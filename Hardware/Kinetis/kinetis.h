/***********************************************************************
    Mark Butcher    Bsc (Hons) MPhil MIET

    M.J.Butcher Consulting
    Birchstrasse 20f,    CH-5406, Rütihof
    Switzerland

    www.uTasker.com    Skype: M_J_Butcher

    ---------------------------------------------------------------------
    File:      kinetis.h
    Project:   Single Chip Embedded Internet
    ---------------------------------------------------------------------
    Copyright (C) M.J.Butcher Consulting 2004..2017
    *********************************************************************
    03.03.2012 Correct PORT5_BLOCK address (K61/K70)                     {1}
    03.03.2012 Add UART2 alternative port mapping on K70                 {2}
    03.03.2012 SDHC_DATPORT declared volatile                            {3}
    04.03.2012 Add NAND Flash Controller defines                         {4}
    09.03.2012 Make PIT control register volatile and add PIT_RETRIGGER  {5}
    12.03.2012 Add ADC interface                                         {6}
    17.04.2012 Add K61, K70 and general F120 support
    08.05.2012 Add K70 UART pins of port F                               {7}
    17.06.2012 Add CRC module                                            {8}
    17.06.2012 Correct some Ethernet register bits                       {9}
    17.06.2012 Make TCR volatile to avoid IAR problem where it tries to access as byte and causes exception {10}
    15.07.2012 Correct Port F addresses                                  {11}
    15.07.2012 Adjust macros _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_LOW() and _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_HIGH() to set PORT_MUX_GPIO {12}
    15.07.2012 Add CPACR (co-processor access control register)          {13}
    22.07.2012 Add fnProgramOnce()                                       {14}
    04.08.2012 Add ETHER_DBSWP to ECR for devices with it                {15}
    11.08.2012 Add 150MHz part speed checking                            {16}
    14.09.2012 Add UART alternative port options to K61                  {17}
    19.11.2012 Add port F and port F bit defines                         {18}
    19.11.2012 Add PHY interface for multi-port devices                  {19}
    26.01.2013 Add RESET_VECTOR_VALIDATION                               {20}
    26.01.2013 Add PHY_KSZ8031 registers                                 {21}
    26.01.2013 Make SPIx_PUSHR volatile                                  {22}
    26.01.2013 Add DAC support                                           {23}
    26.01.2013 Add UTC seconds value to RTC_SETUP                        {24}
    04.02.2013 Add USBHS                                                 {25}
    03.03.2013 Moved RANDOM_SEED_LOCATION and BOOT_MAIL_BOX to this header file {26}
    21.03.2013 Add NAND Flash controller buffer space                    {27}
    24.05.2013 Add DDR1/2/LP SDRAM controller                            {28}
    29.05.2013 Add MCM                                                   {29}
    11.07.2013 Add additional peripheral pin configurations for newer parts {30}
    25.07.2013 Add PDB                                                   {31}
    12.08.2013 Add PB_19_FB_OE                                           {32}
    30.09.2013 Add ADC_SELECT_INPUTS_A and ADC_SELECT_INPUTS_B           {33}
    01.10.2013 Add fnEnterInterrupt() as global prototype                {34}
    04.10.2013 Add PGA control                                           {35}
    27.10.2013 Add ADC DMA configuration                                 {36}
    27.10.2013 Add PDB interface                                         {37}
    19.11.2013 Add DAC DMA configuration                                 {38}
    27.11.2013 Correct _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_HIGH() macro {39}
    22.12.2013 Modified the crossbar master number FS-USB for FPU devices{40}
    26.12.2013 Add RNGA                                                  {41}
    25.01.2014 Add Kinetis KL and KE support                             {42}
    15.02.2014 Add mask revision                                         {43}
    16.02.2014 Add K21 interrupts                                        {44}
    21.02.2014 Add MMCAU                                                 {45}
    08.03.2014 Add K64                                                   {46}
    21.04.2014 Add KL PITs                                               {47}
    06.05.2014 Add KL DMA                                                {48}
    12.05.2014 Correct flash sector size for 50MHz devices               {49}
    08.06.2014 Add crossbar switch registers                             {50}
    15.06.2014 Add low power timer                                       {51}
    19.06.2014 Add KL DAC                                                {52}
    25.06.2014 Add MCGPLL1CLK and PLL1 configuration limits              {53}
    15.07.2014 Add SMC                                                   {54}
    22.07.2014 Add clock source selection to TPM                         {55}
    07.08.2014 Add KE family keyboard interrupt module and IRQ           {56}
    18.09.2014 Add ADC channel B input selection                         {57}
    30.10.2014 Add crystal-less USB clock registers for K64, K63 and K24 {58}
    06.12.2014 Add LPUART                                                {59}
    17.12.2014 Add K70 LCD controller                                    {60}
    21.12.2014 Add chip mask/errata management                           {61}
    10.01.2015 Add LLWU                                                  {62}
    08.02.2015 Add RTC seconds and prescaler in undefined RAM space      {63}
    05.04.2015 Correct polarity of SPI_PUSHR_PCS_NONE                    {64}
    08.06.2015 Correct _CONFIG_PORT_OUTPUT_FAST_HIGH macro               {65}
    10.06.2015 Moved struct packing control to this header               {66}
    10.06.2015 Adjusted flash protection field of KINETIS_FLASH_CONFIGURATION to be a single long word {67}
    10.10.2015 Correct fast and slow IRC speeds in devices with MCG Lite {68}
    16.10.2015 Add fnClkout()                                            {69}
    12.11.2015 Add fnSwapMemory()                                        {70}
    01.12.2015 Add CONTROL_DATA_TOGGLE_REVERSED                          {71}
    03.12.2015 Add K80
    11.12.2015 Add PORT_DMA_MODE and PORT_KEEP_PERIPHERAL                {72}
    14.12.2015 Add I2S                                                   {73}
    19.12.2015 Add DMA trigger source to DAC configuration               {74}
    20.12.2015 Use MCGOUTCLK rather than core clock as divider input (K-parts) {75}
    08.01.2016 Add QSPI                                                  {76}
    09.01.2016 Add USBPHY                                                {77}
    09.01.2016 Enabled ETHER_DBSWP for K64                               {78}
    09.01.2016 Add macros _DIS_ARM_PORT_INTERRUPT() and _RE_ARM_PORT_INTERRUPT() {79}
    26.02.2016 Modified KE02 trimmed internal clock frequency from 37.5kHz to 31.25kHz {80}
    10.03.2015 Correct KE/KEA flash configuration layout                 {81}
    10.03.2015 TPM clock uses IRC48M when available instead of MCGPLLCLK/MCGFLLCLK {82}
    10.03.2015 Add PWM_FREQUENCY()                                       {83}
    18.03.2016 Add NMI_IN_FLASH option                                   {84}
    02.06.2016 Add ACMP and CMP                                          {85}
    20.07.2016 Enable MPU in K22 FN parts with 512k Flash                {86}
    07.09.2016 correct KE operation directly from crystal source when bypassing FEE [RUN_FROM_EXTERNAL_CLOCK] {87}
    09.12.2016 Add PWT                                                   {88}
    26.01.2017 Add external clock source selection to timer interface    {89}
    31.01.2017 Add fnClearPending() and fnIsPending()                    {90}
    11.02.2017 Add system clock generator                                {91}
    14.02.2017 Add LTC                                                   {92}
    08.03.2017 Add PWM_NO_OUTPUT and PWM_DMA_CHANNEL_ENABLE PWM options  {93}
    08.03.2017 Add ucDmaTriggerSource to ADC setup                       {94}
    19.04.2017 Adjust USB FS crossbar master setting for K65 and K66     {95}

*/

#if defined _WINDOWS
    #define _SIM_PORT_CHANGE     fnSimPorts()
    #define _SIM_PER_CHANGE      fnSimPers()
    #define _EXCEPTION(x)        *(unsigned char *)0 = 0                 // generate exception when simulating
    #define _SIM_PORTS           fnSimPorts()
#else
    #if defined _COMPILE_IAR
        #include <intrinsics.h>                                          // for __disable_interrupt(), __enable_interrupt() and __sleep_mode(), etc.
    #endif
    #define _SIM_PORT_CHANGE
    #define _SIM_PER_CHANGE
    #define _EXCEPTION(x)                                                // ignore on target
    #define _SIM_PORTS
#endif

extern int fnClkout(int iClockSource);                                   // {69}
    #define FLEXBUS_CLOCK_OUT              0
    #define RTC_CLOCK_OUT                  1
    #define FLASH_CLOCK_OUT                2
    #define BUS_CLOCK_OUT                  3
    #define LOW_POWER_OSCILLATOR_CLOCK_OUT 4
    #define INTERNAL_LIRC_CLOCK_OUT        5
    #define EXTERNAL_OSCILLATOR_CLOCK_OUT  6
    #define INTERNAL_IRC48M_CLOCK_OUT      7

extern int fnSwapMemory(int iCheck);                                     // {70}
    #define SWAP_STATE_UNINITIALISED       3
    #define SWAP_STATE_SWAPPED             2
    #define SWAP_STATE_USING_1             1
    #define SWAP_STATE_USING_0             0
    #define SWAP_COMMAND_FAILURE          -1
    #define SWAP_ERASE_FAILURE            -2

/* =================================================================== */
/*                           struct packing control {66}               */
/* =================================================================== */

#if defined _GNU
    #define _PACK      __attribute__((__packed__))
#else
    #define _PACK
#endif
#if defined _CODE_WARRIOR_CF  
    #define __PACK_ON  #pragma pack(1) 
    #define __PACK_OFF #pragma pack() 
#elif defined _COMPILE_GHS
    #define __PACK_ON  //#pragma pack(1) 
    #define __PACK_OFF //#pragma pack(0) 
#else
    #define __PACK_ON 
    #define __PACK_OFF 
#endif


#define _MALLOC_ALIGN                                                    // support malloc with align option since LAN memory should be on specific boundary
#define _ALIGN_HEAP_4                                                    // ensure long word alignment
#define _LITTLE_ENDIAN                                                   // compile project in LITTLE ENDIAN mode since the kinetis is fixed in this mode


#define SAVE_COMPLETE_FLASH                                              // when simulating, save complete flash contents and not just the file system contents


#define CAST_POINTER_ARITHMETIC unsigned long                            // Kinetis uses 32 bit pointers


// Mask/errata management  
//
#include "kinetis_errata.h"                                              // {61}

#if defined KINETIS_KL || defined KINETIS_KE
    #define ARM_MATH_CM0PLUS                                             // Cortex-M0 to be used
#else
    #define ARM_MATH_CM4                                                 // Cortex-M4 to be used
#endif

// ROM Bootoader
//
#if (defined KINETIS_KL03 || defined KINETIS_KL43 || defined KINETIS_KL27 || defined KINETIS_KL82) // devices with ROM bootloader
    #define ROM_BOOTLOADER
#endif

// Clock setting/checking
//
#if defined KINETIS_KL28                                                 // devices with SCG (system clock generator)
    #define KINETIS_WITH_SCG                                             // {91}
#elif (defined KINETIS_KL03 || defined KINETIS_KL43 || defined KINETIS_KL27) // devices with MCG-Lite
    #define KINETIS_WITH_MCG_LITE
#elif (defined KINETIS_KL02 || defined KINETIS_KL05)                     // devices with no PLL in MCG
    #define MCG_WITHOUT_PLL
#endif

#if defined KINETIS_K66 && defined PERIPHERAL_CLOCK_DIVIDE
    #if PERIPHERAL_CLOCK_DIVIDE_FRACTION == 5
        #if (PERIPHERAL_CLOCK_DIVIDE == 0)                               // divide by 0.5
            #define PERIPHERAL_CLOCK_DIVIDE_VALUE ((0 << 1) | 0x1)
        #elif (PERIPHERAL_CLOCK_DIVIDE == 1)                             // divide by 1.5
            #define PERIPHERAL_CLOCK_DIVIDE_VALUE ((3 << 1) | 0x1)
        #elif (PERIPHERAL_CLOCK_DIVIDE == 2)                             // divide by 2.5
            #define PERIPHERAL_CLOCK_DIVIDE_VALUE ((5 << 1) | 0x1)
        #elif (PERIPHERAL_CLOCK_DIVIDE == 3)                             // divide by 3.5
            #define PERIPHERAL_CLOCK_DIVIDE_VALUE ((7 << 1) | 0x1)
        #else
            #error Invalid peripheral divide value - integer must be 0,1,2 or 3 when used with a fraction (0.5)
        #endif
    #else
        #if (PERIPHERAL_CLOCK_DIVIDE < 1) || (PERIPHERAL_CLOCK_DIVIDE < 8)
            #error Invalid peripheral divide value - must be 1,2,3,4,5,6,7 or 8
        #endif
        #define PERIPHERAL_CLOCK_DIVIDE_VALUE ((PERIPHERAL_CLOCK_DIVIDE - 1) << 1)
    #endif
#endif

#if defined KINETIS_KE || defined KINETIS_KV10 || (defined KINETIS_KL && !defined KINETIS_KL82)
    #define BUS_FLASH_CLOCK_SHARED                                       // bus and flash clocks are shared and so have the same speed
#endif

#if (defined KINETIS_K60 && (KINETIS_MAX_SPEED >= 120000000)) || defined KINETIS_K61 || defined KINETIS_K70 || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
    #define HS_USB_AVAILABLE
    #if defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
        #define KINETIS_WITH_USBPHY                                      // USB2.0 PHY integrated in device
    #endif
#endif

#if (defined KINETIS_K22 && !defined KINETIS_FLEX && ((SIZE_OF_FLASH >= (128 * 1024)) && (SIZE_OF_FLASH <= (512 * 1024)))) || defined KINETIS_K80 || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_KL28 || defined KINETIS_KL82
    #define HIGH_SPEED_RUN_MODE_AVAILABLE
#endif

#if (defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000) || defined KINETIS_KL82) && !defined KINETIS_KV30 && !defined KINETIS_K21 && !defined KINETIS_K22 && !defined KINETIS_K24 && !defined KINETIS_K64
    #if defined FLL_FACTOR                                               // using FLL
        #define CLOCK_DIV   1
        #define CLOCK_MUL   FLL_FACTOR
        #if (FLL_FACTOR == 640)
            #define _FLL_VALUE (MCG_C4_LOW_RANGE)
        #elif (FLL_FACTOR == 732)
            #define _FLL_VALUE (MCG_C4_LOW_RANGE | MCG_C4_DMX32)
        #elif (FLL_FACTOR == 1280)
            #define _FLL_VALUE (MCG_C4_MID_RANGE)
        #elif (FLL_FACTOR == 1464)
            #define _FLL_VALUE (MCG_C4_MID_RANGE | MCG_C4_DMX32)
        #elif (FLL_FACTOR == 1920)
            #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE)
        #elif (FLL_FACTOR == 2197)
            #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE | MCG_C4_DMX32)
        #elif (FLL_FACTOR == 2560)
            #define _FLL_VALUE (MCG_C4_HIGH_RANGE)
        #elif (FLL_FACTOR == 2929)
            #define _FLL_VALUE (MCG_C4_HIGH_RANGE | MCG_C4_DMX32)
        #else
            #error Invalid FLL factor has been specified - valid are 640, 732, 1280, 1464, 1920, 2197, 2560 or 2929
        #endif
    #else
        #if defined CLOCK_DIV
            #if (CLOCK_DIV < 1) || (CLOCK_DIV > 8)
                #error input divide must be between 1 and 8
            #endif
            #if (CLOCK_MUL < 16) || (CLOCK_MUL > 47)
                #error PLL multiplier must be between 16 and 47
            #endif
            #if ((_EXTERNAL_CLOCK/CLOCK_DIV) < 8000000) || ((_EXTERNAL_CLOCK/CLOCK_DIV) > 16000000)
                #error PLL input frequency must be between 8MHz and 16MHz
            #endif
        #endif
        #if defined CLOCK_DIV_1                                          // {53}
            #if (CLOCK_DIV_1 < 1) || (CLOCK_DIV_1 > 8)
                #error PLL1 input divide must be between 1 and 8
            #endif
            #if (CLOCK_MUL_1 < 16) || (CLOCK_MUL_1 > 47)
                #error PLL1 multiplier must be between 16 and 47
            #endif
            #if ((_EXTERNAL_CLOCK / CLOCK_DIV_1) < 8000000) || ((_EXTERNAL_CLOCK / CLOCK_DIV_1) > 16000000)
                #error PLL1 input frequency must be between 8MHz and 16MHz
            #endif
        #endif
    #endif
#elif defined KINETIS_K21 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_K64 || defined KINETIS_KV30 // {44}
    #if !defined RUN_FROM_EXTERNAL_CLOCK && !defined RUN_FROM_DEFAULT_CLOCK && !defined RUN_FROM_HIRC && !defined FLL_FACTOR && !defined RUN_FROM_LIRC // no PLL/FLL used
        #if (CLOCK_DIV < 1) || (CLOCK_DIV > 24)
            #error input divide must be between 1 and 24
        #endif
        #if (CLOCK_MUL < 24) || (CLOCK_MUL > 55)
            #error PLL multiplier must be between 24 and 55
        #endif
        #if ((_EXTERNAL_CLOCK / CLOCK_DIV) < 2000000) || ((_EXTERNAL_CLOCK / CLOCK_DIV) > 4000000)
            #error PLL input frequency must be between 2MHz and 4MHz
        #endif
    #endif
#elif defined KINETIS_KE                                                 // {42}
    #if (defined KINETIS_KEA && KINETIS_MAX_SPEED <= 40000000) || defined KINETIS_KE02 // {80}
        #define ICSIRCLK        31250                                    // trimmed internal 31.25kHz clock
    #else
        #define ICSIRCLK        37500                                    // trimmed internal 37.5kHz clock
    #endif
    #if defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define MAX_HIGH_RANGE_XTAL   (24000000)
    #else
        #define MAX_HIGH_RANGE_XTAL   (20000000)
    #endif
    #if !defined RUN_FROM_DEFAULT_CLOCK
        #if ((CRYSTAL_FREQUENCY >= 4000000) && (CRYSTAL_FREQUENCY <= MAX_HIGH_RANGE_XTAL)) // select crystal range setting depending on the crystal used
            #define _OSC_RANGE   (OSC_CR_RANGE_HIGH)
        #elif ((CRYSTAL_FREQUENCY >= 31250) && (CRYSTAL_FREQUENCY <= 39063)) // {87}
            #define _OSC_RANGE   (OSC_CR_RANGE_LOW)
        #else
            #error Invalid crystal frequency!! (either 32kHz range or 4MHz..MAX_HIGH_RANGE_XTAL)
        #endif
        #if defined RUN_FROM_EXTERNAL_CLOCK                              // {87}
             #define _FLL_VALUE (ICS_C1_RDIV_RANGE1_1024)                // value is not important when driven directly by oscillator input
        #else
            #if (CLOCK_DIV == 1)                                         // only possible with low frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #error Invalid clock divide from high frequency crystal
                #else
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE0_1)
                #endif
            #elif (CLOCK_DIV == 2)                                       // only possible with low frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #error Invalid clock divide from high frequency crystal
                #else
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE0_2)
                #endif
            #elif (CLOCK_DIV == 4)                                       // only possible with low frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #error Invalid clock divide from high frequency crystal
                #else
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE0_4)
                #endif
            #elif (CLOCK_DIV == 8)                                       // only possible with low frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #error Invalid clock divide from high frequency crystal
                #else
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE0_8)
                #endif
            #elif (CLOCK_DIV == 16)                                      // only possible with low frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #error Invalid clock divide from high frequency crystal
                #else
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE0_16)
                #endif
            #elif (CLOCK_DIV == 32)
                #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE | MCG_C4_DMX32)
            #elif (CLOCK_DIV == 64)
                #define _FLL_VALUE (MCG_C4_HIGH_RANGE)
            #elif (CLOCK_DIV == 128)
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE1_128)
                #else
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE0_128)
                #endif
            #elif (CLOCK_DIV == 256)                                     // only possible with high frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE1_256)
                #else
                    #error Invalid clock divide from low frequency crystal            
                #endif
            #elif (CLOCK_DIV == 512)                                     // only possible with high frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE1_512)
                #else
                    #error Invalid clock divide from low frequency crystal            
                #endif
            #elif (CLOCK_DIV == 1024)                                    // only possible with high frequency crystal
                #if  (_OSC_RANGE == OSC_CR_RANGE_HIGH)
                    #define _FLL_VALUE (ICS_C1_RDIV_RANGE1_1024)
                #else
                    #error Invalid clock divide from low frequency crystal            
                #endif
            #else
                #error Invalid input clock divide has been specified - valid are 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 or 1024
            #endif
            #if (((_EXTERNAL_CLOCK / CLOCK_DIV) > 39066) || ((_EXTERNAL_CLOCK / CLOCK_DIV) < 31250))
                #error Invalid FLL input frequency - 31.25kHz..39.06525kHz required
            #endif
        #endif
    #endif
    #if (SYSTEM_CLOCK_DIVIDE == 1)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_1)
    #elif (SYSTEM_CLOCK_DIVIDE == 2)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_2)
    #elif (SYSTEM_CLOCK_DIVIDE == 4)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_4)
    #elif (SYSTEM_CLOCK_DIVIDE == 8)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_8)
    #elif (SYSTEM_CLOCK_DIVIDE == 16)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_16)
    #elif (SYSTEM_CLOCK_DIVIDE == 32)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_32)
    #elif (SYSTEM_CLOCK_DIVIDE == 64)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_64)
    #elif (SYSTEM_CLOCK_DIVIDE == 128)
        #define _SYSCLK__DIV   (ICS_C2_BDIV_128)
    #else
        #error Invalid system clock (ICSCLK) divide has been specified - valid are 1, 2, 4, 8, 16, 32, 64 or 128
    #endif
    #if (BUS_CLOCK_DIVIDE != 1) && (BUS_CLOCK_DIVIDE != 2)
        #error Invalid bus clock divide has been specified - valid are 1 or 2
    #endif
    #if defined KINETIS_KE04 || defined KINETIS_KE06 || (defined KINETIS_KEA && (KINETIS_MAX_SPEED > 40000000))
        #define CLOCK_MUL  (1280)                                        // fixed FLL multiplier
    #else
        #define CLOCK_MUL  (1024)                                        // fixed FLL multiplier
    #endif
#elif defined KINETIS_KL || defined KINETIS_KV                           // {42}
    #if defined KINETIS_KV
        #define KINETIS_MAX_SPEED   75000000
    #elif defined KINETIS_WITH_SCG                                       // {91}
        #define KINETIS_MAX_SPEED   96000000                             // run mode required for highest speed (72MHz in run mode)
    #else
        #define KINETIS_MAX_SPEED   48000000
    #endif
    #if defined FLL_FACTOR                                               // FLL being used
        #define CLOCK_DIV   1
        #define CLOCK_MUL   FLL_FACTOR
        #if (FLL_FACTOR == 640)
            #define _FLL_VALUE (MCG_C4_LOW_RANGE)
        #elif (FLL_FACTOR == 732)
            #define _FLL_VALUE (MCG_C4_LOW_RANGE | MCG_C4_DMX32)
        #elif (FLL_FACTOR == 1280)
            #define _FLL_VALUE (MCG_C4_MID_RANGE)
        #elif (FLL_FACTOR == 1464)
            #define _FLL_VALUE (MCG_C4_MID_RANGE | MCG_C4_DMX32)
        #elif (FLL_FACTOR == 1920)
            #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE)
        #elif (FLL_FACTOR == 2197)
            #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE | MCG_C4_DMX32)
        #elif (FLL_FACTOR == 2560)
            #define _FLL_VALUE (MCG_C4_HIGH_RANGE)
        #elif (FLL_FACTOR == 2929)
            #define _FLL_VALUE (MCG_C4_HIGH_RANGE | MCG_C4_DMX32)
        #else
            #error Invalid FLL factor has been specified - valid are 640, 732, 1280, 1464, 1920, 2197, 2560 or 2929
        #endif
    #elif defined KINETIS_WITH_MCG_LITE || defined RUN_FROM_LIRC || defined RUN_FROM_DEFAULT_CLOCK || defined KINETIS_WITH_SCG
    #else
        #if (CLOCK_DIV < 1) || (CLOCK_DIV > 25)
            #error input divide must be between 1 and 25
        #endif
        #if (CLOCK_MUL < 24) || (CLOCK_MUL > 55)
            #error PLL multiplier must be between 24 and 55
        #endif
        #if ((_EXTERNAL_CLOCK / CLOCK_DIV) < 2000000) || ((_EXTERNAL_CLOCK / CLOCK_DIV) > 4000000)
            #if !defined KINETIS_KL || (((_EXTERNAL_CLOCK / CLOCK_DIV) < 30000) || ((_EXTERNAL_CLOCK / CLOCK_DIV) > 40000)) // 32kHz crystal allowed
                #error PLL input frequency must be between 2MHz and 4MHz (or 32kHz)
            #endif
        #endif
    #endif
#elif !defined RUN_FROM_DEFAULT_CLOCK                                    // default is K-series
    #if (CLOCK_DIV < 1) || (CLOCK_DIV > 25)
        #error input divide must be between 1 and 25
    #endif
    #if (CLOCK_MUL < 24) || (CLOCK_MUL > 55)
        #error PLL multiplier must be between 24 and 55
    #endif
    #if ((_EXTERNAL_CLOCK / CLOCK_DIV) < 2000000) || ((_EXTERNAL_CLOCK / CLOCK_DIV) > 4000000)
        #if !defined KINETIS_KL || (((_EXTERNAL_CLOCK / CLOCK_DIV) < 30000) || ((_EXTERNAL_CLOCK / CLOCK_DIV) > 40000)) // 32kHz crystal allowed
            #error PLL input frequency must be between 2MHz and 4MHz (or 32kHz)
        #endif
    #endif
#endif
#if (SYSTEM_CLOCK_DIVIDE < 1) || (SYSTEM_CLOCK_DIVIDE > 16)
    #error the core/system clock divide value must be between 1 and 16
#endif
#if defined KINETIS_WITH_MCG_LITE
    #if (BUS_CLOCK_DIVIDE < 1) || (BUS_CLOCK_DIVIDE > 8)
        #error the bus/peripheral clock divide value must be between 1 and 8
    #endif
#else
    #if (BUS_CLOCK_DIVIDE < 1) || (BUS_CLOCK_DIVIDE > 16)
        #error the bus/peripheral clock divide value must be between 1 and 16
    #endif
#endif
#if (FLEX_CLOCK_DIVIDE < 1) || (FLEX_CLOCK_DIVIDE > 16)
    #error the flex bus clock divide value must be between 1 and 16
#endif
#if (FLASH_CLOCK_DIVIDE < 1) || (FLASH_CLOCK_DIVIDE > 16)
    #error the flash clock divide value must be between 1 and 16
#endif


// Clock definitions
//
#if !defined KINETIS_KE
    #if (defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000) || defined KINETIS_KL82) && !defined KINETIS_K21 && !defined KINETIS_K22 && !defined KINETIS_K24 && !defined KINETIS_K64 && !defined KINETIS_KV30
        #if defined FLL_FACTOR
            #if defined RUN_FROM_HIRC_FLL
                #define MCGOUTCLK      ((48000000/1536) * FLL_FACTOR)    // 48MHz/1536 IRC multiplied by the FLL factor
            #else
                #define MCGOUTCLK      (35000 * FLL_FACTOR)              // 32kHz IRC multiplied by the FLL factor
            #endif
        #elif defined RUN_FROM_HIRC
            #define MCGOUTCLK          48000000
        #else
            #define MCGOUTCLK          (((_EXTERNAL_CLOCK/CLOCK_DIV) * CLOCK_MUL)/2) // up to 120MHz/150MHz (PLL0 clock output)
            #if defined CLOCK_DIV_1                                      // {53}
                #define MCGPLL1CLK     (((_EXTERNAL_CLOCK/CLOCK_DIV_1) * CLOCK_MUL_1)/2) // up to 120MHz/150MHz (PLL1 clock output)
            #endif
        #endif
    #elif defined KINETIS_WITH_SCG
        #define MCGOUTCLK              48000000 // temp
#define DIVCORE 1
#define DIVSLOW 3
        #define DIVCORE_CLK            (MCGOUTCLK/DIVCORE)
        #define DIVSLOW_CLK            (DIVCORE_CLK/DIVSLOW) // flash and bus clock
    #elif defined KINETIS_WITH_MCG_LITE
        #if defined RUN_FROM_HIRC
            #define MCGOUTCLK          48000000
        #elif defined RUN_FROM_LIRC
            #if defined RUN_FROM_LIRC_2M
                #define IRC_CLOCK      2000000
            #else
                #define IRC_CLOCK      8000000
            #endif
            #if defined SLOW_CLOCK_DIVIDE
                #if (SLOW_CLOCK_DIVIDE == 1)
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_1)
                #elif SLOW_CLOCK_DIVIDE == 2
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_2)
                #elif SLOW_CLOCK_DIVIDE == 4
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_4)
                #elif SLOW_CLOCK_DIVIDE == 8
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_8)
                #elif SLOW_CLOCK_DIVIDE == 16
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_16)
                #elif SLOW_CLOCK_DIVIDE == 32
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_32)
                #elif SLOW_CLOCK_DIVIDE == 64
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_64)
                #elif SLOW_CLOCK_DIVIDE == 128
                    #define SLOW_CLOCK_DIVIDE_VALUE  (MCG_SC_FCRDIV_132)
                #else
                    #error "Slow clock divider must be 1,2,4,8,16,32 or 128!!"
                #endif
                #define MCGOUTCLK  ((IRC_CLOCK)/(SLOW_CLOCK_DIVIDE))
            #else
                #define MCGOUTCLK  (IRC_CLOCK)
            #endif
        #else
            #define MCGOUTCLK  (_EXTERNAL_CLOCK)                         // run directly from EXT
        #endif
    #elif defined RUN_FROM_LIRC && (defined KINETIS_KL || defined KINETIS_K22)
        #define MCGOUTCLK      (4000000)
    #elif defined RUN_FROM_HIRC
        #define MCGOUTCLK      (48000000)
    #else
        #if defined RUN_FROM_EXTERNAL_CLOCK
            #define MCGOUTCLK  (_EXTERNAL_CLOCK)                         // connected directly to input clock
        #elif defined RUN_FROM_DEFAULT_CLOCK
            #if defined FLL_FACTOR
                #define MCGOUTCLK  ((32768) * FLL_FACTOR)                // assume tuned to 32768kHz
            #else
                #define MCGOUTCLK  ((32768) * 640)                       // 20.971MHz nominal (20MHz..25MHz)
            #endif
        #elif defined FLL_FACTOR                                         // FLL is to be used with input from the external source
            #if !defined FRDIVIDER                                       // if no input divider for the FLL is defined default to 1
                #if defined RUN_FROM_HIRC_FLL
                    #define FRDIVIDER    1280                            // default the FLL input divider to 1280 to give 37500 (range 31.25kHz..39.0625kHz)
                #else
                    #define FRDIVIDER    1
                #endif
            #endif
            #if (FLL_FACTOR == 640)
                #define _FLL_VALUE (MCG_C4_LOW_RANGE)
            #elif (FLL_FACTOR == 732)
                #define _FLL_VALUE (MCG_C4_LOW_RANGE | MCG_C4_DMX32)
            #elif (FLL_FACTOR == 1280)
                #define _FLL_VALUE (MCG_C4_MID_RANGE)
            #elif (FLL_FACTOR == 1464)
                #define _FLL_VALUE (MCG_C4_MID_RANGE | MCG_C4_DMX32)
            #elif (FLL_FACTOR == 1920)
                #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE)
            #elif (FLL_FACTOR == 2197)
                #define _FLL_VALUE (MCG_C4_MID_HIGH_RANGE | MCG_C4_DMX32)
            #elif (FLL_FACTOR == 2560)
                #define _FLL_VALUE (MCG_C4_HIGH_RANGE)
            #elif (FLL_FACTOR == 2929)
                #define _FLL_VALUE (MCG_C4_HIGH_RANGE | MCG_C4_DMX32)
            #else
                #error Invalid FLL factor has been specified - valid are 640, 732, 1280, 1464, 1920, 2197, 2560 or 2929
            #endif
            #define MCGOUTCLK  ((_EXTERNAL_CLOCK / FRDIVIDER) * FLL_FACTOR) // FLL clock output
        #else
            #define MCGOUTCLK  ((_EXTERNAL_CLOCK/CLOCK_DIV) * CLOCK_MUL) // up to 100/120MHz (PLL0 clock output)
        #endif
    #endif
    #define CORE_CLOCK         (MCGOUTCLK/SYSTEM_CLOCK_DIVIDE)           // up to 100MHz/120MHz/150MHz
    #define SYSTEM_CLOCK       CORE_CLOCK                                // up to 100MHz/120MHz/150MHz
    #if defined KINETIS_WITH_SCG
        #define BUS_CLOCK      DIVSLOW_CLK
        #define FLASH_CLOCK    DIVSLOW_CLK
    #elif defined KINETIS_KL || defined KINETIS_KE
        #define BUS_CLOCK      (CORE_CLOCK/BUS_CLOCK_DIVIDE)             // up to 50MHz/60MHz but must not be faster than the core clock {75}
        #define FLASH_CLOCK    (CORE_CLOCK/BUS_CLOCK_DIVIDE)             // up to 25MHz but must not be faster than the bus clock {75}
    #else
        #define BUS_CLOCK      (MCGOUTCLK/BUS_CLOCK_DIVIDE)              // up to 50MHz/60MHz but must not be faster than the core clock {75}
        #define FLEXBUS_CLOCK  (MCGOUTCLK/FLEX_CLOCK_DIVIDE)             // up to 50MHz but must not be faster than the bus clock {75}
        #define FLASH_CLOCK    (MCGOUTCLK/FLASH_CLOCK_DIVIDE)            // up to 25MHz but must not be faster than the bus clock {75}
    #endif
    #if defined KINETIS_WITH_MCG_LITE                                    // {68}
        #define FAST_ICR       8000000
        #define SLOW_ICR       2000000
    #else
        #define FAST_ICR       4000000
        #define SLOW_ICR       32768
    #endif
    #if defined USE_FAST_INTERNAL_CLOCK || (defined RUN_FROM_LIRC && !defined RUN_FROM_LIRC_2M) // if not selected the slow internal clock is used (when needed)
        #define MCGIRCLK       FAST_ICR                                  // 4MHz (8MHz for devices with MCG Lite)
    #else
        #define MCGIRCLK       SLOW_ICR                                  // 30..40kHz (2MHz for devices with MCG Lite)
    #endif
    #define MCGFFCLK
    #define MCGFLLCLK          MCGOUTCLK
    #define MCGPLLCLK          MCGOUTCLK
    #define MCG_EXT_REF_CLOCK
    #define OSCCLK
    #if defined EXTERNAL_CLOCK
        #define OSCERCLK       EXTERNAL_CLOCK
    #else
        #if defined CRYSTAL_FREQUENCY
            #define OSCERCLK   CRYSTAL_FREQUENCY
        #endif
    #endif
    #define OSC32KCLK
    #define ERCLK32K
    #define RTC_CLOCK
    #define LPO_1K_OUTPUT                                                    // 1kHz
#endif

#if defined USB_INTERFACE
    #if SYSTEM_CLOCK < 20000000
        #error system clock much be at least 20MHz to allow USB operation!
    #endif
#endif

#if defined KINETIS_K_FPU                                                // 120/150/180/220MHz device
    #if KINETIS_MAX_SPEED == 220000000                                   // 220MHz part (high-speed run mode)
        #if CORE_CLOCK > 220000000
            #error PLL frequency out of range: maximum 220MHz
        #endif
        #if BUS_CLOCK > 27500000
            #error bus clock frequency out of range: maximum 27.5MHz
        #endif
        #if BUS_CLOCK > CORE_CLOCK
            #error bus clock may not be faster than the system clock!
        #endif
        #if FLEXBUS_CLOCK > 55000000
            #error flex bus clock frequency out of range: maximum 55MHz
        #endif
        #if FLEXBUS_CLOCK > BUS_CLOCK
            #error flex bus clock may not be faster than the bus clock!
        #endif
        #if FLASH_CLOCK > 27500000
            #error flash clock frequency out of range: maximum 27.5MHz
        #endif
        #if FLASH_CLOCK > BUS_CLOCK
            #error flash clock may not be faster than the bus clock!
        #endif
    #elif KINETIS_MAX_SPEED == 180000000                                 // 180MHz part (high-speed run mode)
        #define KINETIS_MAX_DDR_SPEED  180000000
        #if CORE_CLOCK > 180000000
            #error PLL frequency out of range: maximum 180MHz
        #endif
        #if BUS_CLOCK > 60000000
            #error bus clock frequency out of range: maximum 60MHz
        #endif
        #if BUS_CLOCK > CORE_CLOCK
            #error bus clock may not be faster than the system clock!
        #endif
        #if FLEXBUS_CLOCK > 60000000
            #error flex bus clock frequency out of range: maximum 60MHz
        #endif
        #if FLEXBUS_CLOCK > BUS_CLOCK
            #error flex bus clock may not be faster than the bus clock!
        #endif
        #if FLASH_CLOCK > 28000000
            #error flash clock frequency out of range: maximum 28MHz
        #endif
        #if FLASH_CLOCK > BUS_CLOCK
            #error flash clock may not be faster than the bus clock!
        #endif
    #elif KINETIS_MAX_SPEED == 150000000                                 // 150MHz part                                            // {16}
        #define KINETIS_MAX_DDR_SPEED  150000000                         // {28}
        #if CORE_CLOCK > 150000000
            #error PLL frequency out of range: maximum 120MHz
        #endif
        #if BUS_CLOCK > 75000000
            #error bus clock frequency out of range: maximum 75MHz
        #endif
        #if BUS_CLOCK > CORE_CLOCK
            #error bus clock may not be faster than the system clock!
        #endif
        #if defined KINETIS_K80
            #if FLEXBUS_CLOCK > 75000000
                #error flex bus clock frequency out of range: maximum 75MHz
            #endif
            #if FLASH_CLOCK > 28000000
                #error flash clock frequency out of range: maximum 28MHz
            #endif
        #else
            #if FLEXBUS_CLOCK > 50000000
                #error flex bus clock frequency out of range: maximum 50MHz
            #endif
            #if FLASH_CLOCK > 25000000
                #error flash clock frequency out of range: maximum 25MHz
            #endif
        #endif
        #if FLEXBUS_CLOCK > BUS_CLOCK
            #error flex bus clock may not be faster than the bus clock!
        #endif
        #if FLASH_CLOCK > BUS_CLOCK
            #error flash clock may not be faster than the bus clock!
        #endif
    #elif KINETIS_MAX_SPEED == 100000000
        #if CORE_CLOCK > 100000000
            #error FLL frequency out of range: maximum 100MHz
        #endif
        #if BUS_CLOCK > 50000000
            #error bus clock frequency out of range: maximum 50MHz
        #endif
        #if BUS_CLOCK > CORE_CLOCK
            #error bus clock may not be faster than the system clock!
        #endif
        #if FLASH_CLOCK > 25000000
            #error flash clock frequency out of range: maximum 25MHz
        #endif
        #if FLASH_CLOCK > BUS_CLOCK
            #error flash clock may not be faster than the bus clock!
        #endif
    #else
        #define KINETIS_MAX_SPEED  120000000
        #define KINETIS_MAX_DDR_SPEED  125000000                         // {28}
        #if CORE_CLOCK > 120000000
            #error PLL frequency out of range: maximum 120MHz
        #endif
        #if BUS_CLOCK > 60000000
            #error bus clock frequency out of range: maximum 60MHz
        #endif
        #if BUS_CLOCK > CORE_CLOCK
            #error bus clock may not be faster than the system clock!
        #endif
        #if FLEXBUS_CLOCK > 50000000
            #error flex bus clock frequency out of range: maximum 50MHz
        #endif
        #if FLEXBUS_CLOCK > BUS_CLOCK
            #error flex bus clock may not be faster than the bus clock!
        #endif
        #if defined HIGH_SPEED_RUN_MODE_AVAILABLE
            #if KINETIS_MAX_SPEED > 100000000
                #if (CORE_CLOCK > 80000000) || (SYSTEM_CLOCK > 80000000) || (BUS_CLOCK > 50000000)
                    #define HIGH_SPEED_RUN_MODE_REQUIRED                             // to operate at the configured speeds the high speed mode (with restrictions) must be used
                    #if defined FLASH_ROUTINES || defined FLASH_FILE_SYSTEM
                        #error Flash writes/erase are not possible in high speed run mode!
                    #endif
                #endif
            #else
                #if (CORE_CLOCK > 72000000) || (SYSTEM_CLOCK > 72000000)
                    #define HIGH_SPEED_RUN_MODE_REQUIRED                             // to operate at the configured speeds the high speed mode (with restrictions) must be used
                    #if defined FLASH_ROUTINES
                        #error Flash writes/erase are not possible in high speed run mode!
                    #endif
                #endif
            #endif
            #if FLASH_CLOCK > 26680000
                #error flash clock frequency out of range: maximum 26.67MHz
            #endif
        #else
            #if FLASH_CLOCK > 25000000
                #error flash clock frequency out of range: maximum 25MHz
            #endif
        #endif
        #if FLASH_CLOCK > BUS_CLOCK
            #error flash clock may not be faster than the bus clock!
        #endif
    #endif
#elif defined KINETIS_KE
    #if defined RUN_FROM_EXTERNAL_CLOCK
        #define ICSOUT_CLOCK   ((_EXTERNAL_CLOCK)/SYSTEM_CLOCK_DIVIDE)
    #elif defined RUN_FROM_DEFAULT_CLOCK
        #define ICSOUT_CLOCK   ((ICSIRCLK * CLOCK_MUL)/SYSTEM_CLOCK_DIVIDE)
    #else
        #define ICSOUT_CLOCK   (((_EXTERNAL_CLOCK / CLOCK_DIV) * CLOCK_MUL)/SYSTEM_CLOCK_DIVIDE)
    #endif
    #define SYSTEM_CLOCK   (ICSOUT_CLOCK)
    #define CORE_CLOCK     (ICSOUT_CLOCK)
    #define BUS_CLOCK      (ICSOUT_CLOCK/BUS_CLOCK_DIVIDE)
    #if SYSTEM_CLOCK > KINETIS_MAX_SPEED
        #error ICSOUT/system frequency out of range: maximum KINETIS_MAX_SPEED
    #endif
    #if KINETIS_MAX_SPEED == 48000000
        #if BUS_CLOCK > 24000000
            #error Bus frequency out of range: maximum 24MHz
        #endif
    #else
        #if BUS_CLOCK > 20000000
            #error Bus frequency out of range: maximum 20MHz
        #endif
    #endif

    // RTC clock
    //
    #if defined RTC_USES_EXT_CLK || defined RTC_USES_INT_REF
        #if RTC_CLOCK_PRESCALER_1 == 1
            #define _RTC_PRESCALER    RTC_SC_RTCPS_1
        #elif RTC_CLOCK_PRESCALER_1 == 2
            #define _RTC_PRESCALER    RTC_SC_RTCPS_2
        #elif RTC_CLOCK_PRESCALER_1 == 4
            #define _RTC_PRESCALER    RTC_SC_RTCPS_4
        #elif RTC_CLOCK_PRESCALER_1 == 8
            #define _RTC_PRESCALER    RTC_SC_RTCPS_8
        #elif RTC_CLOCK_PRESCALER_1 == 16
            #define _RTC_PRESCALER    RTC_SC_RTCPS_16
        #elif RTC_CLOCK_PRESCALER_1 == 32
            #define _RTC_PRESCALER    RTC_SC_RTCPS_32
        #elif RTC_CLOCK_PRESCALER_1 == 64
            #define _RTC_PRESCALER    RTC_SC_RTCPS_64
        #else
            #error invalid RTC clock prescaler value (1, 2, 4, 8, 16, 32 or 64)
        #endif
        #if defined RTC_USES_EXT_CLK
            #define _RTC_CLOCK_SOURCE  RTC_SC_RTCLKS_EXT
        #else
            #define _RTC_CLOCK_SOURCE  RTC_SC_RTCLKS_INT
        #endif
    #elif defined RTC_USES_BUS_CLOCK || defined RTC_USES_LPO_1kHz
        #if RTC_CLOCK_PRESCALER_2 == 128
            #define _RTC_PRESCALER    RTC_SC_RTCPS_128
        #elif RTC_CLOCK_PRESCALER_2 == 256
            #define _RTC_PRESCALER    RTC_SC_RTCPS_256
        #elif RTC_CLOCK_PRESCALER_2 == 512
            #define _RTC_PRESCALER    RTC_SC_RTCPS_512
        #elif RTC_CLOCK_PRESCALER_2 == 1024
            #define _RTC_PRESCALER    RTC_SC_RTCPS_1024
        #elif RTC_CLOCK_PRESCALER_2 == 2048
            #define _RTC_PRESCALER    RTC_SC_RTCPS_2048
        #elif RTC_CLOCK_PRESCALER_2 == 100
            #define _RTC_PRESCALER    RTC_SC_RTCPS_100
        #elif RTC_CLOCK_PRESCALER_2 == 1000
            #define _RTC_PRESCALER    RTC_SC_RTCPS_1000
        #else
            #error invalid RTC clock presacler value (128, 256, 512, 1024, 2048, 100 or 1000)
        #endif
        #if defined RTC_USES_BUS_CLOCK
            #define _RTC_CLOCK_SOURCE  RTC_SC_RTCLKS_BUS
        #else
            #define _RTC_CLOCK_SOURCE  RTC_SC_RTCLKS_1K
        #endif
    #endif
#elif defined KINETIS_KV
    #if CORE_CLOCK > 75000000
       // #error Core/system frequency out of range: maximum 75MHz
    #endif
    #if BUS_CLOCK > 25000000                                             // flash clock is the same as bus clock
      //#error bus clock frequency out of range: maximum 25MHz
    #endif
    #if FLASH_CLOCK > 25000000
      //#error Flash clock frequency out of range: maximum 25MHz
    #endif
#elif defined KINETIS_KL
    #if defined KINETIS_WITH_SCG || defined KINETIS_KL82
        #if CORE_CLOCK > 96000000
            #error Core/system frequency out of range: maximum 96MHz
        #elif CORE_CLOCK > 72000000
            #define HIGH_SPEED_RUN_MODE_REQUIRED                         // to operate at the configured speeds the high speed mode (with restrictions) must be used
            #if defined FLASH_ROUTINES || defined FLASH_FILE_SYSTEM
                #error Flash writes/erase are not possible in high speed run mode!
            #endif
        #endif
        #if BUS_CLOCK > (24000000)                                       // flash clock is the same as bus clock
            #error bus clock frequency out of range: maximum 24MHz
        #endif
        #if FLASH_CLOCK > 24000000
            #error Flash clock frequency out of range: maximum 24MHz
        #endif
    #else
        #if CORE_CLOCK > 48000000
            #error Core/system frequency out of range: maximum 48MHz
        #endif
        #if BUS_CLOCK > (24000000)                                       // flash clock is the same as bus clock
            #error bus clock frequency out of range: maximum 24MHz
        #endif
        #if FLASH_CLOCK > 24000000
            #error Flash clock frequency out of range: maximum 24MHz
        #endif
    #endif
#elif defined KINETIS_MAX_SPEED                                          // device speed defined for particular device
    #if CORE_CLOCK > KINETIS_MAX_SPEED
        #error PLL frequency out of range: maximum 100MHz
    #endif
    #if KINETIS_MAX_SPEED == 50000000
        #if BUS_CLOCK > (50000000)
            #error bus clock frequency out of range: maximum 50MHz
        #endif
    #elif BUS_CLOCK > (KINETIS_MAX_SPEED/2)
        #error bus clock frequency out of range: maximum KINETIS_MAX_SPEED/2
    #endif
    #if BUS_CLOCK > (CORE_CLOCK)
        #error bus clock may not be faster than the system clock!
    #endif
    #if FLEXBUS_CLOCK > (KINETIS_MAX_SPEED/2)
        #error flex bus clock frequency out of range: maximum 50MHz
    #endif
    #if FLEXBUS_CLOCK > (BUS_CLOCK)
        #error flex bus clock may not be faster than the bus clock!
    #endif
    #if FLASH_CLOCK > 25000000
        #error flash clock frequency out of range: maximum 25MHz
    #endif
    #if FLASH_CLOCK > (BUS_CLOCK)
        #error flash clock may not be faster than the bus clock!
    #endif
#else                                                                    // 100MHz device
    #define KINETIS_MAX_SPEED  100000000
    #if CORE_CLOCK > 100000000
        #error PLL frequency out of range: maximum 100MHz
    #endif
    #if BUS_CLOCK > 50000000
        #error bus clock frequency out of range: maximum 50MHz
    #endif
    #if BUS_CLOCK > CORE_CLOCK
        #error bus clock may not be faster than the system clock!
    #endif
    #if FLEXBUS_CLOCK > 50000000
        #error flex bus clock frequency out of range: maximum 50MHz
    #endif
    #if FLEXBUS_CLOCK > BUS_CLOCK
        #error flex bus clock may not be faster than the bus clock!
    #endif
    #if FLASH_CLOCK > 25000000
        #error flash clock frequency out of range: maximum 25MHz
    #endif
    #if FLASH_CLOCK > BUS_CLOCK
        #error flash clock may not be faster than the bus clock!
    #endif
#endif

#define PLL_OUTPUT_FREQ    (CORE_CLOCK)                                  // this is for simulation compatibility and is set to the core/system clock frequency which is not necessarily equal to the real PLL frequency

typedef struct stKINETIS_CAN_BUF
{
    volatile unsigned long ulCode_Len_TimeStamp;
    volatile unsigned long ulID;
    volatile unsigned long ulData[2];
} KINETIS_CAN_BUF;


typedef struct stRESET_VECTOR
{
    void  *ptrResetSP;                                                   // initial stack pointer
    void  (*ptrResetPC)(void);                                           // initial program counter
#if defined NMI_IN_FLASH                                                 // {84}
    void  (*ptrNMI)(void);
#endif
} RESET_VECTOR;


#if (defined KINETIS_K_FPU && ((!defined KINETIS_K02 && !defined KINETIS_K22 && !(defined KINETIS_K24 && (SIZE_OF_FLASH == (256 * 1024))) && !defined KINETIS_K80 && !defined KINETIS_KV30) || defined KINETIS_FLEX || (SIZE_OF_FLASH >= (1024 * 1024)))) // exceptions are K22 FN512 and K22 FN256
    #define PHRASE_PROGRAMMING_METHOD                                    // use phrase programming (aligned 8 byte block) rather than long word programming
#endif

#if defined PHRASE_PROGRAMMING_METHOD
    #define FLASH_GRANULARITY   (4 * 1024)                               // smallest sector which can be erased independently
    #define FLEXRAM_MAX_SECTION_COPY_SIZE (1 * 1024)
#elif defined KINETIS_KE
    #define FLASH_GRANULARITY   (512)                                    // smallest sector which can be erased independently
#elif (defined KINETIS_KL || (defined KINETIS_MAX_SPEED && (KINETIS_MAX_SPEED <= 50000000))) && !defined KINETIS_KW2X // {42}{49}
    #define FLASH_GRANULARITY   (1 * 1024)                               // smallest sector which can be erased independently
#elif defined KINETIS_K24 || defined KINETIS_K80                         // K24 and K80 without phrase programming still uses 4k sectors
    #define FLASH_GRANULARITY   (4 * 1024)                               // smallest sector which can be erased independently
#else
    #define FLASH_GRANULARITY   (2 * 1024)                               // smallest sector which can be erased independently
    #define FLEXRAM_MAX_SECTION_COPY_SIZE (2 * 1024)
#endif

#if defined KINETIS_K26 || defined KINETIS_KL28 || defined KINETIS_K64 || defined KINETIS_K65 || defined KINETIS_K66 || defined KINETIS_K80 || defined KINETIS_K02 || defined KINETIS_K63 || (defined KINETIS_K22 && (SIZE_OF_FLASH == (512 * 1024))) || defined KINETIS_K24 || defined KINETIS_KL43 || defined KINETIS_KL03 || defined KINETIS_KL27 || defined KINETIS_KL82 || defined KINETIS_KV30
    #define KINETIS_HAS_IRC48M                                           // device has IRC48M which can be used for crystal-less USB
#endif

#define FLASH_LINE_SIZE         8                                        // lines made up of 8 bytes to avoid file header problems with the FLASH characteristics
#if defined PHRASE_PROGRAMMING_METHOD || defined KINETIS_KE
    #define FLASH_ROW_SIZE      8                                        // FLASH writes are performed on this many bytes at a time (the faster devices, and KE, use 8 byte phrases)
#else
    #define FLASH_ROW_SIZE      4                                        // FLASH writes are performed on this many bytes at a time (this is not FLASH structure dependent but rather logical when working with the long word write restriction - a buffer of the same size as the FLASH granularity results in fastest operation due to less FLASH writes)
#endif
#define MAX_SECTOR_PARS         ((FLASH_GRANULARITY - (2 * FLASH_ROW_SIZE))/FLASH_ROW_SIZE) // the number of user bytes fitting into first parameter block

#define FLASH_START_ADDRESS     0                                        // up to 2Meg
#if (defined KINETIS_KL && !defined KINETIS_KL28) || defined KINETIS_KE || defined KINETIS_KV10 // {42}
    #define RAM_START_ADDRESS   (0x20000000 - (SIZE_OF_RAM/4))           // SRAM L is 1/4 of the RAM size and is anchored to end at 0x1ffffffff
                                                                         // SRAM H is 3/4 of the RAM size and is anchored to start at 0x20000000
#elif defined KINETIS_K64 || defined KINETIS_K24 || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66 || defined KINETIS_K80
    #define RAM_START_ADDRESS   (0x20000000 - (64 * 1024))               // SRAM L is 64k and is anchored to end at 0x1ffffffff
                                                                         // SRAM H is the remainder of RAM size and is anchored to start at 0x20000000
#elif defined KINETIS_KV30
    #define RAM_START_ADDRESS   (0x20000000 - (32 * 1024))               // SRAM L is 32k and is anchored to end at 0x1ffffffff
                                                                         // SRAM H is the remainder of RAM size and is anchored to start at 0x20000000
#else
    #define RAM_START_ADDRESS   (0x20000000 - (SIZE_OF_RAM/2))           // SRAM is symmetrical around 0x20000000
#endif

#if KINETIS_MAX_SPEED >= 100000000                                       // devices with less that 100MHz speed don't generally have memory protection unit
    #if !(defined KINETIS_K22 && ((SIZE_OF_FLASH == (512 * 1024)) && !defined KINETIS_FLEX)) // {86} exception of K22 FN with 512k Flash
        #define MPU_AVAILABLE
    #endif
#elif defined KINETIS_KL82
    #define MPU_AVAILABLE
#endif

#define FLEXNVM_START_ADDRESS   (0x10000000)
#define KE_EEPROM_START_ADDRESS FLEXNVM_START_ADDRESS
#define KE_EEPROM_GRANULARITY   (2)
#define FLEXRAM_START_ADDRESS   (0x14000000)                             // devices without flexNVM may also have "programming acceleration RAM" in this area
#define FLEXRAM_SIZE            (4 * 1024)
#if defined _WINDOWS
    extern unsigned char uninitialisedRAM[16];
    #define BOOT_MAIL_BOX           (unsigned short *)&uninitialisedRAM[0]
    #define RANDOM_SEED_LOCATION    (unsigned short *)&uninitialisedRAM[2]
    #define RTC_SECONDS_LOCATION    (unsigned long *)&uninitialisedRAM[4]
    #define RTC_ALARM_LOCATION      (unsigned long *)&uninitialisedRAM[8]
    #define RTC_VALID_LOCATION      (unsigned short *)&uninitialisedRAM[12]
    #define RTC_PRESCALER_LOCATION  (unsigned short *)&uninitialisedRAM[14]
#else
    #define BOOT_MAIL_BOX           (unsigned short *)(RAM_START_ADDRESS + (SIZE_OF_RAM - 2)) // {26}
    #define RANDOM_SEED_LOCATION    (unsigned short *)(RAM_START_ADDRESS + (SIZE_OF_RAM - 4)) // {26} location of a long word which is never initialised and so has a random power on value
    #define RTC_SECONDS_LOCATION    (unsigned long *)(RAM_START_ADDRESS + (SIZE_OF_RAM - 8)) // {63}
    #define RTC_ALARM_LOCATION      (unsigned long *)(RAM_START_ADDRESS + (SIZE_OF_RAM - 12)) // {63}
    #define RTC_VALID_LOCATION      (unsigned short *)(RAM_START_ADDRESS + (SIZE_OF_RAM - 14)) // {63}
    #define RTC_PRESCALER_LOCATION  (unsigned short *)(RAM_START_ADDRESS + (SIZE_OF_RAM - 16)) // {63}
#endif

#define RTC_VALID_PATTERN       0xca35

#if !defined PERSISTENT_RAM_SIZE
    #define PERSISTENT_RAM_SIZE          0
#endif
#if defined SUPPORT_SW_RTC || (defined KINETIS_KL && defined RTC_USES_LPO_1kHz) || (defined KINETIS_KE && defined SUPPORT_RTC) || defined _BOOT_LOADER
     #define NON_INITIALISED_RAM_SIZE    (16 + PERSISTENT_RAM_SIZE)
#else
     #define NON_INITIALISED_RAM_SIZE    (4 + PERSISTENT_RAM_SIZE)
#endif

#if ((defined KINETIS_KL && !defined KINETIS_KL02) || defined KINETIS_K22)
    #define CLKOUT_AVAILABLE
#endif

// Ethernet configuration
//
#if defined KINETIS_K50 || defined KINETIS_K60 || defined KINETIS_K70
    #define ETHERNET_AVAILABLE
#endif

// LTC (LP Trusted Cryptography)
//
#if defined KINETIS_K82 || defined KINETIS_KL82
   #define LTC_AVAILABLE
#endif

// CAU configuration
//
#if defined KINETIS_K21 || defined KINETIS_K26 || defined KINETIS_K60 || defined KINETIS_K61 || defined KINETIS_K70 || defined KINETIS_K80
    #define CAU_V2_AVAILABLE
#elif (defined KINETIS_K24 && (SIZE_OF_FLASH == (1 * 1024 * 1024))) || defined  KINETIS_K64
    #define CAU_V1_AVAILABLE
#endif

// Crossbar switch
//
#if defined KINETIS_K02
    #define CROSSBAR_SWITCH_LITE
#endif

// UART configuration
//
#if defined KINETIS_KL03 || defined KINETIS_KL28 || defined KINETIS_KL82 || defined KINETIS_K80  // devices with exclusively LPUARTs
    #define UARTS_AVAILABLE         0
#elif defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
    #define UARTS_AVAILABLE         5
#elif defined KINETIS_KL02 || defined KINETIS_KL05 || defined KINETIS_KL43 || defined KINETIS_KL27 || defined KINETIS_KEA8
    #define UARTS_AVAILABLE         1
#elif defined KINETIS_KV
    #if defined KINETIS_KV31
        #define UARTS_AVAILABLE     3
    #else
        #define UARTS_AVAILABLE     2
    #endif
#elif defined KINETIS_K02
    #define UARTS_AVAILABLE         2
#elif defined KINETIS_K22
    #if ((SIZE_OF_FLASH == (512 * 1024)) || (SIZE_OF_FLASH == (256 * 1024)))
        #define UARTS_AVAILABLE     3
    #else
        #define UARTS_AVAILABLE     6
    #endif
#elif defined KINETIS_K21
    #if !defined KINETIS_K_FPU
        #define UARTS_AVAILABLE     4
    #else
        #define UARTS_AVAILABLE     6
    #endif
#elif defined KINETIS_K20
    #if (KINETIS_MAX_SPEED == 72000000)
        #if (PIN_COUNT == PIN_COUNT_64_PIN)
            #define UARTS_AVAILABLE 3
        #else
            #define UARTS_AVAILABLE 5
        #endif
    #elif (KINETIS_MAX_SPEED <= 50000000)
        #define UARTS_AVAILABLE     3
    #else
        #define UARTS_AVAILABLE     6
    #endif
#elif defined KINETIS_KL || defined KINETIS_KE || defined KINETIS_KW2X   // {42}
    #define UARTS_AVAILABLE         3
#else
    #define UARTS_AVAILABLE         6
#endif

// LPUART configuration
//
#if defined KINETIS_K80
    #define LPUARTS_AVAILABLE       5
#elif defined KINETIS_KL28 || defined KINETIS_KL82
    #define LPUARTS_AVAILABLE       2 // provisional since 3 are available but need muxed interrupt
#elif defined KINETIS_KL03
    #define LPUARTS_AVAILABLE       1
#elif defined KINETIS_KV31 || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
    #define LPUARTS_AVAILABLE       1
    #define LPUARTS_PARALLEL                                             // LPUARTs and UARTs are counted from 0
#elif defined KINETIS_KL43 || defined KINETIS_KL27
    #define LPUARTS_AVAILABLE       2
#elif defined KINETIS_K22
    #if ((SIZE_OF_FLASH == (512 * 1024)) || (SIZE_OF_FLASH == (256 * 1024)))
        #define LPUARTS_AVAILABLE   1
        #define LPUARTS_PARALLEL                                         // LPUARTs and UARTs are counted from 0
    #else
        #define LPUARTS_AVAILABLE   0
    #endif
#else
    #define LPUARTS_AVAILABLE       0
#endif

// SPI configuration
//
#if defined KINETIS_K02
    #define SPI_AVAILABLE           1
#elif (defined KINETIS_K20 && (KINETIS_MAX_SPEED < 100000000))
    #define SPI_AVAILABLE           2
#else
    #define SPI_AVAILABLE           3
#endif

#if defined KINETIS_K80
    #define QSPI_AVAILABLE          1
#endif

// I2C configuration
//
#if defined KINETIS_K80 || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
    #define I2C_AVAILABLE                4
#elif defined KINETIS_K64
    #define I2C_AVAILABLE                3
#elif defined KINETIS_K21
    #if (KINETIS_MAX_SPEED  <= 50000000)
        #define I2C_AVAILABLE            2
    #else
        #define I2C_AVAILABLE            3
    #endif
#elif defined KINETIS_KL02 || defined KINETIS_KL25 || defined KINETIS_KL43 || defined KINETIS_KL46 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128 || defined KINETIS_KV31 || defined KINETIS_KL27 || defined KINETIS_KW2X
    #define I2C_AVAILABLE                2
#elif (KINETIS_MAX_SPEED  <= 50000000) || defined KINETIS_KV || defined KINETIS_K02
    #define I2C_AVAILABLE                1
#else
    #define I2C_AVAILABLE                2
#endif

#if defined KINETIS_KL43 || defined KINETIS_KL33 || defined KINETIS_KL27 || defined KINETIS_KL17 || defined KINETIS_KL03
    #define DOUBLE_BUFFERED_I2C
#elif defined KINETIS_K22 || defined KINETIS_K64 || defined KINETIS_KE02 // parts with single-buffered I2C implementation but a start condition interrupt
    #define I2C_START_CONDITION_INTERRUPT
#endif

// I2S configuration
//
#if defined KINETIS_K22 || defined KINETIS_KL43 || defined KINETIS_K80
    #define I2S_AVAILABLE                1
#elif defined KINETIS_K61 || defined KINETIS_K70 || ((defined KINETIS_K60 || defined KINETIS_K20) && KINETIS_MAX_SPEED > 100000000)
    #define I2S_AVAILABLE                2
#else
    #define I2S_AVAILABLE                0
#endif

// PIT configuration
//
#if defined KINETIS_KL02 || defined KINETIS_KL03 || defined KINETIS_KV10
    #define KINETIS_WITHOUT_PIT
#elif defined KINETIS_KL || defined KINETIS_KE
    #define PITS_AVAILABLE  2
#else
    #define PITS_AVAILABLE  4
#endif

// RTC configuration
//
#if defined KINETIS_KV || defined KINETIS_KL02 || defined KINETIS_K02
    #define KINETIS_WITHOUT_RTC
#endif

// PWT configuration
#if (defined KINETIS_KE && !defined KINETIS_KE02) || (defined KINETIS_KEA && !defined KINETIS_KEA64)
    #define PWT_AVAILABLE   1
#endif

// FlexTimer configuration
//
#if defined KINETIS_K66 || defined KINETIS_K80
    #define FLEX_TIMERS_AVAILABLE   6                                    // 4 flex timers plus 2 TPMs
    #define TPMS_AVAILABLE          2                                    // TPM in addition to flex timers
#elif defined KINETIS_K61 || defined KINETIS_K64 || defined KINETIS_K70 || ((defined KINETIS_K10 || defined KINETIS_K60 || defined KINETIS_K21 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_KV30) && (KINETIS_MAX_SPEED > 100000000))
    #define FLEX_TIMERS_AVAILABLE   4
#elif defined KINETIS_KL05 || ((defined KINETIS_K10 || defined KINETIS_K20) && (KINETIS_MAX_SPEED <= 50000000))
    #define FLEX_TIMERS_AVAILABLE   2
#else
    #define FLEX_TIMERS_AVAILABLE   3
#endif

// ADC configuration
//
#if defined KINETIS_K61 || defined KINETIS_K70 || (((defined KINETIS_K60 && !defined KINETIS_K64 && !defined KINETIS_K65 && !defined KINETIS_K66) || (defined KINETIS_K20 && !defined KINETIS_K26 && !defined KINETIS_K21 && !defined KINETIS_K22 && !defined KINETIS_K24)) && (KINETIS_MAX_SPEED > 100000000))
    #define ADC_CONTROLLERS         4
#elif defined KINETIS_K80 || defined KINETIS_KL || defined KINETIS_KE || defined KINETIS_K02 || ((defined KINETIS_K20 || defined KINETIS_K21) && (KINETIS_MAX_SPEED < 72000000))
    #define ADC_CONTROLLERS         1
#else
    #define ADC_CONTROLLERS         2
#endif

// DAC configuration
//
#if defined KINETIS_K60 || defined KINETIS_K61 || defined KINETIS_K64 || defined KINETIS_K70 || defined KINETIS_KV31 || (defined KINETIS_K24 && (SIZE_OF_FLASH == (1024 * 1024)))
    #define DAC_CONTROLLERS         2
#elif defined KINETIS_KE || defined KINETIS_KL27 || defined KINETIS_KL03 || defined KINETIS_KL02
    #define DAC_CONTROLLERS         0
#else
    #define DAC_CONTROLLERS         1
#endif

// CAN configuration
//
#if defined KINETIS_K64 || (defined KINETIS_K24 && (SIZE_OF_FLASH == (1024 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
    #define NUMBER_OF_CAN_INTERFACES 1
    #if defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define MSCAN_CAN_INTERFACE                                      // MSCAN rather than FlexCAN
    #endif
#elif (KINETIS_MAX_SPEED == 72000000) && (defined KINETIS_K20 || defined KINETIS_K30)
    #define NUMBER_OF_CAN_INTERFACES 1
#elif (KINETIS_MAX_SPEED == 120000000) && defined KINETIS_K22
    #define NUMBER_OF_CAN_INTERFACES 1
#elif defined KINETIS_K24
    #define NUMBER_OF_CAN_INTERFACES 0
#elif (KINETIS_MAX_SPEED >= 100000000) && (defined KINETIS_K10 || defined KINETIS_K20 || defined KINETIS_K26 || defined KINETIS_K30 || defined KINETIS_K40 || defined KINETIS_K60 || defined KINETIS_K65 || defined KINETIS_K66 || defined KINETIS_K70)
    #define NUMBER_OF_CAN_INTERFACES 2
#else
    #define NUMBER_OF_CAN_INTERFACES 0
#endif

// Comparator configuration
//
#if defined KINETIS_K24 && (SIZE_OF_FLASH == (1024 * 1024))
    #define NUMBER_OF_COMPARATORS 3
#else
    #define NUMBER_OF_COMPARATORS 2
#endif

// SDHC configuration
//
#if defined KINETIS_K24
    #if (SIZE_OF_FLASH == (1024 * 1024))
        #define NUMBER_OF_SDHC    1
    #else
        #define NUMBER_OF_SDHC    0
    #endif
#elif defined KINETIS_K21 || defined KINETIS_K26 || defined KINETIS_K40 || defined KINETIS_K53 || defined KINETIS_K60 || defined KINETIS_K64 || defined KINETIS_K70 || defined KINETIS_K80
    #define NUMBER_OF_SDHC        1
#elif defined KINETIS_K20 && (KINETIS_MAX_SPEED == 120000000)
    #define NUMBER_OF_SDHC        1
#else
    #define NUMBER_OF_SDHC        0
#endif

// KBI configuration
//
#if defined KINETIS_KE
    #define KBIS_AVAILABLE 2
    #if defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define KBI_WIDTH  32
    #else
        #define KBI_WIDTH  8
    #endif
#else
    #define KBIS_AVAILABLE 0
#endif

// SDRAM configuration
//

#if (defined KINETIS_K70 || defined KINETIS_K61)
    #define SDRAM_CONTROLLER_AVAILABLE
#endif

// LLWU configuration
//
#if !defined KINETIS_KE && !defined KINETIS_KL02
    #define LLWU_AVAILABLE
#endif

// RNG configuration
//
#if defined KINETIS_K60 || defined KINETIS_K70 || defined KINETIS_K80 || defined KINETIS_K52 || defined KINETIS_K53 || defined KINETIS_K24
    #define RNG_AVAILABLE
    #if defined KINETIS_K80
        #define TRUE_RANDOM_NUMBER_GENERATOR                             // true random number generator is available
    #elif defined KINETIS_REVISION_2 || defined KINETIS_K70
        #define RANDOM_NUMBER_GENERATOR_A                                // random number generator A is available
    #else
        #define RANDOM_NUMBER_GENERATOR_B                                // random number generator B is available (not RNGA)
    #endif
#endif

// SLCD configuration
//
#if defined KINETIS_K30 || defined KINETIS_K40 || defined KINETIS_K51 || defined KINETIS_K53 || defined KINETIS_KL46 || defined KINETIS_KL43
    #define DEVICE_WITH_SLCD
#endif

// FlexIO configuration
//
#if defined KINETIS_KL43|| defined KINETIS_KL27 || defined KINETIS_K80
    #define CHIP_HAS_FLEXIO
#endif


// Define the number of ports that the processor has
//
#if (defined KINETIS_KE || defined KINETIS_KL || defined KINETIS_KV10) && !defined KINETIS_KL17 && !defined KINETIS_KL27 && !defined KINETIS_KL43 && !defined KINETIS_KL46 // fast GPIO alias avaiable
    #define FGPIO_AVAILABLE
#endif
#if defined KINETIS_KE
    #if defined KINETIS_KEA8
        #define PORTS_AVAILABLE 1
        #define PORTS_AVAILABLE_8_BIT  3
    #elif defined KINETIS_KE06 || defined KINETIS_KEA
        #define PORTS_AVAILABLE 3
        #define PORTS_AVAILABLE_8_BIT  9
    #elif (defined KINETIS_KE04 && (SIZE_OF_FLASH <= (8 * 1024)))
        #define PORTS_AVAILABLE 1
        #define PORTS_AVAILABLE_8_BIT  4
    #else
        #define PORTS_AVAILABLE 2
        #define PORTS_AVAILABLE_8_BIT  8
    #endif
#elif defined KINETIS_K61 || defined KINETIS_K70
    #define PORTS_AVAILABLE 6
#elif defined KINETIS_KL02 || defined KINETIS_KL03 || defined KINETIS_KL04 || defined KINETIS_KL05
    #define PORTS_AVAILABLE 2
#else
    #define PORTS_AVAILABLE 5
#endif

// DMA configuration
//
#if defined KINETIS_KE || defined KINETIS_KL02 || defined KINETIS_KL03   // devices that don't support DMA
    #define DEVICE_WITHOUT_DMA
#elif defined KINETIS_K_FPU && !defined KINETIS_K21 && !defined KINETIS_K22 && !defined KINETIS_K24 && !defined KINETIS_K64 && !defined KINETIS_KV30
    #define DEVICE_WITH_TWO_DMA_GROUPS
    #define DMA_CHANNEL_COUNT        16
#else
    #if defined KINETIS_KL
        #if defined KINETIS_KL82                                         // temporary (KL82 has eDMA and is this an exception in the KL family)
            #define DEVICE_WITHOUT_DMA
        #else
            #define DMA_CHANNEL_COUNT    4
        #endif
    #else
        #define DMA_CHANNEL_COUNT    16
    #endif
#endif

#if defined KINETIS_K70 || ((defined KINETIS_K60 && defined KINETIS_K_FPU) && !defined KINETIS_K64 && !defined KINETIS_K66) || (defined KINETIS_K20 && (KINETIS_MAX_SPEED > 100000000))
    #define DMAMUX1_AVAILABLE
#endif



// Kinetis interrupts
//
typedef struct stPROCESSOR_IRQ
{
#if defined KINETIS_KE                                                   // {42}
    void  (*reserved0)(void);                                            // 0
    void  (*reserved1)(void);                                            // 1
    void  (*reserved2)(void);                                            // 2
    void  (*reserved3)(void);                                            // 3
    void  (*reserved4)(void);                                            // 4
    void  (*irq_FTMRH)(void);                                            // 5
    void  (*irq_PMC)(void);                                              // 6
    void  (*irq_IRQ)(void);                                              // 7
    void  (*irq_I2C0)(void);                                             // 8
    void  (*irq_I2C1)(void);                                             // 9
    void  (*irq_SPI0)(void);                                             // 10
    void  (*irq_SPI1)(void);                                             // 11
    void  (*irq_UART0)(void);                                            // 12 status and error
    void  (*irq_UART1)(void);                                            // 13 status and error
    void  (*irq_UART2)(void);                                            // 14 status and error
    void  (*irq_ADC0)(void);                                             // 15
    void  (*irq_CMP0)(void);                                             // 16
    void  (*irq_FTM0)(void);                                             // 17
    void  (*irq_FTM1)(void);                                             // 18
    void  (*irq_FTM2)(void);                                             // 19
    void  (*irq_RTC_OVERFLOW)(void);                                     // 20
    void  (*irq_CMP1)(void);                                             // 21
    void  (*irq_PIT0)(void);                                             // 22
    void  (*irq_PIT1)(void);                                             // 23
    void  (*irq_KBI0)(void);                                             // 24
    void  (*irq_KBI1)(void);                                             // 25
    void  (*reserved26)(void);                                           // 26
    void  (*irq_ICS)(void);                                              // 27
    void  (*irq_WDOG)(void);                                             // 28
#elif defined KINETIS_KV && !defined KINETIS_KV30 && !defined KINETIS_KV50
    void  (*irq_DMA0)(void);                                             // 0
    void  (*irq_DMA1)(void);                                             // 1
    void  (*irq_DMA2)(void);                                             // 2
    void  (*irq_DMA3)(void);                                             // 3
    void  (*irq_DMA_error)(void);                                        // 4
    void  (*irq_FTFA)(void);                                             // 5 (command complete and read collision combined)
    void  (*irq_LOW_VOLTAGE)(void);                                      // 6 low voltage detect, low-voltage warning
    void  (*irq_LL_wakeup)(void);                                        // 7
    void  (*irq_I2C0)(void);                                             // 8
    void  (*irq_I2C1)(void);                                             // 9
    void  (*irq_SPI0)(void);                                             // 10
    void  (*irq_SPI1)(void);                                             // 11
    void  (*irq_UART0)(void);                                            // 12 status and error
    void  (*irq_UART1)(void);                                            // 13 status and error
    void  (*irq_UART2)(void);                                            // 14 status and error
    void  (*irq_ADC0)(void);                                             // 15
    void  (*irq_ADC1)(void);                                             // 16
    void  (*irq_FTM0)(void);                                             // 17
    void  (*irq_FTM1)(void);                                             // 18
    void  (*irq_FTM2)(void);                                             // 19
    void  (*irq_CMP0)(void);                                             // 20
    void  (*irq_CMP1)(void);                                             // 21
    void  (*reserved22)(void);                                           // 22
    void  (*irq_WDOG_EWM)(void);                                         // 23
    void  (*reserved24)(void);                                           // 24
    void  (*irq_DAC0)(void);                                             // 25
    void  (*reserved26)(void);                                           // 26
    void  (*irq_MCG)(void);                                              // 27
    void  (*irq_LPT)(void);                                              // 28
    void  (*irq_PDB)(void);                                              // 29
    void  (*irq_PORTA)(void);                                            // 30
    void  (*irq_PORTB_C_D_E)(void);                                      // 31 single interrupt vector for ports B, C, D and E
#elif defined KINETIS_KL                                                 // {42}
    #if defined DEVICE_WITHOUT_DMA
        void  (*reserved0)(void);                                        // 0
        void  (*reserved1)(void);                                        // 1
        void  (*reserved2)(void);                                        // 2
        void  (*reserved3)(void);                                        // 3
    #else
        void  (*irq_DMA0)(void);                                         // 0
        void  (*irq_DMA1)(void);                                         // 1
        void  (*irq_DMA2)(void);                                         // 2
        void  (*irq_DMA3)(void);                                         // 3
    #endif
    void  (*reserved4)(void);                                            // 4
    void  (*irq_FTFA)(void);                                             // 5 (command complete and read collision combined)
    void  (*irq_LOW_VOLTAGE)(void);                                      // 6 low voltage detect, low-voltage warning
    void  (*irq_LL_wakeup)(void);                                        // 7
    void  (*irq_I2C0)(void);                                             // 8
    void  (*irq_I2C1)(void);                                             // 9
    void  (*irq_SPI0)(void);                                             // 10
    void  (*irq_SPI1)(void);                                             // 11
    #if LPUARTS_AVAILABLE > 0
        void  (*irq_LPUART0)(void);                                      // 12 status and error
    #else
        void  (*irq_UART0)(void);                                        // 12 status and error
    #endif
    #if LPUARTS_AVAILABLE > 1
        void  (*irq_LPUART1)(void);                                      // 13 status and error
    #else
        void  (*irq_UART1)(void);                                        // 13 status and error
    #endif
    void  (*irq_UART2)(void);                                            // 14 status and error
    void  (*irq_ADC0)(void);                                             // 15
    void  (*irq_CMP0)(void);                                             // 16
    void  (*irq_TPM0)(void);                                             // 17
    void  (*irq_TPM1)(void);                                             // 18
    void  (*irq_TPM2)(void);                                             // 19
    #if defined KINETIS_KL02
        void  (*reserved20)(void);                                       // 20
        void  (*reserved21)(void);                                       // 21
    #else
        void  (*irq_RTC_ALARM)(void);                                    // 20
        void  (*irq_RTC_SECONDS)(void);                                  // 21
    #endif
    void  (*irq_PIT)(void);                                              // 22 single interrupt vector for all channels
    void  (*irq_I2S0)(void);                                             // 23 single interrupt vector for all sources
    void  (*irq_USB_OTG)(void);                                          // 24
    void  (*irq_DAC0)(void);                                             // 25
    void  (*irq_TSI)(void);                                              // 26
    void  (*irq_MCG)(void);                                              // 27
    void  (*irq_LPT)(void);                                              // 28
    void  (*irq_SLCD)(void);                                             // 29
    void  (*irq_PORTA)(void);                                            // 30
  #if (PORTS_AVAILABLE == 2)
    void  (*irq_PORTB)(void);                                            // 31
  #elif defined KINETIS_KL27
    void  (*irq_PORTBCD_E)(void);                                        // 31 single interrupt vector for ports B, C, D and E
  #else
    void  (*irq_PORTC_D)(void);                                          // 31 single interrupt vector for ports C and D
  #endif
#elif defined KINETIS_K21                                                // {44}
    void  (*irq_DMA0)(void);                                             // 0
    void  (*irq_DMA1)(void);                                             // 1
    void  (*irq_DMA2)(void);                                             // 2
    void  (*irq_DMA3)(void);                                             // 3
    void  (*irq_DMA4)(void);                                             // 4
    void  (*irq_DMA5)(void);                                             // 5
    void  (*irq_DMA6)(void);                                             // 6
    void  (*irq_DMA7)(void);                                             // 7
    void  (*irq_DMA8)(void);                                             // 8
    void  (*irq_DMA9)(void);                                             // 9
    void  (*irq_DMA10)(void);                                            // 10
    void  (*irq_DMA11)(void);                                            // 11
    void  (*irq_DMA12)(void);                                            // 12
    void  (*irq_DMA13)(void);                                            // 13
    void  (*irq_DMA14)(void);                                            // 14
    void  (*irq_DMA15)(void);                                            // 15
    void  (*irq_DMA_ERROR)(void);                                        // 16
    void  (*irq_MCM)(void);                                              // 17
    void  (*irq_FLASH_CC)(void);                                         // 18
    void  (*irq_FLASH_RC)(void);                                         // 19
    void  (*irq_LOW_VOLTAGE)(void);                                      // 20
    void  (*irq_LL_wakeup)(void);                                        // 21
    void  (*irq_WDOG)(void);                                             // 22
    void  (*irq_RNGB)(void);                                             // 23
    void  (*irq_I2C0)(void);                                             // 24
    void  (*irq_I2C1)(void);                                             // 25
    void  (*irq_SPI0)(void);                                             // 26
    void  (*irq_SPI1)(void);                                             // 27
    void  (*irq_I2S0)(void);                                             // 28
    void  (*irq_I2S1)(void);                                             // 29
    #if defined KINETIS_K_FPU
        void  (*irq_UART0_LON)(void);                                    // 30
    #else
        void  (*reserved30)(void);                                       // 30
    #endif
    void  (*irq_UART0)(void);                                            // 31
    void  (*irq_UART0_ERROR)(void);                                      // 32
    void  (*irq_UART1)(void);                                            // 33
    void  (*irq_UART1_ERROR)(void);                                      // 34
    void  (*irq_UART2)(void);                                            // 35
    void  (*irq_UART2_ERROR)(void);                                      // 36
    void  (*irq_UART3)(void);                                            // 37
    void  (*irq_UART3_ERROR)(void);                                      // 38
    void  (*irq_ADC0)(void);                                             // 39
    void  (*irq_CMP0)(void);                                             // 40
    void  (*irq_CMP1)(void);                                             // 41
    void  (*irq_FTM0)(void);                                             // 42
    void  (*irq_FTM1)(void);                                             // 43
    void  (*irq_FTM2)(void);                                             // 44
    void  (*irq_CMT)(void);                                              // 45
    void  (*irq_RTC_ALARM)(void);                                        // 46
    void  (*irq_RTC_SECONDS)(void);                                      // 47
    void  (*irq_PIT0)(void);                                             // 48
    void  (*irq_PIT1)(void);                                             // 49
    void  (*irq_PIT2)(void);                                             // 50
    void  (*irq_PIT3)(void);                                             // 51
    void  (*irq_PDB)(void);                                              // 52
    void  (*irq_USB_OTG)(void);                                          // 53
    void  (*irq_USB_CD)(void);                                           // 54
    void  (*reserved55)(void);                                           // 55
    void  (*irq_DAC0)(void);                                             // 56
    void  (*irq_MCG)(void);                                              // 57
    void  (*irq_LPT)(void);                                              // 58
    void  (*irq_PORTA)(void);                                            // 59
    void  (*irq_PORTB)(void);                                            // 60
    void  (*irq_PORTC)(void);                                            // 61
    void  (*irq_PORTD)(void);                                            // 62
    void  (*irq_PORTE)(void);                                            // 63
    void  (*irq_SW_IRQ)(void);                                           // 64
    #if defined KINETIS_K_FPU
        void  (*irq_SPI2)(void);                                         // 65
        void  (*irq_UART4)(void);                                        // 66
        void  (*irq_UART4_ERROR)(void);                                  // 67
        void  (*irq_UART5)(void);                                        // 68
        void  (*irq_UART6_ERROR)(void);                                  // 69
        void  (*irq_CMP2)(void);                                         // 70
        void  (*irq_FTM3)(void);                                         // 71
        void  (*irq_DAC1)(void);                                         // 72
        void  (*irq_ADC1)(void);                                         // 73
        void  (*irq_I2C2)(void);                                         // 74
        void  (*irq_CAN0_MESSAGE)(void);                                 // 75
        void  (*irq_CAN0_BUS_OFF)(void);                                 // 76
        void  (*irq_CAN0_ERROR)(void);                                   // 77
        void  (*irq_CAN0_TX)(void);                                      // 78
        void  (*irq_CAN0_RX)(void);                                      // 79
        void  (*irq_CAN0_WAKE_UP)(void);                                 // 80
        void  (*irq_SDHC)(void);                                         // 81
    #endif
#elif (KINETIS_MAX_SPEED <= 50000000) && !defined KINETIS_KW2X
    void  (*irq_DMA0)(void);                                             // 0
    void  (*irq_DMA1)(void);                                             // 1
    void  (*irq_DMA2)(void);                                             // 2
    void  (*irq_DMA3)(void);                                             // 3
    void  (*irq_DMA_ERROR)(void);                                        // 4
    void  (*reserved5)(void);                                            // 5
    void  (*irq_FLASH_CC)(void);                                         // 6
    void  (*irq_FLASH_RC)(void);                                         // 7
    void  (*irq_LOW_VOLTAGE)(void);                                      // 8
    void  (*irq_LL_wakeup)(void);                                        // 9
    void  (*irq_WDOG)(void);                                             // 10
    void  (*irq_I2C0)(void);                                             // 11
    void  (*irq_SPI0)(void);                                             // 12
    void  (*irq_I2S0_TX)(void);                                          // 13
    void  (*irq_I2S0_RX)(void);                                          // 14
    void  (*irq_UART0_LON)(void);                                        // 15
    void  (*irq_UART0)(void);                                            // 16
    void  (*irq_UART0_ERROR)(void);                                      // 17
    void  (*irq_UART1)(void);                                            // 18
    void  (*irq_UART1_ERROR)(void);                                      // 19
    void  (*irq_UART2)(void);                                            // 20
    void  (*irq_UART2_ERROR)(void);                                      // 21
    void  (*irq_ADC0)(void);                                             // 22
    void  (*irq_CMP0)(void);                                             // 23
    void  (*irq_CMP1)(void);                                             // 24
    void  (*irq_FTM0)(void);                                             // 25
    void  (*irq_FTM1)(void);                                             // 26
    void  (*irq_CMT)(void);                                              // 27
    void  (*irq_RTC_ALARM)(void);                                        // 28
    void  (*irq_RTC_SECONDS)(void);                                      // 29
    void  (*irq_PIT0)(void);                                             // 30
    void  (*irq_PIT1)(void);                                             // 31
    void  (*irq_PIT2)(void);                                             // 32
    void  (*irq_PIT3)(void);                                             // 33
    void  (*irq_PDB)(void);                                              // 34
    void  (*irq_USB_OTG)(void);                                          // 35
    void  (*irq_USB_CD)(void);                                           // 36
    void  (*irq_TSI)(void);                                              // 37
    void  (*irq_MCG)(void);                                              // 38
    void  (*irq_LPT)(void);                                              // 39
    void  (*irq_PORTA)(void);                                            // 40
    void  (*irq_PORTB)(void);                                            // 41
    void  (*irq_PORTC)(void);                                            // 42
    void  (*irq_PORTD)(void);                                            // 43
    void  (*irq_PORTE)(void);                                            // 44
    void  (*irq_SW_IRQ)(void);                                           // 45
#else
    void  (*irq_DMA0)(void);                                             // 0
    void  (*irq_DMA1)(void);                                             // 1
    void  (*irq_DMA2)(void);                                             // 2
    void  (*irq_DMA3)(void);                                             // 3
    #if defined KINETIS_K02
        void  (*irq_res_4)(void);                                        // 4
        void  (*irq_res_5)(void);                                        // 5
        void  (*irq_res_6)(void);                                        // 6
        void  (*irq_res_7)(void);                                        // 7
        void  (*irq_res_8)(void);                                        // 8
        void  (*irq_res_9)(void);                                        // 9
        void  (*irq_res_10)(void);                                       // 10
        void  (*irq_res_11)(void);                                       // 11
        void  (*irq_res_12)(void);                                       // 12
        void  (*irq_res_13)(void);                                       // 13
        void  (*irq_res_14)(void);                                       // 14
        void  (*irq_res_15)(void);                                       // 15
    #else
        void  (*irq_DMA4)(void);                                         // 4
        void  (*irq_DMA5)(void);                                         // 5
        void  (*irq_DMA6)(void);                                         // 6
        void  (*irq_DMA7)(void);                                         // 7
        void  (*irq_DMA8)(void);                                         // 8
        void  (*irq_DMA9)(void);                                         // 9
        void  (*irq_DMA10)(void);                                        // 10
        void  (*irq_DMA11)(void);                                        // 11
        void  (*irq_DMA12)(void);                                        // 12
        void  (*irq_DMA13)(void);                                        // 13
        void  (*irq_DMA14)(void);                                        // 14
        void  (*irq_DMA15)(void);                                        // 15
    #endif
    void  (*irq_DMA_ERROR)(void);                                        // 16
    void  (*irq_MCM)(void);                                              // 17
    void  (*irq_FLASH_CC)(void);                                         // 18
    void  (*irq_FLASH_RC)(void);                                         // 19
    void  (*irq_LOW_VOLTAGE)(void);                                      // 20
    void  (*irq_LL_wakeup)(void);                                        // 21
    void  (*irq_WDOG)(void);                                             // 22
    #if defined RNG_AVAILABLE
        void  (*irq_RNG)(void);                                          // 23
    #else
        void  (*irq_res_23)(void);                                       // 23
    #endif
    void  (*irq_I2C0)(void);                                             // 24
    #if I2C_AVAILABLE > 1
        void  (*irq_I2C1)(void);                                         // 25
    #else
        void  (*irq_res_25)(void);                                       // 25
    #endif
    void  (*irq_SPI0)(void);                                             // 26
    #if SPI_AVAILABLE > 1
        void  (*irq_SPI1)(void);                                         // 27
    #else
        void  (*irq_res_27)(void);                                       // 27
    #endif
    #if defined KINETIS_K80
        void  (*irq_I2S0_TX)(void);                                      // 28
        void  (*irq_I2S0_RX)(void);                                      // 29
        void  (*irq_LPUART0)(void);                                      // 30
        void  (*irq_LPUART1)(void);                                      // 31
        void  (*irq_LPUART2)(void);                                      // 32
        void  (*irq_LPUART3)(void);                                      // 33
        void  (*irq_LPUART4)(void);                                      // 34
        void  (*irq_res_35)(void);                                       // 35
        void  (*irq_res_36)(void);                                       // 36
        void  (*irq_EVMSIM0)(void);                                      // 37
        void  (*irq_EVMSIM1)(void);                                      // 38
        void  (*irq_ADC0)(void);                                         // 39
        void  (*irq_CMP0)(void);                                         // 40
        void  (*irq_CMP1)(void);                                         // 41
        void  (*irq_FTM0)(void);                                         // 42
        void  (*irq_FTM1)(void);                                         // 43
        void  (*irq_FTM2)(void);                                         // 44
        void  (*irq_CMT)(void);                                          // 45
        void  (*irq_RTC_ALARM)(void);                                    // 46
        void  (*irq_RTC_SECONDS)(void);                                  // 47
        void  (*irq_PIT0)(void);                                         // 48
        void  (*irq_PIT1)(void);                                         // 49
        void  (*irq_PIT2)(void);                                         // 50
        void  (*irq_PIT3)(void);                                         // 51
        void  (*irq_PDB)(void);                                          // 52
        void  (*irq_USB_OTG)(void);                                      // 53
        void  (*irq_USB_CD)(void);                                       // 54
        void  (*irq_res_55)(void);
        void  (*irq_DAC0)(void);                                         // 56
        void  (*irq_MCG)(void);                                          // 57
        void  (*irq_LPT)(void);                                          // 58
        void  (*irq_PORTA)(void);                                        // 59
        void  (*irq_PORTB)(void);                                        // 60
        void  (*irq_PORTC)(void);                                        // 61
        void  (*irq_PORTD)(void);                                        // 62
        void  (*irq_PORTE)(void);                                        // 63
        void  (*irq_SOFTWARE)(void);                                     // 64
        void  (*irq_SPI2)(void);                                         // 65
        void  (*irq_res_66)(void);                                       // 66
        void  (*irq_res_67)(void);                                       // 67
        void  (*irq_res_68)(void);                                       // 68
        void  (*irq_res_69)(void);                                       // 69
        void  (*irq_FLEXIO)(void);                                       // 70
        void  (*irq_FTM3)(void);                                         // 71
        void  (*irq_res_72)(void);                                       // 72
        void  (*irq_res_73)(void);                                       // 73
        void  (*irq_I2C2)(void);                                         // 74
        void  (*irq_res_75)(void);                                       // 75
        void  (*irq_res_76)(void);                                       // 76
        void  (*irq_res_77)(void);                                       // 77
        void  (*irq_res_78)(void);                                       // 78
        void  (*irq_res_79)(void);                                       // 79
        void  (*irq_res_80)(void);                                       // 80
        void  (*irq_SDHC)(void);                                         // 81
        void  (*irq_res_82)(void);                                       // 82
        void  (*irq_res_83)(void);                                       // 83
        void  (*irq_res_84)(void);                                       // 84
        void  (*irq_res_85)(void);                                       // 85
        void  (*irq_res_86)(void);                                       // 86
        void  (*irq_TSI0)(void);                                         // 87
        void  (*irq_TPM1)(void);                                         // 88
        void  (*irq_TPM2)(void);                                         // 89
        void  (*irq_res_90)(void);                                       // 90
        void  (*irq_I2C3)(void);                                         // 91
        void  (*irq_res_92)(void);                                       // 92
        void  (*irq_res_93)(void);                                       // 93
        void  (*irq_res_94)(void);                                       // 94
        void  (*irq_res_95)(void);                                       // 95
        void  (*irq_res_96)(void);                                       // 96
        void  (*irq_res_97)(void);                                       // 97
        void  (*irq_res_98)(void);                                       // 98
        void  (*irq_res_99)(void);                                       // 99
        void  (*irq_QSPI)(void);                                         // 100
    #elif defined KINETIS_K26 || defined KINETIS_K64 || defined KINETIS_K65 || defined KINETIS_K66 || defined KINETIS_K02 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_KV30 || defined KINETIS_KW2X // {46}
        #if defined KINETIS_KW2X || defined KINETIS_K24 || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
            void  (*irq_I2S0_TX)(void);                                  // 28
            void  (*irq_I2S0_RX)(void);                                  // 29
            void  (*irq_res_30)(void);                                   // 30
        #else
            #if defined I2S_AVAILABLE > 1
                void  (*irq_I2S1_TX)(void);                              // 28
            #else
                void  (*irq_res_28)(void);                               // 28
            #endif
            #if defined I2S_AVAILABLE > 1
                void  (*irq_I2S1_RX)(void);                              // 29
            #else
                void  (*irq_res_29)(void);                               // 29
            #endif
            #if LPUARTS_AVAILABLE > 0
                void  (*irq_LPUART0)(void);                              // 30
            #else
                void  (*irq_res_30)(void);                               // 30
            #endif
        #endif
        void  (*irq_UART0)(void);                                        // 31
        void  (*irq_UART0_ERROR)(void);                                  // 32
        void  (*irq_UART1)(void);                                        // 33
        void  (*irq_UART1_ERROR)(void);                                  // 34
        #if UARTS_AVAILABLE > 2
            void  (*irq_UART2)(void);                                    // 35
            void  (*irq_UART2_ERROR)(void);                              // 36
        #else
            void  (*irq_res_35)(void);                                   // 35
            void  (*irq_res_36)(void);                                   // 36
        #endif
        #if UARTS_AVAILABLE > 3
            void  (*irq_UART3)(void);                                    // 37
            void  (*irq_UART3_ERROR)(void);                              // 38
        #else
            void  (*irq_res_37)(void);                                   // 37
            void  (*irq_res_38)(void);                                   // 38
        #endif
        void  (*irq_ADC0)(void);                                         // 39
        void  (*irq_CMP0)(void);                                         // 40
        void  (*irq_CMP1)(void);                                         // 41
        void  (*irq_FTM0)(void);                                         // 42
        void  (*irq_FTM1)(void);                                         // 43
        void  (*irq_FTM2)(void);                                         // 44
        void  (*irq_CMT)(void);                                          // 45
        #if defined KINETIS_KV30 || defined KINETIS_K02
            void  (*irq_res_46)(void);                                   // 46
            void  (*irq_res_47)(void);                                   // 47
        #else
            void  (*irq_RTC_ALARM)(void);                                // 46
            void  (*irq_RTC_SECONDS)(void);                              // 47
        #endif
        void  (*irq_PIT0)(void);                                         // 48
        void  (*irq_PIT1)(void);                                         // 49
        void  (*irq_PIT2)(void);                                         // 50
        void  (*irq_PIT3)(void);                                         // 51
        void  (*irq_PDB)(void);                                          // 52
        void  (*irq_USB_OTG)(void);                                      // 53
        void  (*irq_USB_CD)(void);                                       // 54
        void  (*irq_res_55)(void);
        void  (*irq_DAC0)(void);                                         // 56
        void  (*irq_MCG)(void);                                          // 57
        void  (*irq_LPT)(void);                                          // 58
        void  (*irq_PORTA)(void);                                        // 59
        void  (*irq_PORTB)(void);                                        // 60
        void  (*irq_PORTC)(void);                                        // 61
        void  (*irq_PORTD)(void);                                        // 62
        void  (*irq_PORTE)(void);                                        // 63
        void  (*irq_SOFTWARE)(void);                                     // 64
        #if !defined KINETIS_K02 && !defined KINETIS_KW2X
            void  (*irq_SPI2)(void);                                     // 65
            #if UARTS_AVAILABLE > 4
                void  (*irq_UART4)(void);                                // 66
                void  (*irq_UART4_ERROR)(void);                          // 67
            #else
                void  (*irq_res_66)(void);                               // 66
                void  (*irq_res_67)(void);                               // 67
            #endif
            #if UARTS_AVAILABLE > 5
                void  (*irq_UART5)(void);                                // 68
                void  (*irq_UART5_ERROR)(void);                          // 69
            #else
                void  (*irq_res_68)(void);                               // 68
                void  (*irq_res_69)(void);                               // 69
            #endif
            #if NUMBER_OF_COMPARATORS > 2
                void  (*irq_CMP2)(void);                                 // 70
            #else
                void  (*irq_res_70)(void);                               // 70
            #endif
            void  (*irq_FTM3)(void);                                     // 71
            #if DAC_CONTROLLERS > 1
                void  (*irq_DAC1)(void);                                 // 72
            #else
                void  (*irq_res_72)(void);                               // 72
            #endif
            void  (*irq_ADC1)(void);                                     // 73
            #if defined KINETIS_K24 && ((SIZE_OF_FLASH == 256 * 1024))
                void  (*irq_I2C2)(void);                                 // 74
            #elif !defined KINETIS_KV30 && !defined KINETIS_K22
                void  (*irq_I2C2)(void);                                 // 74
                #if NUMBER_OF_CAN_INTERFACES > 0
                    void  (*irq_CAN0_MESSAGE)(void);                     // 75
                    void  (*irq_CAN0_BUS_OFF)(void);                     // 76
                    void  (*irq_CAN0_ERROR)(void);                       // 77
                    void  (*irq_CAN0_TX)(void);                          // 78
                    void  (*irq_CAN0_RX)(void);                          // 79
                    void  (*irq_CAN0_WAKE_UP)(void);                     // 80
                #else
                    void  (*irq_res_75)(void);                           // 75
                    void  (*irq_res_76)(void);                           // 76
                    void  (*irq_res_77)(void);                           // 77
                    void  (*irq_res_78)(void);                           // 78
                    void  (*irq_res_79)(void);                           // 79
                    void  (*irq_res_80)(void);                           // 80
                #endif
                #if NUMBER_OF_SDHC > 0
                    void  (*irq_SDHC)(void);                             // 81
                #else
                    void  (*irq_res_81)(void);                           // 81
                #endif
                #if !defined KINETIS_K24
                    void  (*irq_ETH_IEEE1588)(void);                     // 82
                    void  (*irq_ETH_TX)(void);                           // 83
                    void  (*irq_ETH_RX)(void);                           // 84
                    void  (*irq_ETH_ERR_MISC)(void);                     // 85
                #endif
                #if defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
                    void  (*irq_LPUART0)(void);                          // 86
                    void  (*irq_TSI0)(void);                             // 87
                    void  (*irq_TPM1)(void);                             // 88
                    void  (*irq_TPM2)(void);                             // 89
                    void  (*irq_USBHS_DCD_PHY)(void);                    // 90
                    void  (*irq_I2C3)(void);                             // 91
                    void  (*irq_CMP3)(void);                             // 92
                    void  (*irq_USB_HS)(void);                           // 93
                    void  (*irq_CAN1_MESSAGE)(void);                     // 94
                    void  (*irq_CAN1_BUS_OFF)(void);                     // 95
                    void  (*irq_CAN1_ERROR)(void);                       // 96
                    void  (*irq_CAN1_TX)(void);                          // 97
                    void  (*irq_CAN1_RX)(void);                          // 98
                    void  (*irq_CAN1_WAKE_UP)(void);                     // 99
                #endif
            #endif
        #endif
    #else
        void  (*irq_SPI2)(void);                                         // 28
        void  (*irq_CAN0_MESSAGE)(void);                                 // 29
        void  (*irq_CAN0_BUS_OFF)(void);                                 // 30
        void  (*irq_CAN0_ERROR)(void);                                   // 31
        void  (*irq_CAN0_TX)(void);                                      // 32
        void  (*irq_CAN0_RX)(void);                                      // 33
        void  (*irq_CAN0_WAKE_UP)(void);                                 // 34
        #if defined KINETIS_K20 && defined KINETIS_REVISION_2
            void (*irq_I2S0_TRANSMIT_ID)(void);                          // 35
            void (*irq_I2S0_RECEIVE_ID)(void);                           // 36
        #else
            void  (*irq_CAN0_IMEU)(void);                                // 35
            void  (*irq_CAN0_LOST_RX)(void);                             // 36
        #endif
        void  (*irq_CAN1_MESSAGE)(void);                                 // 37
        void  (*irq_CAN1_BUS_OFF)(void);                                 // 38
        void  (*irq_CAN1_ERROR)(void);                                   // 39
        void  (*irq_CAN1_TX)(void);                                      // 40
        void  (*irq_CAN1_RX)(void);                                      // 41
        void  (*irq_CAN1_WAKE_UP)(void);                                 // 42
        #if defined KINETIS_K20 && KINETIS_MAX_SPEED > 100000000
            void  (*irq_res_43)(void);                                   // 43
            void  (*irq_UART0_LON)(void);                                // 44
        #else
            void  (*irq_CAN1_IMEU)(void);                                // 43
            void  (*irq_CAN1_LOST_RX)(void);                             // 44
        #endif
        void  (*irq_UART0)(void);                                        // 45
        void  (*irq_UART0_ERROR)(void);                                  // 46
        void  (*irq_UART1)(void);                                        // 47
        void  (*irq_UART1_ERROR)(void);                                  // 48
        void  (*irq_UART2)(void);                                        // 49
        void  (*irq_UART2_ERROR)(void);                                  // 50
        void  (*irq_UART3)(void);                                        // 51
        void  (*irq_UART3_ERROR)(void);                                  // 52
        void  (*irq_UART4)(void);                                        // 53
        void  (*irq_UART4_ERROR)(void);                                  // 54
        void  (*irq_UART5)(void);                                        // 55
        void  (*irq_UART5_ERROR)(void);                                  // 56
        void  (*irq_ADC0)(void);                                         // 57
        void  (*irq_ADC1)(void);                                         // 58
        void  (*irq_CMP0)(void);                                         // 59
        void  (*irq_CMP1)(void);                                         // 60
        void  (*irq_CMP2)(void);                                         // 61
        void  (*irq_FTM0)(void);                                         // 62
        void  (*irq_FTM1)(void);                                         // 63
        void  (*irq_FTM2)(void);                                         // 64
        void  (*irq_CMT)(void);                                          // 65
        void  (*irq_RTC_ALARM)(void);                                    // 66
        #if defined KINETIS_REVISION_2 || (KINETIS_MAX_SPEED <= 50000000)
            void  (*irq_RTC_SECONDS)(void);                              // 67
        #else
            void  (*irq_res_67)(void);                                   // 67
        #endif
        void  (*irq_PIT0)(void);                                         // 68
        void  (*irq_PIT1)(void);                                         // 69
        void  (*irq_PIT2)(void);                                         // 70
        void  (*irq_PIT3)(void);                                         // 71
        void  (*irq_PDB)(void);                                          // 72
        void  (*irq_USB_OTG)(void);                                      // 73
        void  (*irq_USB_CD)(void);                                       // 74
        #if defined ETHERNET_AVAILABLE
            void  (*irq_ETH_IEEE1588)(void);                             // 75
            void  (*irq_ETH_TX)(void);                                   // 76
            void  (*irq_ETH_RX)(void);                                   // 77
            void  (*irq_ETH_ERR_MISC)(void);                             // 78
        #else
            void  (*irq_res_75)(void);                                   // 75
            void  (*irq_res_76)(void);                                   // 76
            void  (*irq_res_77)(void);                                   // 77
            void  (*irq_res_78)(void);                                   // 78
        #endif
        void  (*irq_I2S)(void);                                          // 79
        void  (*irq_SDHC)(void);                                         // 80
        void  (*irq_DAC0)(void);                                         // 81
        void  (*irq_DAC1)(void);                                         // 82
        void  (*irq_TSI)(void);                                          // 83
        void  (*irq_MCG)(void);                                          // 84
        void  (*irq_LPT)(void);                                          // 85
        void  (*reserved86)(void);                                       // 86
        void  (*irq_PORTA)(void);                                        // 87
        void  (*irq_PORTB)(void);                                        // 88
        void  (*irq_PORTC)(void);                                        // 89
        void  (*irq_PORTD)(void);                                        // 90
        void  (*irq_PORTE)(void);                                        // 91
        #if defined KINETIS_K61 || defined KINETIS_K70
            void  (*irq_PORTF)(void);                                    // 92
            void  (*irq_DDR)(void);                                      // 93
            void  (*irq_SOFTWARE)(void);                                 // 94
            void  (*irq_NFC)(void);                                      // 95
            void  (*irq_USB_HS)(void);                                   // 96
            void  (*irq_GLCD)(void);                                     // 97
            void  (*irq_CMP3)(void);                                     // 98
            void  (*irq_TAMPER)(void);                                   // 99
            void  (*reserved100)(void);                                  // 100
            void  (*irq_FTM3)(void);                                     // 101
            void  (*irq_ADC2)(void);                                     // 102
            void  (*irq_ADC3)(void);                                     // 103
            void  (*irq_I2S1_TX)(void);                                  // 104
            void  (*irq_I2S1_RX)(void);                                  // 105
        #elif (defined KINETIS_K60 || defined KINETIS_K20) && (KINETIS_MAX_SPEED > 100000000)
            void  (*irq_PORTF)(void);                                    // 92
            void  (*reserved93)(void);                                   // 93
            void  (*irq_SOFTWARE)(void);                                 // 94
            void  (*irq_NFC)(void);                                      // 95
            void  (*irq_USB_HS)(void);                                   // 96
            void  (*reserved97)(void);                                   // 97
            void  (*irq_CMP3)(void);                                     // 98
            void  (*reserved99)(void);                                   // 99
            void  (*reserved100)(void);                                  // 100
            void  (*irq_FTM3)(void);                                     // 101
            void  (*irq_ADC2)(void);                                     // 102
            void  (*irq_ADC3)(void);                                     // 103
            void  (*irq_I2S1_TX)(void);                                  // 104
            void  (*irq_I2S1_RX)(void);                                  // 105
        #endif
    #endif
#endif
} PROCESSOR_IRQ;


typedef struct stVECTOR_TABLE
{
    RESET_VECTOR  reset_vect;
    void  (*ptrNMI)(void);
    void  (*ptrHardFault)(void);
    void  (*ptrMemManagement)(void);
    void  (*ptrBusFault)(void);
    void  (*ptrUsageFault)(void);
    unsigned long ptrReserved0;
    unsigned long ptrReserved1;
    unsigned long ptrReserved2;
    unsigned long ptrReserved3;
    void  (*ptrSVCall)(void);
    void  (*ptrDebugMonitor)(void);
    unsigned long ptrReserved4;
    void  (*ptrPendSV)(void);
    void  (*ptrSysTick)(void);
    PROCESSOR_IRQ processor_interrupts;                                  // length is processor specific
} VECTOR_TABLE;



// Interrupt sources
//
#if defined KINETIS_KE                                                   // {42}
    #define irq_FTMRH_ID                  5                              // 5
    #define irq_PMC_ID                    6                              // 6
    #define irq_IRQ_ID                    7                              // 7
    #define irq_I2C0_ID                   8                              // 8
  #if defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
    #define irq_I2C1_ID                   9                              // 9
  #endif
    #define irq_SPI0_ID                   10                             // 10
    #define irq_SPI1_ID                   11                             // 11
    #define irq_UART0_ID                  12                             // 12
    #define irq_UART1_ID                  13                             // 13
    #define irq_UART2_ID                  14                             // 14
    #define irq_ADC0_ID                   15                             // 15
    #define irq_CMP0_ID                   16                             // 16
    #define irq_FTM0_ID                   17                             // 17
    #define irq_FTM1_ID                   18                             // 18
    #define irq_FTM2_ID                   19                             // 19
    #define irq_RTC_OVERFLOW_ID           20                             // 20
    #define irq_CMP1_ID                   21                             // 21
    #define irq_PIT0_ID                   22                             // 22
    #define irq_PIT1_ID                   23                             // 23
    #define irq_KBI0_ID                   24                             // 24
    #define irq_KBI1_ID                   25                             // 25

    #define irq_ICS_ID                    27                             // 27
    #define irq_WDOG_ID                   28                             // 28
#elif defined KINETIS_KV && !defined KINETIS_KV30 && !defined KINETIS_KV50
    #define irq_DMA0_ID                   0                              // 0
    #define irq_DMA1_ID                   1                              // 1
    #define irq_DMA2_ID                   2                              // 2
    #define irq_DMA3_ID                   3                              // 3
    #define irq_DMAERROR_ID               4                              // 4
    #define irq_FTFA_ID                   5                              // 5
    #define irq_LOW_VOLTAGE_ID            6                              // 6
    #define irq_LL_wakeup_ID              7                              // 7
    #define irq_I2C0_ID                   8                              // 8
    #define irq_I2C1_ID                   9                              // 9
    #define irq_SPI0_ID                   10                             // 10
    #define irq_SPI1_ID                   11                             // 11
    #define irq_UART0_ID                  12                             // 12
    #define irq_UART1_ID                  13                             // 13
    #define irq_UART2_ID                  14                             // 14
    #define irq_ADC0_ID                   15                             // 15
    #define irq_ADC1_ID                   16                             // 16
    #define irq_FTM0_ID                   17                             // 17
    #define irq_FTM1_ID                   18                             // 18
    #define irq_FTM2_ID                   19                             // 19
    #define irq_MP0_ID                    20                             // 20
    #define irq_CMP1_ID                   21                             // 21

    #define irq_WDOG_EWM_ID               23                             // 23

    #define irq_DAC0_ID                   25                             // 25

    #define irq_MCG_ID                    27                             // 27
    #define irq_LPT_ID                    28                             // 28
    #define irq_PDB_ID                    29                             // 29
    #define irq_PORTA_ID                  30                             // 30
    #define irq_PORTB_C_D_E_ID            31                             // 31 (ports B, C, D and E share an interrupt)
#elif defined KINETIS_KL                                                 // {42}
    #if !defined DEVICE_WITHOUT_DMA
        #define irq_DMA0_ID               0                              // 0
        #define irq_DMA1_ID               1                              // 1
        #define irq_DMA2_ID               2                              // 2
        #define irq_DMA3_ID               3                              // 3
    #endif

    #define irq_FTFA_ID                   5                              // 5
    #define irq_LOW_VOLTAGE_ID            6                              // 6
    #define irq_LL_wakeup_ID              7                              // 7
    #define irq_I2C0_ID                   8                              // 8
    #define irq_I2C1_ID                   9                              // 9
    #define irq_SPI0_ID                   10                             // 10
    #define irq_SPI1_ID                   11                             // 11
    #if LPUARTS_AVAILABLE > 0
        #define irq_LPUART0_ID            12                             // 12
        #define irq_LPUART1_ID            13                             // 13
    #else
        #define irq_UART0_ID              12                             // 12
        #define irq_UART1_ID              13                             // 13
    #endif
    #define irq_UART2_ID                  14                             // 14
    #define irq_ADC0_ID                   15                             // 15
    #define irq_CMP0_ID                   16                             // 16
    #define irq_TPM0_ID                   17                             // 17
    #define irq_TPM1_ID                   18                             // 18
    #define irq_TPM2_ID                   19                             // 19
    #if !defined KINETIS_KL02
        #define irq_RTC_ALARM_ID          20                             // 20
        #define irq_RTC_SECONDS_ID        21                             // 21
    #endif
    #if !defined KINETIS_KL03
        #define irq_PIT_ID                22                             // 22
        #define irq_I2S0_ID               23                             // 23
        #define irq_USB_OTG_ID            24                             // 24
        #define irq_DAC0_ID               25                             // 25
        #define irq_TSI_ID                26                             // 26
        #define irq_MCG_ID                27                             // 27
    #endif
    #define irq_LPT_ID                    28                             // 28
    #define irq_SLCD_ID                   29                             // 29
    #define irq_PORTA_ID                  30                             // 30 (port A)
  #if (PORTS_AVAILABLE == 2)
    #define irq_PORTB_ID                  31                             // 31 (port B)
  #elif defined KINETIS_KL27 && (FLASH_SIZE <= (64 * 1024))
    #define irq_PORTBCD_E_ID              31                             // 31 (ports B, C D and E share an interrupt)
  #elif defined KINETIS_KL25
    #define irq_PORTD_ID                  31                             // 31 (port D)
  #else
    #define irq_PORTC_D_ID                31                             // 31 (port B doesn't support interrupts and ports C and D share an interrupt)
  #endif
#elif defined KINETIS_K21                                                // {44}
    #define irq_DMA0_ID                   0                              // 0
    #define irq_DMA1_ID                   1                              // 1
    #define irq_DMA2_ID                   2                              // 2
    #define irq_DMA3_ID                   3                              // 3
    #define irq_DMA4_ID                   4                              // 4
    #define irq_DMA5_ID                   5                              // 5
    #define irq_DMA6_ID                   6                              // 6
    #define irq_DMA7_ID                   7                              // 7
    #define irq_DMA8_ID                   8                              // 8
    #define irq_DMA9_ID                   9                              // 9
    #define irq_DMA10_ID                  10                             // 10
    #define irq_DMA11_ID                  11                             // 11
    #define irq_DMA12_ID                  12                             // 12
    #define irq_DMA13_ID                  13                             // 13
    #define irq_DMA14_ID                  14                             // 14
    #define irq_DMA15_ID                  15                             // 15
    #define irq_DMA_ERROR_ID              16                             // 16
    #define irq_MCM_ID                    17                             // 17
    #define irq_FLASH_CC_ID               18                             // 18
    #define irq_FLASH_RC_ID               19                             // 19
    #define irq_LOW_VOLTAGE_ID            20                             // 20
    #define irq_LL_wakeup_ID              21                             // 21
    #define irq_WDOG_ID                   22                             // 22
    #define irq_RNG_ID                    23                             // 23
    #define irq_I2C0_ID                   24                             // 24
    #define irq_I2C1_ID                   25                             // 25
    #define irq_SPI0_ID                   26                             // 26
    #define irq_SPI1_ID                   27                             // 27
    #define irq_I2S0_ID                   28                             // 28
    #define irq_I2S1_ID                   29                             // 29
    #if defined KINETIS_K_FPU
        #define irq_UART0_LON_ID          30                             // 30
    #endif
    #define irq_UART0_ID                  31                             // 31
    #define irq_UART0_ERROR_ID            32                             // 32
    #define irq_UART1_ID                  33                             // 33
    #define irq_UART1_ERROR_ID            34                             // 34
    #define irq_UART2_ID                  35                             // 35
    #define irq_UART2_ERROR_ID            36                             // 36
    #define irq_UART3_ID                  37                             // 37
    #define irq_UART3_ERROR_ID            38                             // 38
    #define irq_ADC0_ID                   39                             // 39
    #define irq_CMP0_ID                   40                             // 40
    #define irq_CMP1_ID                   41                             // 41
    #define irq_FTM0_ID                   42                             // 42
    #define irq_FTM1_ID                   43                             // 43
    #define irq_FTM2_ID                   44                             // 44
    #define irq_CMT_ID                    45                             // 45
    #define irq_RTC_ALARM_ID              46                             // 46
    #define irq_RTC_SECONDS_ID            47                             // 47
    #define irq_PIT0_ID                   48                             // 48
    #define irq_PIT1_ID                   49                             // 49
    #define irq_PIT2_ID                   50                             // 50
    #define irq_PIT3_ID                   51                             // 51
    #define irq_PDB_ID                    52                             // 52
    #define irq_USB_OTG_ID                53                             // 53
    #define irq_USB_CD_ID                 54                             // 54

    #define irq_DAC0_ID                   56                             // 56
    #define irq_MCG_ID                    57                             // 57
    #define irq_LPT_ID                    58                             // 58
    #define irq_PORTA_ID                  59                             // 59
    #define irq_PORTB_ID                  60                             // 60
    #define irq_PORTC_ID                  61                             // 61
    #define irq_PORTD_ID                  62                             // 62
    #define irq_PORTE_ID                  63                             // 63
    #define irq_SW_IRQ_ID                 64                             // 64
    #if defined KINETIS_K_FPU
        #define irq_SPI2_ID               65                             // 65
        #define irq_UART4_ID              66                             // 66
        #define irq_UART4_ERROR_ID        67                             // 67
        #define irq_UART5_ID              68                             // 68
        #define irq_UART5_ERROR_ID        69                             // 69
        #define irq_CMP2_ID               70                             // 70
        #define irq_FTM3_ID               71                             // 71
        #define irq_DAC1_ID               72                             // 72
        #define irq_ADC1_ID               73                             // 73
        #define irq_I2C2_ID               74                             // 74
        #define irq_CAN0_MESSAGE_ID       75                             // 75
        #define irq_CAN0_BUS_OFF_ID       76                             // 76
        #define irq_CAN0_ERROR_ID         77                             // 77
        #define irq_CAN0_TX_ID            78                             // 78
        #define irq_CAN0_RX_ID            79                             // 79
        #define irq_CAN0_WAKE_UP_ID       80                             // 80
        #define irq_SDHC_ID               81                             // 81
    #endif
#elif (KINETIS_MAX_SPEED <= 50000000) && !defined KINETIS_KW2X
    #define irq_DMA0_ID                   0                              // 0
    #define irq_DMA1_ID                   1                              // 1
    #define irq_DMA2_ID                   2                              // 2
    #define irq_DMA3_ID                   3                              // 3
    #define irq_DMA_ERROR_ID              4                              // 4

    #define irq_FLASH_CC_ID               6                              // 6
    #define irq_FLASH_RC_ID               7                              // 7
    #define irq_LOW_VOLTAGE_ID            8                              // 8
    #define irq_LL_wakeup_ID              9                              // 9
    #define irq_WDOG_ID                   10                             // 10
    #define irq_I2C0_ID                   11                             // 11
    #define irq_SPI0_ID                   12                             // 12
    #define irq_I2S0_TX_ID                13                             // 13
    #define irq_I2S0_RX_ID                14                             // 14
    #define irq_UART0_LON_ID              15                             // 15
    #define irq_UART0_ID                  16                             // 16
    #define irq_UART0_ERROR_ID            17                             // 17
    #define irq_UART1_ID                  18                             // 18
    #define irq_UART1_ERROR_ID            19                             // 19
    #define irq_UART2_ID                  20                             // 20
    #define irq_UART2_ERROR_ID            21                             // 21
    #define irq_ADC0_ID                   22                             // 22
    #define irq_CMP0_ID                   23                             // 23
    #define irq_CMP1_ID                   24                             // 24
    #define irq_FTM0_ID                   25                             // 25
    #define irq_FTM1_ID                   26                             // 26
    #define irq_CMT_ID                    27                             // 27
    #define irq_RTC_ALARM_ID              28                             // 28
    #define irq_RTC_SECONDS_ID            29                             // 29
    #define irq_PIT0_ID                   30                             // 30
    #define irq_PIT1_ID                   31                             // 31
    #define irq_PIT2_ID                   32                             // 32
    #define irq_PIT3_ID                   33                             // 33
    #define irq_PDB_ID                    34                             // 34
    #define irq_USB_OTG_ID                35                             // 35
    #define irq_USB_CD_ID                 36                             // 36
    #define irq_TSI_ID                    37                             // 37
    #define irq_MCG_ID                    38                             // 38
    #define irq_LPT_ID                    39                             // 39
    #define irq_PORTA_ID                  40                             // 40
    #define irq_PORTB_ID                  41                             // 41
    #define irq_PORTC_ID                  42                             // 43
    #define irq_PORTD_ID                  43                             // 43
    #define irq_PORTE_ID                  44                             // 44
    #define irq_SW_IRQ_ID                 45                             // 45
#else
    #define irq_DMA0_ID                   0                              // 0
    #define irq_DMA1_ID                   1                              // 1
    #define irq_DMA2_ID                   2                              // 2
    #define irq_DMA3_ID                   3                              // 3
    #if !defined KINETIS_K02
        #define irq_DMA4_ID               4                              // 4
        #define irq_DMA5_ID               5                              // 5
        #define irq_DMA6_ID               6                              // 6
        #define irq_DMA7_ID               7                              // 7
        #define irq_DMA8_ID               8                              // 8
        #define irq_DMA9_ID               9                              // 9
        #define irq_DMA10_ID              10                             // 10
        #define irq_DMA11_ID              11                             // 11
        #define irq_DMA12_ID              12                             // 12
        #define irq_DMA13_ID              13                             // 13
        #define irq_DMA14_ID              14                             // 14
        #define irq_DMA15_ID              15                             // 15
    #endif
    #define irq_DMA_ERROR_ID              16                             // 16
    #define irq_MCM_ID                    17                             // 17
    #define irq_FLASH_CC_ID               18                             // 18
    #define irq_FLASH_RC_ID               19                             // 19
    #define irq_LOW_VOLTAGE_ID            20                             // 20
    #define irq_LL_wakeup_ID              21                             // 21
    #define irq_WDOG_ID                   22                             // 22
    #if defined RNG_AVAILABLE
        #define irq_RNG_ID                23                             // 23
    #endif
    #define irq_I2C0_ID                   24                             // 24
    #define irq_I2C1_ID                   25                             // 25
    #define irq_SPI0_ID                   26                             // 26
    #define irq_SPI1_ID                   27                             // 27
    #if defined KINETIS_K80
        #define irq_I2S0_TX_ID            28                             // 28
        #define irq_I2S0_RX_ID            29                             // 29
        #define irq_LPUART0_ID            30                             // 30
        #define irq_LPUART1_ID            31                             // 31
        #define irq_LPUART2_ID            32                             // 32
        #define irq_LPUART3_ID            33                             // 33
        #define irq_LPUART4_ID            34                             // 34

        #define irq_EVMSIM0_ID            37                             // 37
        #define irq_EVMSIM1_ID            38                             // 38
        #define irq_ADC0_ID               39                             // 39
        #define irq_CMP0_ID               40                             // 40
        #define irq_CMP1_ID               41                             // 41
        #define irq_FTM0_ID               42                             // 42
        #define irq_FTM1_ID               43                             // 43
        #define irq_FTM2_ID               44                             // 44
        #define irq_CMT_ID                45                             // 45
        #define irq_RTC_ALARM_ID          46                             // 46
        #define irq_RTC_SECONDS_ID        47                             // 47
        #define irq_PIT0_ID               48                             // 48
        #define irq_PIT1_ID               49                             // 49
        #define irq_PIT2_ID               50                             // 50
        #define irq_PIT3_ID               51                             // 51
        #define irq_PDB_ID                52                             // 52
        #define irq_USB_OTG_ID            53                             // 53
        #define irq_USB_CD_ID             54                             // 54

        #define irq_DAC0_ID               56                             // 56
        #define irq_MCG_ID                57                             // 57
        #define irq_LPT_ID                58                             // 58
        #define irq_PORTA_ID              59                             // 59
        #define irq_PORTB_ID              60                             // 60
        #define irq_PORTC_ID              61                             // 61
        #define irq_PORTD_ID              62                             // 62
        #define irq_PORTE_ID              63                             // 63
        #define irq_SOFTWARE_ID           64                             // 64
        #define irq_SPI2_ID               65                             // 65

        #define irq_FLEXIO_ID             70                             // 70
        #define irq_FTM3_ID               71                             // 71

        #define irq_I2C2_ID               74                             // 74

        #define irq_SDHC_ID               81                             // 81

        #define irq_TSI0_ID               87                             // 87
        #define irq_TPM1_ID               88                             // 88
        #define irq_TPM2_ID               89                             // 89

        #define irq_I2C3_ID               91                             // 91

        #define irq_QSPI_ID               100                            // 100
    #elif defined KINETIS_K02 || defined KINETIS_K26 || defined KINETIS_K64 || defined KINETIS_K65 || defined KINETIS_K66 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_KV30 || defined KINETIS_KW2X // {46}
        #if defined KINETIS_KW2X || defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
            #define irq_I2S0_TX_ID        28                             // 28
            #define irq_I2S0_RX_ID        29                             // 29
        #else
            #define irq_I2S1_TX_ID        28                             // 28
            #define irq_I2S1_RX_ID        29                             // 29
            #define irq_LPUART0_ID        30                             // 30
        #endif
        #define irq_UART0_ID              31                             // 31
        #define irq_UART0_ERROR_ID        32                             // 32
        #define irq_UART1_ID              33                             // 33
        #define irq_UART1_ERROR_ID        34                             // 34
        #define irq_UART2_ID              35                             // 35
        #define irq_UART2_ERROR_ID        36                             // 36
        #if !defined KINETIS_KW2X
            #define irq_UART3_ID          37                             // 37
            #define irq_UART3_ERROR_ID    38                             // 38
        #endif
        #define irq_ADC0_ID               39                             // 39
        #define irq_CMP0_ID               40                             // 40
        #define irq_CMP1_ID               41                             // 41
        #define irq_FTM0_ID               42                             // 42
        #define irq_FTM1_ID               43                             // 43
        #define irq_FTM2_ID               44                             // 44
        #define irq_CMT_ID                45                             // 45
        #if !defined KINETIS_KV30
            #define irq_RTC_ALARM_ID      46                             // 46
            #define irq_RTC_SECONDS_ID    47                             // 47
        #endif
        #define irq_PIT0_ID               48                             // 48
        #define irq_PIT1_ID               49                             // 49
        #define irq_PIT2_ID               50                             // 50
        #define irq_PIT3_ID               51                             // 51
        #define irq_PDB_ID                52                             // 52
        #define irq_USB_OTG_ID            53                             // 53
        #define irq_USB_CD_ID             54                             // 54

        #define irq_DAC0_ID               56                             // 56
        #define irq_MCG_ID                57                             // 57
        #define irq_LPT_ID                58                             // 58
        #define irq_PORTA_ID              59                             // 59
        #define irq_PORTB_ID              60                             // 60
        #define irq_PORTC_ID              61                             // 61
        #define irq_PORTD_ID              62                             // 62
        #define irq_PORTE_ID              63                             // 63
        #define irq_SOFTWARE_ID           64                             // 64
        #if !defined KINETIS_K02 && !defined KINETIS_KW2X
            #define irq_SPI2_ID           65                             // 65
            #if UARTS_AVAILABLE > 4
                #define irq_UART4_ID          66                         // 66
                #define irq_UART4_ERROR_ID    67                         // 67
            #endif
            #if UARTS_AVAILABLE > 5
                #define irq_UART5_ID          68                         // 68
                #define irq_UART5_ERROR_ID    69                         // 69
            #endif
            #define irq_CMP2_ID           70                             // 70
            #define irq_FTM3_ID           71                             // 71
            #define irq_DAC1_ID           72                             // 72
            #define irq_ADC1_ID           73                             // 73
            #if !defined KINETIS_KV30 && !defined KINETIS_K22
                #define irq_I2C2_ID           74                         // 74
                #define irq_CAN0_MESSAGE_ID   75                         // 75
                #define irq_CAN0_BUS_OFF_ID   76                         // 76
                #define irq_CAN0_ERROR_ID     77                         // 77
                #define irq_CAN0_TX_ID        78                         // 78
                #define irq_CAN0_RX_ID        79                         // 79
                #define irq_CAN0_WAKE_UP_ID   80                         // 80
                #define irq_SDHC_ID           81                         // 81
                #define irq_ETH_IEEE1588_ID   82                         // 82
                #define irq_ETH_TX_ID         83                         // 83
                #define irq_ETH_RX_ID         84                         // 84
                #define irq_ETH_ERR_MISC_ID   85                         // 85
                #if defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
                    #define irq_LPUART0_ID    86                         // 86
                    #define irq_TSI0_ID       87                         // 87
                    #define irq_TPM1_ID       88                         // 88
                    #define irq_TPM2_ID       89                         // 89
                    #define irq_USBHS_DCD_PHY_ID 90                      // 90
                    #define irq_I2C3_ID       91                         // 91
                    #define irq_CMP3_ID       92                         // 92
                    #define irq_USB_HS_ID     93                         // 93
                    #define irq_CAN1_MESSAGE_ID  94                      // 94
                    #define irq_CAN1_BUS_OFF_ID  95                      // 95
                    #define irq_CAN1_ERROR_ID    96                      // 96
                    #define irq_CAN1_TX_ID       97                      // 97
                    #define irq_CAN1_RX_ID       98                      // 98
                    #define irq_CAN1_WAKE_UP_ID  99                      // 99
                #endif
            #endif
        #endif
    #else
        #define irq_SPI2_ID               28                             // 28
        #define irq_CAN0_MESSAGE_ID       29                             // 29
        #define irq_CAN0_BUS_OFF_ID       30                             // 30
        #define irq_CAN0_ERROR_ID         31                             // 31
        #define irq_CAN0_TX_ID            32                             // 32
        #define irq_CAN0_RX_ID            33                             // 33
        #define irq_CAN0_WAKE_UP_ID       34                             // 34
        #if defined KINETIS_K20 && defined KINETIS_REVISION_2
            #define irq_I2S0_TRANSMIT_ID  35                             // 35
            #define irq_I2S0_RECEIVE_ID   36                             // 36
        #else
            #define irq_CAN0_IMEU_ID      35                             // 35
            #define irq_CAN0_LOST_RX_ID   36                             // 36
        #endif
        #define irq_CAN1_MESSAGE_ID       37                             // 37
        #define irq_CAN1_BUS_OFF_ID       38                             // 38
        #define irq_CAN1_ERROR_ID         39                             // 39
        #define irq_CAN1_TX_ID            40                             // 40
        #define irq_CAN1_RX_ID            41                             // 41
        #define irq_CAN1_WAKE_UP_ID       42                             // 42
        #if defined KINETIS_K20 && KINETIS_MAX_SPEED > 100000000

            #define irq_UART0_LON_ID      44                             // 44
        #else
            #define irq_CAN1_IMEU_ID      43                             // 43
            #define irq_CAN1_LOST_RX_ID   44                             // 44
        #endif
        #define irq_UART0_ID              45                             // 45
        #define irq_UART0_ERROR_ID        46                             // 46
        #define irq_UART1_ID              47                             // 47
        #define irq_UART1_ERROR_ID        48                             // 48
        #define irq_UART2_ID              49                             // 49
        #define irq_UART2_ERROR_ID        50                             // 50
        #define irq_UART3_ID              51                             // 51
        #define irq_UART3_ERROR_ID        52                             // 52
        #define irq_UART4_ID              53                             // 53
        #define irq_UART4_ERROR_ID        54                             // 54
        #define irq_UART5_ID              55                             // 55
        #define irq_UART5_ERROR_ID        56                             // 56
        #define irq_ADC0_ID               57                             // 57
        #define irq_ADC1_ID               58                             // 58
        #define irq_CMP0_ID               59                             // 59
        #define irq_CMP1_ID               60                             // 60
        #define irq_CMP2_ID               61                             // 61
        #define irq_FTM0_ID               62                             // 62
        #define irq_FTM1_ID               63                             // 63
        #define irq_FTM2_ID               64                             // 64
        #define irq_CMT_ID                65                             // 65
        #define irq_RTC_ALARM_ID          66                             // 66
        #if defined KINETIS_REVISION_2
            #define irq_RTC_SECONDS_ID    67                             // 67
        #endif
        #define irq_PIT0_ID               68                             // 68
        #define irq_PIT1_ID               69                             // 69
        #define irq_PIT2_ID               70                             // 70
        #define irq_PIT3_ID               71                             // 71
        #define irq_PDB_ID                72                             // 72
        #define irq_USB_OTG_ID            73                             // 73
        #define irq_USB_CD_ID             74                             // 74
        #if defined ETHERNET_AVAILABLE
            #define irq_ETH_IEEE1588_ID   75                             // 75
            #define irq_ETH_TX_ID         76                             // 76
            #define irq_ETH_RX_ID         77                             // 77
            #define irq_ETH_ERR_MISC_ID   78                             // 78
        #endif
        #define irq_I2S_ID                79                             // 79
        #define irq_SDHC_ID               80                             // 80
        #define irq_DAC0_ID               81                             // 81
        #define irq_DAC1_ID               82                             // 82
        #define irq_TSI_ID                83                             // 83
        #define irq_MCG_ID                84                             // 84
        #define irq_LPT_ID                85                             // 85

        #define irq_PORTA_ID              87                             // 87
        #define irq_PORTB_ID              88                             // 88
        #define irq_PORTC_ID              89                             // 89
        #define irq_PORTD_ID              90                             // 90
        #define irq_PORTE_ID              91                             // 91
        #if defined KINETIS_K61 || defined KINETIS_K70
            #define irq_PORTF_ID          92                             // 92
            #define irq_DDR_ID            93                             // 93
            #define irq_SOFTWARE_ID       94                             // 94
            #define irq_NFC_ID            95                             // 95
            #define irq_USB_HS_ID         96                             // 96
            #define irq_GLCD_ID           97                             // 97
            #define irq_CMP3_ID           98                             // 98
            #define irq_TAMPER_ID         99                             // 99
            #define irq_FTM3_ID           101                            // 101
            #define irq_ADC2_ID           102                            // 102
            #define irq_ADC3_ID           103                            // 103
            #define irq_I2S1_TX_ID        104                            // 104
            #define irq_I2S1_RX_ID        104                            // 105
        #elif (defined KINETIS_K60 || defined KINETIS_K20) && (KINETIS_MAX_SPEED > 100000000)
            #define irq_PORTF_ID          92                             // 92

            #define irq_SOFTWARE_ID       94                             // 94
            #define irq_NFC_ID            95                             // 95
            #define irq_USB_HS_ID         96                             // 96

            #define irq_CMP3_ID           98                             // 98

            #define irq_FTM3_ID           101                            // 101
            #define irq_ADC2_ID           102                            // 102
            #define irq_ADC3_ID           103                            // 103
            #define irq_I2S1_TX_ID        104                            // 104
            #define irq_I2S1_RX_ID        105                            // 105
        #endif
    #endif
#endif

#define VECTOR_SIZE                      (sizeof(VECTOR_TABLE))

#if defined KINETIS_KE                                                   // {42}
    #define LAST_PROCESSOR_IRQ     irq_WDOG
    #define CHECK_VECTOR_SIZE                180                         // (16 + 28 + 1) = 45) * 4 - adequate for this processor [0xb4]
#elif defined KINETIS_K02 || defined KINETIS_KW2X
    #define LAST_PROCESSOR_IRQ     irq_SOFTWARE
    #define CHECK_VECTOR_SIZE                324                         // (16 + 64 + 1) = 81) * 4 - adequate for this processor [0x144]
#elif defined KINETIS_KV30 || defined KINETIS_K22
    #define LAST_PROCESSOR_IRQ     irq_ADC1
    #define CHECK_VECTOR_SIZE                360                         // (16 + 73 + 1) = 90) * 4 - adequate for this processor [0x168]
#elif defined KINETIS_KV
    #define LAST_PROCESSOR_IRQ     irq_PORTB_C_D_E
    #define CHECK_VECTOR_SIZE                192                         // (16 + 31 + 1) = 48) * 4 - adequate for this processor [0xc0]
#elif defined KINETIS_KL                                                 // {42}
  #if (PORTS_AVAILABLE == 2)
    #define LAST_PROCESSOR_IRQ     irq_PORTB
  #elif defined irq_PORTBCD_E_ID
    #define LAST_PROCESSOR_IRQ     irq_PORTBCD_E
  #else
    #define LAST_PROCESSOR_IRQ     irq_PORTC_D
  #endif
    #define CHECK_VECTOR_SIZE                192                         // (16 + 31 + 1) = 48) * 4 - adequate for this processor [0xc0]
#elif defined KINETIS_K21 && defined KINETIS_K_FPU
    #define LAST_PROCESSOR_IRQ     irq_SDHC
    #define CHECK_VECTOR_SIZE                392                         // (16 + 81 + 1) = 98) * 4 - adequate for this processor [0x188]
#elif defined KINETIS_K21                                                // {44}
    #define LAST_PROCESSOR_IRQ     irq_SW_IRQ
    #define CHECK_VECTOR_SIZE                324                         // (16 + 64 + 1) = 81) * 4 - adequate for this processor [0x144]
#elif defined KINETIS_K24 && (SIZE_OF_FLASH == (1024 * 1024))
    #define LAST_PROCESSOR_IRQ     irq_SDHC
    #define CHECK_VECTOR_SIZE                392                         // (16 + 81 + 1) = 98) * 4 - adequate for this processor [0x188]
#elif defined KINETIS_K24
    #define LAST_PROCESSOR_IRQ     irq_I2C2
    #define CHECK_VECTOR_SIZE                364                         // (16 + 74 + 1) = 91) * 4 - adequate for this processor [0x16c]
#elif defined KINETIS_K64                                                // {46}
    #define LAST_PROCESSOR_IRQ     irq_ETH_ERR_MISC
    #define CHECK_VECTOR_SIZE                408                         // (16 + 85 + 1) = 102) * 4 - adequate for this processor [0x198]
#elif KINETIS_MAX_SPEED <= 50000000
    #define LAST_PROCESSOR_IRQ     irq_SW_IRQ
    #define CHECK_VECTOR_SIZE                248                         // (16 + 45 + 1) = 62) * 4 - adequate for this processor [0xf8]
#elif defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
    #define LAST_PROCESSOR_IRQ     irq_CAN1_WAKE_UP
    #define CHECK_VECTOR_SIZE                464                         // (16 + 99 + 1) = 116) * 4 - adequate for this processor [0x1d0]
#elif defined KINETIS_K61 || defined KINETIS_K70 || ((defined KINETIS_K60 || defined KINETIS_K20) && KINETIS_MAX_SPEED > 100000000)
    #define LAST_PROCESSOR_IRQ     irq_I2S1_RX
    #define CHECK_VECTOR_SIZE                488                         // (16 + 105 + 1) = 122) * 4 - adequate for this processor [0x1e8]
#elif defined KINETIS_K80
    #define LAST_PROCESSOR_IRQ     irq_QSPI
    #define CHECK_VECTOR_SIZE                468                         // (16 + 100 + 1) = 117    ) * 4 - adequate for this processor [0x1e8]
#else
    #define LAST_PROCESSOR_IRQ     irq_PORTE
    #define CHECK_VECTOR_SIZE                432                         // (16 + 91 + 1) = 108) * 4 - adequate for this processor  [0x1b0]
#endif






#if defined _WINDOWS
    #include "simkinetis.h"
#endif

// Peripheral Register Blocks
//
#if defined _WINDOWS
    #if defined KINETIS_KL                                                  // {48}
        #if !defined DEVICE_WITHOUT_DMA
            #define DMA_BLOCK                  ((unsigned char *)(&kinetis.DMA)) // DMA Controller
        #endif
    #else
        #define eDMA_BLOCK                     ((unsigned char *)(&kinetis.eDMA)) // eDMA Controller
        #define eDMA_DESCRIPTORS               ((unsigned char *)(&kinetis.eDMADES)) // eDMA Descriptor Memory
        #define FLEXBUS_ADD                    ((unsigned char *)(&kinetis.FB))// FlexBus
    #endif
    #if defined MPU_AVAILABLE
        #define MPU_BLOCK                      ((unsigned char *)(&kinetis.MPU)) // Memory Protection Unit
    #endif
    #if !defined KINETIS_KL
        #define FMC_BLOCK                      ((unsigned char *)(&kinetis.FMC)) // Flash Memory Controller
    #endif
    #define FTFL_BLOCK                         ((unsigned char *)(&kinetis.FTFL)) // Flash Memory Module
    #define DMAMUX0_BLOCK                      ((unsigned char *)(&kinetis.DMAMUX[0])) // DMAMUX0
    #if defined KINETIS_K70 || (defined KINETIS_K60 && defined KINETIS_K_FPU)
        #define DMAMUX1_BLOCK                  ((unsigned char *)(&kinetis.DMAMUX[1])) // DMAMUX1
    #endif
    #if defined I2S_AVAILABLE
        #define I2S0_BLOCK                     ((unsigned char *)(&kinetis.I2S_SAI[0])) // I2S0
    #endif
    #if defined KINETIS_KE
        #define IRQ_BLOCK                      ((unsigned char *)(&kinetis.IRQ)) // external IRQ
    #endif
    #if defined KINETIS_KL || defined KINETIS_KE
        #define SPI0_BLOCK                     ((unsigned char *)(&kinetis.SPI[0])) // SPI0
        #define SPI1_BLOCK                     ((unsigned char *)(&kinetis.SPI[1])) // SPI1
        #if KBIS_AVAILABLE > 0
            #define KBI0_BLOCK                 ((unsigned char *)(&kinetis.KBI[0])) // Keyboard interrupt 0
        #endif
        #if KBIS_AVAILABLE > 1
            #define KBI1_BLOCK                 ((unsigned char *)(&kinetis.KBI[1])) // Keyboard interrupt 1
        #endif
        #if defined MSCAN_CAN_INTERFACE
            #define MSCAN_BASE_ADD             ((unsigned char *)(&kinetis.MSCAN)) // MSCAN module
        #endif
    #else
        #define CAN0_BASE_ADD                  ((unsigned char *)(&kinetis.CAN[0])) // FLEXCAN module 0
        #if NUMBER_OF_CAN_INTERFACES > 1
            #define CAN1_BASE_ADD              ((unsigned char *)(&kinetis.CAN[1])) // FLEXCAN module 1
        #endif
        #define DSPI0_BLOCK                    ((unsigned char *)(&kinetis.DSPI[0])) // DSPI0
        #define DSPI1_BLOCK                    ((unsigned char *)(&kinetis.DSPI[1])) // DSPI1
        #define CRC_BLOCK                      ((unsigned char *)(&kinetis.CRC)) // {8} CRC 
    #endif
    #if defined LLWU_AVAILABLE
        #define LLWU_BLOCK                     ((unsigned char *)(&kinetis.LLWU)) // {62} Low-Leakage Wakeup Unit
    #endif
    #define PMC_BLOCK                          ((unsigned char *)(&kinetis.PMC)) // Power Management Controller
    #if defined HS_USB_AVAILABLE
        #define USBHS_BASE_ADD                 ((unsigned char *)(&kinetis.USBHS)) // {25} USBHS
        #if defined KINETIS_WITH_USBPHY
            #define USBHS_PHY_ADD              ((unsigned char *)(&kinetis.USBHSPHY)) // {77} integrated HS USB2.0 PHY
        #endif
    #endif
    #if defined PWT_AVAILABLE
        #define PWT_BLOCK                      ((unsigned char *)(&kinetis.PWT)) // {88} PWT
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define PDB_BLOCK                      ((unsigned char *)(&kinetis.PDB)) // {31} PDB
    #endif
    #if !defined KINETIS_WITHOUT_PIT
        #define PIT_BLOCK                      ((unsigned char *)(&kinetis.PIT)) // PITs
    #endif
    #define FTM_BLOCK_0                        ((unsigned char *)(&kinetis.FTM[0])) // FlexTimer 0 (TPM0 in KL/KE)
    #define FTM_BLOCK_1                        ((unsigned char *)(&kinetis.FTM[1])) // FlexTimer 1 (TPM1 in KL/KE)
    #if defined KINETIS_KL || defined KINETIS_KE
        #define FTM_BLOCK_2                    ((unsigned char *)(&kinetis.FTM[2])) // FlexTimer 2 (TPM2 in KL/KE)
    #endif
    #define ADC0_BLOCK                         ((unsigned char *)(&kinetis.ADC0)) // ADC0
    #if ADC_CONTROLLERS > 2
        #define ADC2_BLOCK                     ((unsigned char *)(&kinetis.ADC2)) // ADC2
    #endif
    #if !defined KINETIS_KL02
        #define RTC_BLOCK                      ((unsigned char *)(&kinetis.RTC)) // RTC
    #endif
    #if !defined KINETIS_KE
        #define LPTMR_BLOCK                    ((unsigned char *)(&kinetis.LPTMR)) // {51} Low Power Timer
    #endif
    #if !defined KINETIS_KE && !defined KINETIS_KL
        #define AXBS_BLOCK                     ((unsigned char *)(&kinetis.AXBS)) // {50} Crossbar Switch
    #endif
    #define TSI_BLOCK                          ((unsigned char *)(&kinetis.TSI)) // Touch Sense Input Module
    #define SIM_BLOCK                          ((unsigned char *)(&kinetis.SIM)) // System Integration Module
    #if defined KINETIS_KE
        #define PORT_BLOCK                     ((unsigned char *)(&kinetis.PORT)) // Port block
    #else
        #define PORT0_BLOCK                    ((unsigned char *)(&kinetis.PORT[0])) // Port Control and Interrupts
        #define PORT1_BLOCK                    ((unsigned char *)(&kinetis.PORT[1]))
        #if PORTS_AVAILABLE > 2
            #define PORT2_BLOCK                ((unsigned char *)(&kinetis.PORT[2]))
            #define PORT3_BLOCK                ((unsigned char *)(&kinetis.PORT[3]))
            #define PORT4_BLOCK                ((unsigned char *)(&kinetis.PORT[4]))
        #endif
        #if PORTS_AVAILABLE > 5
            #define PORT5_BLOCK                ((unsigned char *)(&kinetis.PORT[5]))
        #endif
    #endif
    #if !defined KINETIS_KL || defined KINETIS_KL82
        #define WDOG_BLOCK                     ((unsigned char *)(&kinetis.WDOG)) // Watchdog Timer
    #endif
    #if defined CHIP_HAS_FLEXIO
        #define FLEXIO_BLOCK                   ((unsigned char *)(&kinetis.FLEXIO)) // FlexIO
    #endif
    #if defined LTC_AVAILABLE
        #define LTC_BLOCK                      ((unsigned char *)(&kinetis.LTC))   // LTC
    #endif
    #if defined KINETIS_K80
        #define QSPI_BLOCK                     ((unsigned char *)(&kinetis.QSPI)) // QuadSPI
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define EWM_BLOCK                      ((unsigned char *)(&kinetis.EWM)) // External Watchdog Monitor
    #endif
    #if defined KINETIS_KE
        #define INTERNAL_CLOCK_BLOCK           ((unsigned char *)(&kinetis.ICS)) // Internal clock source
    #elif defined KINETIS_WITH_SCG
        #define SCG_BLOCK                      ((unsigned char *)(&kinetis.SCG)) // System Clock Generator
    #else
        #define MCG_BLOCK                      ((unsigned char *)(&kinetis.MCG)) // Multi-purpose Clock Generator
    #endif
    #define OSC0_BLOCK                         ((unsigned char *)(&kinetis.OSC[0])) // Oscillator 0
    #define OSC1_BLOCK                         ((unsigned char *)(&kinetis.OSC[1])) // Oscillator 1
    #define I2C0_BLOCK                         ((unsigned char *)(&kinetis.I2C[0])) // I2C0
    #if I2C_AVAILABLE > 1
        #define I2C1_BLOCK                     ((unsigned char *)(&kinetis.I2C[1])) // I2C1
    #endif
    #if I2C_AVAILABLE > 2
        #define I2C2_BLOCK                     ((unsigned char *)(&kinetis.I2C[2])) // I2C1
    #endif
    #if I2C_AVAILABLE > 3
        #define I2C3_BLOCK                     ((unsigned char *)(&kinetis.I2C[3])) // I2C1
    #endif
    #if LPUARTS_AVAILABLE > 0
        #define LPUART0_BLOCK                  ((unsigned char *)(&kinetis.LPUART[0])) // LPUART0
    #endif
    #if LPUARTS_AVAILABLE > 1
        #define LPUART1_BLOCK                  ((unsigned char *)(&kinetis.LPUART[1])) // LPUART1
    #endif
    #if LPUARTS_AVAILABLE > 2
        #define LPUART2_BLOCK                  ((unsigned char *)(&kinetis.LPUART[2])) // LPUART2
    #endif
    #if LPUARTS_AVAILABLE > 3
        #define LPUART3_BLOCK                  ((unsigned char *)(&kinetis.LPUART[3])) // LPUART3
    #endif
    #if LPUARTS_AVAILABLE > 4
        #define LPUART4_BLOCK                  ((unsigned char *)(&kinetis.LPUART[4])) // LPUART4
    #endif
    #if UARTS_AVAILABLE > 0 && (LPUARTS_AVAILABLE < 1 || defined LPUARTS_PARALLEL)
        #define UART0_BLOCK                    ((unsigned char *)(&kinetis.UART[0])) // UART
    #endif
    #if UARTS_AVAILABLE > 1 && (LPUARTS_AVAILABLE < 2 || defined LPUARTS_PARALLEL)
        #define UART1_BLOCK                    ((unsigned char *)(&kinetis.UART[1]))
    #endif
    #if (UARTS_AVAILABLE > 2 && (LPUARTS_AVAILABLE < 3 || defined LPUARTS_PARALLEL)) || ((UARTS_AVAILABLE == 1 && LPUARTS_AVAILABLE == 2))
        #define UART2_BLOCK                    ((unsigned char *)(&kinetis.UART[2]))
    #endif
    #if UARTS_AVAILABLE > 3
        #define UART3_BLOCK                    ((unsigned char *)(&kinetis.UART[3]))
    #endif
    #if UARTS_AVAILABLE > 4
        #define UART4_BLOCK                    ((unsigned char *)(&kinetis.UART[4]))
    #endif
    #if UARTS_AVAILABLE > 5
        #define UART5_BLOCK                    ((unsigned char *)(&kinetis.UART[5]))
    #endif
    #define USB_BASE_ADD                       ((unsigned char *)(&kinetis.USB)) // USB-OTG Controller
    #if defined KINETIS_K_FPU || defined KINETIS_KL || defined KINETIS_REVISION_2 || (KINETIS_MAX_SPEED > 100000000) // {43}
        #define SMC_BASE_ADD                   ((unsigned char *)(&kinetis.SMC)) // System Mode Controller
        #define RCM_BASE_ADD                   ((unsigned char *)(&kinetis.RCM)) // Reset Control Module
    #elif !defined KINETIS_KE && !defined KINETIS_KEA
        #define MC_BASE_ADD                    ((unsigned char *)(&kinetis.MC)) // Mode Control
    #endif
    #if defined KINETIS_KE                                               // {85}
        #define ACMP0_BLOCK                    ((unsigned char *)(&kinetis.ACMP[0])) // Analogue comparator 0
        #define ACMP1_BLOCK                    ((unsigned char *)(&kinetis.ACMP[1])) // Analogue comparator 1
    #else
        #define CMP0_BLOCK                     ((unsigned char *)(&kinetis.CMP[0])) // comparator 0
        #define CMP1_BLOCK                     ((unsigned char *)(&kinetis.CMP[1])) // comparator 1
        #define CMP2_BLOCK                     ((unsigned char *)(&kinetis.CMP[2])) // comparator 2
        #define CMP3_BLOCK                     ((unsigned char *)(&kinetis.CMP[3])) // comparator 3
    #endif
    #if !defined KINETIS_KL
        #define VREF_ADD                       ((unsigned char *)(&kinetis.VREF)) // VREF
    #endif
    #if defined RNG_AVAILABLE
        #define RNGA_BASE_ADD                  ((unsigned char *)(&kinetis.RNGA)) // {41} Random Number Generator A
        #define RNGB_BASE_ADD                  ((unsigned char *)(&kinetis.RNGB)) // Random Number Generator B
    #endif
    #if defined KINETIS_K70 || (defined KINETIS_K60 && defined KINETIS_K_FPU)
        #define NFC_RAM_0                      ((unsigned char *)(&kinetis.NFC_buf[0])) // {27}
        #define NFC_RAM_1                      ((unsigned char *)(&kinetis.NFC_buf[1]))
        #define NFC_RAM_2                      ((unsigned char *)(&kinetis.NFC_buf[2]))
        #define NFC_RAM_3                      ((unsigned char *)(&kinetis.NFC_buf[3]))
        #define NFC_BLOCK                      ((unsigned char *)(&kinetis.NFC)) // {4} NAND Flash Controller
        #define DDR_BLOCK                      ((unsigned char *)(&kinetis.DDR)) // {28} DDR1/2/LP SDRAM controller
    #endif
    #if defined KINETIS_K70
        #define LCDC_BLOCK                     ((unsigned char *)(&kinetis.LCD)) // {60} LCD controller
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #if SPI_AVAILABLE > 2
            #define DSPI2_BLOCK                ((unsigned char *)(&kinetis.DSPI[2])) // DSPI2
        #endif
        #define SDHC_BLOCK                     ((unsigned char *)(&kinetis.SDHC)) // SDHC
        #define FTM_BLOCK_2                    ((unsigned char *)(&kinetis.FTM[2])) // FlexTimer 2
        #define FTM_BLOCK_3                    ((unsigned char *)(&kinetis.FTM[3])) // FlexTimer 3
        #if defined TPMS_AVAILABLE
            #define FTM_BLOCK_4                ((unsigned char *)(&kinetis.FTM[4])) // TPM1
            #define FTM_BLOCK_5                ((unsigned char *)(&kinetis.FTM[5])) // TPM2
        #endif
        #if ADC_CONTROLLERS > 1
            #define ADC1_BLOCK                 ((unsigned char *)(&kinetis.ADC1)) // ADC1
        #endif
    #endif
    #if ADC_CONTROLLERS > 3
        #define ADC3_BLOCK                     ((unsigned char *)(&kinetis.ADC3)) // ADC3
    #endif
    #if defined DEVICE_WITH_SLCD
        #define SLCD_BASE_ADD                  ((unsigned char *)(&kinetis.SLCD)) // SLCD Controller
    #endif
    #if defined KINETIS_K52 || defined KINETIS_K53 || defined KINETIS_K60 || defined KINETIS_K61 || defined KINETIS_K64 || defined KINETIS_K70
        #define EMAC_BASE_ADD                  ((unsigned char *)(&kinetis.EMAC)) // Ethernet Controller
    #endif
    #if DAC_CONTROLLERS > 0
        #define DAC0_BASE_ADD                  ((unsigned char *)(&kinetis.DAC[0])) // DAC0
    #endif
    #if DAC_CONTROLLERS > 1
        #define DAC1_BASE_ADD                  ((unsigned char *)(&kinetis.DAC[1])) // DAC1
    #endif
    #define GPIO_BLOCK                         ((unsigned char *)(&kinetis.GPIO)) // General Purpose IOs
    #define FGPIO_BLOCK                        GPIO_BLOCK                // fast GPIO alias to GPIO

    #define CORTEX_M4_BLOCK                    ((unsigned char *)(&kinetis.CORTEX_M4))

    #define MCM_BLOCK                          ((unsigned char *)(&kinetis.MCM)) // {29} Miscellaneous Control Module
    #if defined CAU_V1_AVAILABLE || defined CAU_V2_AVAILABLE
        #define MMCAU_BLOCK                    ((unsigned char *)(&kinetis.MMCAU)) // {45} Memory-Mapped Cryptographic Accelerator Unit
    #endif
#else
    #if defined KINETIS_KL                                               // {48}
        #if !defined DEVICE_WITHOUT_DMA
            #define DMA_BLOCK                  0x40008100                // DMA Controller
        #endif
    #else
        #define eDMA_BLOCK                     0x40008000                // eDMA Controller
        #define eDMA_DESCRIPTORS               0x40009000                // eDMA Descriptor Memory
        #define FLEXBUS_ADD                    0x4000c000                // FlexBus
    #endif
    #if defined MPU_AVAILABLE
        #define MPU_BLOCK                      0x4000d000                // Memory Protection Unit
    #endif
    #if defined KINETIS_K80
        #define SDRAMC_BLOCK                   0x4000f000                // SDRAM Controller
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define FMC_BLOCK                      0x4001f000                // Flash Memory Controller
    #endif
    #define FTFL_BLOCK                         0x40020000                // Flash Memory Module
    #define DMAMUX0_BLOCK                      0x40021000                // DMAMUX0
    #if defined KINETIS_K70 || (defined KINETIS_K60 && defined KINETIS_K_FPU)
        #define DMAMUX1_BLOCK                  0x40022000                // DMAMUX1
    #endif
    #if defined I2S_AVAILABLE
        #define I2S0_BLOCK                     0x4002f000                // I2S0
    #endif
    #if defined KINETIS_KL
        #define SPI0_BLOCK                     0x40076000                // SPI0
        #define SPI1_BLOCK                     0x40077000                // SPI1
    #else
        #if defined MSCAN_CAN_INTERFACE
            #define MSCAN_BASE_ADD             0x40024000                // MSCAN modul
        #else
            #define CAN0_BASE_ADD              0x40024000                // FLEXCAN module 0
        #endif
        #define DSPI0_BLOCK                    0x4002c000                // DSPI0
        #define DSPI1_BLOCK                    0x4002d000                // DSPI1
        #if defined KINETIS_KE
            #define IRQ_BLOCK                  0x40031000                // IRQ controller
        #endif
        #define CRC_BLOCK                      0x40032000                // CRC {8}
    #endif
    #if defined HS_USB_AVAILABLE
        #if defined KINETIS_K60 || defined KINETIS_K61 || defined KINETIS_K70
            #define USBHS_BASE_ADD             0x40034000                // USBHS {25}
        #else
            #define USBHS_BASE_ADD             0x400a1000                // USBHS
        #endif
        #if defined KINETIS_WITH_USBPHY
            #define USBHS_PHY_ADD              0x400a2000                // {77} integrated HS USB2.0 PHY
        #endif
    #endif
    #if defined PWT_AVAILABLE
        #define PWT_BLOCK                      0x40033000                // {88} PWT
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define PDB_BLOCK                      0x40036000                // PDB {31}
    #endif
    #if !defined KINETIS_WITHOUT_PIT
        #define PIT_BLOCK                      0x40037000                // PITs
    #endif
    #define FTM_BLOCK_0                        0x40038000                // FlexTimer 0 (TPM0 in KL/KE)
    #define FTM_BLOCK_1                        0x40039000                // FlexTimer 1 (TPM1 in KL/KE)
    #if defined KINETIS_KL || defined KINETIS_KE
        #define FTM_BLOCK_2                    0x4003a000                // FlexTimer 2 (TPM2 in KL/KE)
    #endif
    #define ADC0_BLOCK                         0x4003b000                // ADC0
    #if ADC_CONTROLLERS > 2
        #define ADC2_BLOCK                     0x4003c000                // ADC2
    #endif
    #if !defined KINETIS_KL02
        #define RTC_BLOCK                      0x4003d000                // RTC
    #endif
    #if !defined KINETIS_KE
        #define LPTMR_BLOCK                    0x40040000                // {51} Low Power Timer
    #endif
    #if !defined KINETIS_KE && !defined KINETIS_KL
        #define AXBS_BLOCK                     0x40004000                // {50} Crossbar Switch
    #endif
    #define TSI_BLOCK                          0x40045000                // Touch Sense Input Module
    #if defined KINETIS_KE
        #define SIM_BLOCK                      0x40048000                // System Integration Module
    #else
        #define SIM_BLOCK                      0x40047000                // System Integration Module
    #endif
    #if defined KINETIS_KE 
        #define PORT_BLOCK                     0x40049000                // Port block
    #else
        #define PORT0_BLOCK                    0x40049000                // Port Control and Interrupts
        #define PORT1_BLOCK                    0x4004a000
        #if PORTS_AVAILABLE > 2
            #define PORT2_BLOCK                0x4004b000
            #define PORT3_BLOCK                0x4004c000
            #define PORT4_BLOCK                0x4004d000
        #endif
        #if PORTS_AVAILABLE > 5
            #define PORT5_BLOCK                0x4004e000                // {1}
        #endif
    #endif
    #if !defined KINETIS_KL || defined KINETIS_KL82
        #define WDOG_BLOCK                     0x40052000                // Watchdog Timer
    #endif
    #if defined CHIP_HAS_FLEXIO
        #define FLEXIO_BLOCK                   0x4005f000                // FlexIO
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define EWM_BLOCK                      0x4005f000                // External Watchdog Monitor
    #endif
    #if defined KINETIS_KE
        #define INTERNAL_CLOCK_BLOCK           0x40064000                // Internal clock source
    #elif defined KINETIS_WITH_SCG
        #define SCG_BLOCK                      0x4007b000                // System Clock Generator
    #else
        #define MCG_BLOCK                      0x40064000                // Multi-purpose Clock Generator
    #endif
    #define OSC0_BLOCK                         0x40065000                // Oscillator 0
    #define I2C0_BLOCK                         0x40066000                // I2C0
    #if I2C_AVAILABLE > 1
        #define I2C1_BLOCK                     0x40067000                // I2C1
    #endif
    #if I2C_AVAILABLE > 2
        #define I2C2_BLOCK                     0x400e6000                // I2C2
    #endif
    #if I2C_AVAILABLE > 3
        #define I2C3_BLOCK                     0x400e7000                // I2C3
    #endif
    #if LPUARTS_AVAILABLE > 0
        #if defined KINETIS_KL
            #define LPUART0_BLOCK              0x40054000                // LPUART0
        #elif defined KINETIS_K80
            #define LPUART0_BLOCK              0x400c4000                // LPUART0
        #else
            #define LPUART0_BLOCK              0x4002a000                // LPUART0
        #endif
    #endif
    #if LPUARTS_AVAILABLE > 1
        #if defined KINETIS_K80
            #define LPUART1_BLOCK              0x400c5000                // LPUART1
        #else
            #define LPUART1_BLOCK              0x40055000                // LPUART1
        #endif
    #endif
    #if LPUARTS_AVAILABLE > 2
        #define LPUART2_BLOCK                 0x400c6000                 // LPUART2
    #endif
    #if LPUARTS_AVAILABLE > 3
        #define LPUART3_BLOCK                 0x400c7000                 // LPUART3
    #endif
    #if LPUARTS_AVAILABLE > 4
        #define LPUART4_BLOCK                 0x400d6000                 // LPUART4
    #endif
    #if UARTS_AVAILABLE > 0 && (LPUARTS_AVAILABLE < 1 || defined LPUARTS_PARALLEL)
        #define UART0_BLOCK                    0x4006a000                // UART0
    #endif
    #if UARTS_AVAILABLE > 1 && (LPUARTS_AVAILABLE < 2 || defined LPUARTS_PARALLEL)
        #define UART1_BLOCK                   0x4006b000                // UART1
    #endif
    #if (UARTS_AVAILABLE > 2 && (LPUARTS_AVAILABLE < 3 || defined LPUARTS_PARALLEL)) || ((UARTS_AVAILABLE == 1 && LPUARTS_AVAILABLE == 2))
        #define UART2_BLOCK                    0x4006c000                // UART2
    #endif
    #if UARTS_AVAILABLE > 3
        #define UART3_BLOCK                    0x4006d000
    #endif
    #if UARTS_AVAILABLE > 4
        #define UART4_BLOCK                    0x400ea000
    #endif
    #if UARTS_AVAILABLE > 5
        #define UART5_BLOCK                    0x400eb000
    #endif
    #define USB_BASE_ADD                       0x40072000                // USB-OTG Controller
    #if defined KINETIS_KE                                               // {85}
        #define ACMP0_BLOCK                    0x40073000                // Analogue comparator 0
        #define ACMP1_BLOCK                    0x40074000                // Analogue comparator 1
    #else
        #define CMP0_BLOCK                     0x40073000                // comparator 0
        #define CMP1_BLOCK                     0x40073008                // comparator 1
        #define CMP2_BLOCK                     0x40073010                // comparator 2
        #define CMP3_BLOCK                     0x40073018                // comparator 3
    #endif
    #if !defined KINETIS_KL
        #define VREF_ADD                       0x40074000                // VREF
    #endif
    #if defined KINETIS_KE
        #define SPI0_BLOCK                     0x40076000                // SPI0
        #define SPI1_BLOCK                     0x40076000                // SPI1
        #if KBIS_AVAILABLE > 0
            #define KBI0_BLOCK                 0x40079000                // Keyboard interrupt 0
        #endif
        #if KBIS_AVAILABLE > 1
            #define KBI1_BLOCK                 0x4007A000                // Keyboard interrupt 1
        #endif
    #endif
    #if defined LLWU_AVAILABLE
        #define LLWU_BLOCK                     0x4007c000                // {62} Low-Leakage Wakeup Unit
    #endif
    #define PMC_BLOCK                          0x4007d000                // Power Management Controller
    #if defined KINETIS_K_FPU || defined KINETIS_KL || defined KINETIS_REVISION_2 || (KINETIS_MAX_SPEED > 100000000) // {43}
        #define SMC_BASE_ADD                   0x4007e000                // System Mode Controller
        #define RCM_BASE_ADD                   0x4007f000                // Reset Control Module
    #elif !defined KINETIS_KE && !defined KINETIS_KEA
        #define MC_BASE_ADD                    0x4007e000                // Mode Control
    #endif
    #if defined RNG_AVAILABLE
        #define RNGB_BASE_ADD                  0x400a0000                // Random Number Generator
        #if defined KINETIS_KW2X
            #define RNGA_BASE_ADD              0x40029000
        #else
            #define RNGA_BASE_ADD              0x400a0000                // {41}
        #endif
    #endif
    #if NUMBER_OF_CAN_INTERFACES > 1
        #define CAN1_BASE_ADD                  0x400a4000                // FLEXCAN module 1
    #endif
    #if !defined KINETIS_KL
        #define DSPI2_BLOCK                    0x400ac000                // DSPI2
    #endif
    #if defined KINETIS_K70 || (defined KINETIS_K60 && defined KINETIS_K_FPU)
        #define NFC_RAM_0                      0x400a8000                // {27}
        #define NFC_RAM_1                      0x400a9000
        #define NFC_RAM_2                      0x400aa000
        #define NFC_RAM_3                      0x400ab000
        #define NFC_BLOCK                      0x400abf00                // {4} NAND Flash Controller
        #define DDR_BLOCK                      0x400ae000                // {28} DDR1/2/LP SDRAM controller
    #endif
    #if defined KINETIS_K70
        #define LCDC_BLOCK                     0x400b6000                // {60} LCD controller
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define SDHC_BLOCK                     0x400b1000                // SDHC
        #define FTM_BLOCK_2                    0x400b8000                // FlexTimer 2
        #define FTM_BLOCK_3                    0x400b9000                // FlexTimer 3
        #if defined TPMS_AVAILABLE
            #define FTM_BLOCK_4                0x400c9000                // TPM1
            #define FTM_BLOCK_5                0x400ca000                // TPM2
        #endif
        #if ADC_CONTROLLERS > 1
            #define ADC1_BLOCK                 0x400bb000                // ADC1
        #endif
    #endif
    #if ADC_CONTROLLERS > 3
        #define ADC3_BLOCK                     0x400bc000                // ADC3
    #endif
    #if defined KINETIS_K30 || defined KINETIS_K40 || defined KINETIS_K51 || defined KINETIS_K53
        #define SLCD_BASE_ADD                  0x400be000                // SLCD Controller
    #elif defined KINETIS_KL46 || defined KINETIS_KL43
        #define SLCD_BASE_ADD                  0x40053000                // SLCD Controller
    #endif
    #if defined KINETIS_K52 || defined KINETIS_K53 || defined KINETIS_K60 || defined KINETIS_K61 || defined KINETIS_K64 || defined KINETIS_K70
        #define EMAC_BASE_ADD                  0x400c0000                // Ethernet Controller
    #endif
    #if (DAC_CONTROLLERS > 0)
        #if defined KINETIS_KL
            #define DAC0_BASE_ADD              0x4003f000                // {52} DAC0
        #else
            #define DAC0_BASE_ADD              0x400cc000                // DAC0
            #if (DAC_CONTROLLERS > 0)
                #define DAC1_BASE_ADD          0x400cd000                // DAC1
            #endif
        #endif
    #endif
    #if defined LTC_AVAILABLE
        #if defined KINETIS_KL
            #define LTC_BLOCK                  0x40051000                // LTC
        #else
            #define LTC_BLOCK                  0x400d1000                // LTC
        #endif
    #endif
    #if defined KINETIS_K80
        #define QSPI_BLOCK                     0x400da000                // QuadSPI
    #endif
    #define OSC1_BLOCK                         0x400e5000                // Oscillator 1
    #define GPIO_BLOCK                         0x400ff000                // General Purpose IOs

    #define CORTEX_M4_BLOCK                    0xe000e000

    #define MCM_BLOCK                          0xe0080000                // {29} Miscellaneous Control Module
    #if defined CAU_V1_AVAILABLE || defined CAU_V2_AVAILABLE
        #define MMCAU_BLOCK                    0xe0081000                // {45} Memory-Mapped Cryptographic Accelerator Unit
    #endif
    #if defined FGPIO_AVAILABLE
        #if defined KINETIS_KV || defined KINETIS_KE || defined KINETIS_KL02 || defined KINETIS_KL03 || defined KINETIS_KL16
            #define FGPIO_BLOCK                0xf8000000                // Fast GPIOs
        #else
            #define FGPIO_BLOCK                0xf80ff000                // Fast GPIOs
        #endif
    #endif
#endif


#if defined KINETIS_KL                                                   // {48}
  #if !defined DEVICE_WITHOUT_DMA
// DMA Controller
//
    #define DMA_SAR0        *(volatile unsigned long *)(DMA_BLOCK + 0x00)// DMA 0 Source Address Register
    #define DMA_DAR0        *(volatile unsigned long *)(DMA_BLOCK + 0x04)// DMA 0 Destination Address Register
    #define DMA_DSR_BCR0    *(volatile unsigned long *)(DMA_BLOCK + 0x08)// DMA 0 Status/Bytes Count Register
      #define DMA_DSR_BCR_BCR_MASK 0x00ffffff                            // number of bytes yet to be transferred
      #define DMA_DSR_BCR_DONE 0x01000000                                // done (write '1' to clear)
      #define DMA_DSR_BCR_BSY  0x02000000                                // busy
      #define DMA_DSR_BCR_REQ  0x04000000                                // request
      #define DMA_DSR_BCR_BED  0x10000000                                // bus error on destination
      #define DMA_DSR_BCR_BES  0x20000000                                // bus error on source
      #define DMA_DSR_BCR_CE   0x40000000                                // configuration error has occurred
    #define DMA_DCR0        *(volatile unsigned long *)(DMA_BLOCK + 0x0c)// DMA 0 Control Register
      #define DMA_DCR_LCH2_0   0x00000000                                // link channel 2 - DMA channel 0
      #define DMA_DCR_LCH2_1   0x00000001                                // link channel 2 - DMA channel 1
      #define DMA_DCR_LCH2_2   0x00000002                                // link channel 2 - DMA channel 2
      #define DMA_DCR_LCH2_3   0x00000003                                // link channel 2 - DMA channel 3
      #define DMA_DCR_LCH1_0   0x00000000                                // link channel 1 - DMA channel 0
      #define DMA_DCR_LCH1_1   0x00000004                                // link channel 1 - DMA channel 1
      #define DMA_DCR_LCH1_2   0x00000008                                // link channel 1 - DMA channel 2
      #define DMA_DCR_LCH1_3   0x0000000c                                // link channel 1 - DMA channel 3
      #define DMA_DCR_LINKCC_OFF                0x00000000               // link channel control - off
      #define DMA_DCR_LINKCC_LCH1_CYCLE_LCH_BCR 0x00000010               // link channel control - perform a link to channel LCH1 after each cycle-steal transfer and a link to LCH2 afetr BCD decrements to zero
      #define DMA_DCR_LINKCC_LCH1_AFTER_CYCLE   0x00000020               // link channel control - perform a link to channel LCH1 after each cycle-steal transfer
      #define DMA_DCR_LINKCC_LCH1_AFTER_BCR     0x00000030               // link channel control - perform a link to channel LCH1 after BCD decrements to zero
      #define DMA_DCR_D_REQ    0x00000080                                // DMA request (ERQ is cleared when BCR is exhausted)
      #define DMA_DCR_DMOD_OFF 0x00000000                                // destination address modulo - disabled
      #define DMA_DCR_DMOD_16  0x00000100                                // destination address modulo - 16 bytes
      #define DMA_DCR_DMOD_32  0x00000200                                // destination address modulo - 32 bytes
      #define DMA_DCR_DMOD_64  0x00000300                                // destination address modulo - 64 bytes
      #define DMA_DCR_DMOD_128 0x00000400                                // destination address modulo - 128 bytes
      #define DMA_DCR_DMOD_256 0x00000500                                // destination address modulo - 256 bytes
      #define DMA_DCR_DMOD_512 0x00000600                                // destination address modulo - 512 bytes
      #define DMA_DCR_DMOD_1K  0x00000700                                // destination address modulo - 1k bytes
      #define DMA_DCR_DMOD_2K  0x00000800                                // destination address modulo - 2k bytes
      #define DMA_DCR_DMOD_4K  0x00000900                                // destination address modulo - 4k bytes
      #define DMA_DCR_DMOD_8K  0x00000a00                                // destination address modulo - 8k bytes
      #define DMA_DCR_DMOD_16K 0x00000b00                                // destination address modulo - 16k bytes
      #define DMA_DCR_DMOD_32K 0x00000c00                                // destination address modulo - 32k bytes
      #define DMA_DCR_DMOD_64K 0x00000d00                                // destination address modulo - 64k bytes
      #define DMA_DCR_DMOD_128K 0x00000e00                               // destination address modulo - 128k bytes
      #define DMA_DCR_DMOD_256K 0x00000f00                               // destination address modulo - 256k bytes
      #define DMA_DCR_SMOD_OFF 0x00000000                                // source address modulo - disabled
      #define DMA_DCR_SMOD_16  0x00001000                                // source address modulo - 16 bytes
      #define DMA_DCR_SMOD_32  0x00002000                                // source address modulo - 32 bytes
      #define DMA_DCR_SMOD_64  0x00003000                                // source address modulo - 64 bytes
      #define DMA_DCR_SMOD_128 0x00004000                                // source address modulo - 128 bytes
      #define DMA_DCR_SMOD_256 0x00005000                                // source address modulo - 256 bytes
      #define DMA_DCR_SMOD_512 0x00006000                                // source address modulo - 512 bytes
      #define DMA_DCR_SMOD_1K  0x00007000                                // source address modulo - 1k bytes
      #define DMA_DCR_SMOD_2K  0x00008000                                // source address modulo - 2k bytes
      #define DMA_DCR_SMOD_4K  0x00009000                                // source address modulo - 4k bytes
      #define DMA_DCR_SMOD_8K  0x0000a000                                // source address modulo - 8k bytes
      #define DMA_DCR_SMOD_16K 0x0000b000                                // source address modulo - 16k bytes
      #define DMA_DCR_SMOD_32K 0x0000c000                                // source address modulo - 32k bytes
      #define DMA_DCR_SMOD_64K 0x0000d000                                // source address modulo - 64k bytes
      #define DMA_DCR_SMOD_128K 0x0000e000                               // source address modulo - 128k bytes
      #define DMA_DCR_SMOD_256K 0x0000f000                               // source address modulo - 256k bytes
      #define DMA_DCR_START    0x00010000                                // start DMA (self-clearing after one module clock and always read '0')
      #define DMA_DCR_DSIZE_8  0x00020000                                // destination size byte
      #define DMA_DCR_DSIZE_16 0x00040000                                // destination size half-word
      #define DMA_DCR_DSIZE_32 0x00000000                                // destination size 32 bit word
      #define DMA_DCR_DINC     0x00080000                                // destination increment
      #define DMA_DCR_SSIZE_8  0x00100000                                // source size byte
      #define DMA_DCR_SSIZE_16 0x00200000                                // source size half-word
      #define DMA_DCR_SSIZE_32 0x00000000                                // source size 32 bit word
      #define DMA_DCR_SINC     0x00400000                                // source increment
      #define DMA_DCR_EADREQ   0x00800000                                // enable asynchronous DMA requests
      #define DMA_DCR_AA       0x10000000                                // auto-align
      #define DMA_DCR_CS       0x20000000                                // cycle steal
      #define DMA_DCR_ERQ      0x40000000                                // enable peripheral request (warning - a collision can occur between the START and D_REQ when the ERQ bit is set)
      #define DMA_DCR_EINT     0x80000000                                // enable interrupt on completion of transfer
    #define DMA_SAR1        *(volatile unsigned long *)(DMA_BLOCK + 0x10)// DMA 1 Source Address Register
    #define DMA_DAR1        *(volatile unsigned long *)(DMA_BLOCK + 0x14)// DMA 1 Destination Address Register
    #define DMA_DSR_BCR1    *(volatile unsigned long *)(DMA_BLOCK + 0x18)// DMA 1 Status/Bytes Count Register
    #define DMA_DCR1        *(volatile unsigned long *)(DMA_BLOCK + 0x1c)// DMA 1 Control Register
    #define DMA_SAR2        *(volatile unsigned long *)(DMA_BLOCK + 0x20)// DMA 2 Source Address Register
    #define DMA_DAR2        *(volatile unsigned long *)(DMA_BLOCK + 0x24)// DMA 2 Destination Address Register
    #define DMA_DSR_BCR2    *(volatile unsigned long *)(DMA_BLOCK + 0x28)// DMA 2 Status/Bytes Count Register
    #define DMA_DCR2        *(volatile unsigned long *)(DMA_BLOCK + 0x2c)// DMA 2 Control Register
    #define DMA_SAR3        *(volatile unsigned long *)(DMA_BLOCK + 0x30)// DMA 3 Source Address Register
    #define DMA_DAR3        *(volatile unsigned long *)(DMA_BLOCK + 0x34)// DMA 3 Destination Address Register
    #define DMA_DSR_BCR3    *(volatile unsigned long *)(DMA_BLOCK + 0x38)// DMA 3 Status/Bytes Count Register
    #define DMA_DCR3        *(volatile unsigned long *)(DMA_BLOCK + 0x3c)// DMA 3 Control Register

    typedef struct stKINETIS_DMA
    {
        volatile unsigned long  DMA_SAR;
        volatile unsigned long  DMA_DAR;
        volatile unsigned long  DMA_DSR_BCR;
        volatile unsigned long  DMA_DCR;
    } KINETIS_DMA;

    #define DMA_REVMEMCPY_NOT_POSSIBLE                                   // KL doesn't support auto-decrementing and so can't perform reverse memcpy() by DMA
  #endif
#else
// Extended DMA Controller
//
#define DMA_CR              *(volatile unsigned long *)(eDMA_BLOCK + 0x000) // DMA Control Register
  #define DMA_CR_EDBG       0x00000002                                   // enable debug
  #define DMA_CR_ERCA       0x00000004                                   // enable round robin channel arbitration
  #define DMA_CR_HOE        0x00000010                                   // halt on error
  #define DMA_CR_HALT       0x00000020                                   // halt DMA operations
  #define DMA_CR_CLM        0x00000040                                   // continuous link mode
  #define DMA_CR_EMLM       0x00000080                                   // enable minor loop mapping
#if defined DEVICE_WITH_TWO_DMA_GROUPS
  #define DMA_CR_GRP0PRI_0  0x00000000                                   // group 0 priority level - 0
  #define DMA_CR_GRP0PRI_1  0x00000100                                   // group 0 priority level - 1
  #define DMA_CR_GRP0PRI_2  0x00000200                                   // group 0 priority level - 2
  #define DMA_CR_GRP0PRI_3  0x00000300                                   // group 0 priority level - 3
  #define DMA_CR_GRP1PRI_0  0x00000000                                   // group 1 priority level - 0
  #define DMA_CR_GRP1PRI_1  0x00000400                                   // group 1 priority level - 1
  #define DMA_CR_GRP1PRI_2  0x00000800                                   // group 1 priority level - 2
  #define DMA_CR_GRP1PRI_3  0x00000c00                                   // group 1 priority level - 3
#endif
  #define DMA_CR_ECX        0x00010000                                   // error cancel transfer (self clearing)
  #define DMA_CR_CX         0x00020000                                   // cancel transfer (self clearing)
#define DMA_ES              *(volatile unsigned long *)(eDMA_BLOCK + 0x004) // DMA Error Request Register
  #define DMA_ES_DBE        0x00000001                                   // bus error on destination write
  #define DMA_ES_SBE        0x00000002                                   // bus error on source read
  #define DMA_ES_SGE        0x00000004                                   // scatter/gather configuration error
  #define DMA_ES_NCE        0x00000008                                   // NBYTES/CITER configuration error
  #define DMA_ES_DOE        0x00000010                                   // destination offset error
  #define DMA_ES_DAE        0x00000020                                   // destination address error
  #define DMA_ES_SOE        0x00000040                                   // source offset error
  #define DMA_ES_SAE        0x00000080                                   // source address error
#if defined KINETIS_K_FPU
  #define DMA_ES_ERRCHN_MASK 0x00001f00                                  // last error channel
  #define DMA_ES_GPE        0x00008000                                   // group priority error
#elif defined KINETIS_KV
  #define DMA_ES_ERRCHN_MASK 0x00000300                                  // last error channel
#else
  #define DMA_ES_ERRCHN_MASK 0x00000f00                                  // last error channel
#endif
  #define DMA_ES_CPE        0x00004000                                   // channel priority error
  #define DMA_ES_ECX        0x00010000                                   // transfer cancelled
  #define DMA_ES_VLD        0x80000000                                   // at least one error bit is set

#define DMA_ERQ             *(unsigned long *)(eDMA_BLOCK + 0x00c)       // DMA Enable Request Register
  #define DMA_ERQ_ERQ0      0x00000001                                   // enable DMA request on channel 0
  #define DMA_ERQ_ERQ1      0x00000002                                   // enable DMA request on channel 1
  #define DMA_ERQ_ERQ2      0x00000004                                   // enable DMA request on channel 2
  #define DMA_ERQ_ERQ3      0x00000008                                   // enable DMA request on channel 3
  #define DMA_ERQ_ERQ4      0x00000010                                   // enable DMA request on channel 4
  #define DMA_ERQ_ERQ5      0x00000020                                   // enable DMA request on channel 5
  #define DMA_ERQ_ERQ6      0x00000040                                   // enable DMA request on channel 6
  #define DMA_ERQ_ERQ7      0x00000080                                   // enable DMA request on channel 7
  #define DMA_ERQ_ERQ8      0x00000100                                   // enable DMA request on channel 8
  #define DMA_ERQ_ERQ9      0x00000200                                   // enable DMA request on channel 9
  #define DMA_ERQ_ERQ10     0x00000400                                   // enable DMA request on channel 10
  #define DMA_ERQ_ERQ11     0x00000800                                   // enable DMA request on channel 11
  #define DMA_ERQ_ERQ12     0x00001000                                   // enable DMA request on channel 12
  #define DMA_ERQ_ERQ13     0x00002000                                   // enable DMA request on channel 13
  #define DMA_ERQ_ERQ14     0x00004000                                   // enable DMA request on channel 14
  #define DMA_ERQ_ERQ15     0x00008000                                   // enable DMA request on channel 15
  #define DMA_ERQ_ERQ16     0x00010000                                   // enable DMA request on channel 16
  #define DMA_ERQ_ERQ17     0x00020000                                   // enable DMA request on channel 17
  #define DMA_ERQ_ERQ18     0x00040000                                   // enable DMA request on channel 18
  #define DMA_ERQ_ERQ19     0x00080000                                   // enable DMA request on channel 19
  #define DMA_ERQ_ERQ20     0x00100000                                   // enable DMA request on channel 20
  #define DMA_ERQ_ERQ21     0x00200000                                   // enable DMA request on channel 21
  #define DMA_ERQ_ERQ22     0x00400000                                   // enable DMA request on channel 22
  #define DMA_ERQ_ERQ23     0x00800000                                   // enable DMA request on channel 23
  #define DMA_ERQ_ERQ24     0x01000000                                   // enable DMA request on channel 24
  #define DMA_ERQ_ERQ25     0x02000000                                   // enable DMA request on channel 25
  #define DMA_ERQ_ERQ26     0x04000000                                   // enable DMA request on channel 26
  #define DMA_ERQ_ERQ27     0x08000000                                   // enable DMA request on channel 27
  #define DMA_ERQ_ERQ28     0x10000000                                   // enable DMA request on channel 28
  #define DMA_ERQ_ERQ29     0x20000000                                   // enable DMA request on channel 29
  #define DMA_ERQ_ERQ30     0x40000000                                   // enable DMA request on channel 30
  #define DMA_ERQ_ERQ31     0x80000000                                   // enable DMA request on channel 31

#define DMA_EEI             *(unsigned long *)(eDMA_BLOCK + 0x014)       // DMA Error Interrupt Register
#define DMA_CEEI            *(volatile unsigned char *)(eDMA_BLOCK + 0x018) // DMA Clear Enable Error Interrupt Register (write-only, always reads zero)
#define DMA_SEEI            *(volatile unsigned char *)(eDMA_BLOCK + 0x019) // DMA Set Enable Error Interrupt Register (write-only, always reads zero)
#define DMA_CERQ            *(volatile unsigned char *)(eDMA_BLOCK + 0x01a) // DMA Clear Enable Request Register (write-only, always reads zero)
#define DMA_SERQ            *(volatile unsigned char *)(eDMA_BLOCK + 0x01b) // DMA Set Enable Request Register (write-only, always reads zero)
#define DMA_CDNE            *(volatile unsigned char *)(eDMA_BLOCK + 0x01c) // DMA Clear DONE Bit Status Register (write-only, always reads zero)
#define DMA_SSRT            *(volatile unsigned char *)(eDMA_BLOCK + 0x01d) // DMA Set START Bit Status Register (write-only, always reads zero)
#define DMA_CERR            *(volatile unsigned char *)(eDMA_BLOCK + 0x01e) // DMA Clear Error Register (write-only, always reads zero)
#define DMA_CINT            *(volatile unsigned char *)(eDMA_BLOCK + 0x01f) // DMA Clear Interrupt Request Register (write-only, always reads zero)

#define DMA_INT             *(volatile unsigned long *)(eDMA_BLOCK + 0x024) // DMA Interrupt Request Register (write '1 to clear)
  #define DMA_INT_INT0      0x00000001                                   // DMA interrupts request on channel 0
  #define DMA_INT_INT1      0x00000002                                   // DMA interrupts request on channel 1
  #define DMA_INT_INT2      0x00000004                                   // DMA interrupts request on channel 2
  #define DMA_INT_INT3      0x00000008                                   // DMA interrupts request on channel 3
  #define DMA_INT_INT4      0x00000010                                   // DMA interrupts request on channel 4
  #define DMA_INT_INT5      0x00000020                                   // DMA interrupts request on channel 5
  #define DMA_INT_INT6      0x00000040                                   // DMA interrupts request on channel 6
  #define DMA_INT_INT7      0x00000080                                   // DMA interrupts request on channel 7
  #define DMA_INT_INT8      0x00000100                                   // DMA interrupts request on channel 8
  #define DMA_INT_INT9      0x00000200                                   // DMA interrupts request on channel 9
  #define DMA_INT_INT10     0x00000400                                   // DMA interrupts request on channel 10
  #define DMA_INT_INT11     0x00000800                                   // DMA interrupts request on channel 11
  #define DMA_INT_INT12     0x00001000                                   // DMA interrupts request on channel 12
  #define DMA_INT_INT13     0x00002000                                   // DMA interrupts request on channel 13
  #define DMA_INT_INT14     0x00004000                                   // DMA interrupts request on channel 14
  #define DMA_INT_INT15     0x00008000                                   // DMA interrupts request on channel 15
  #define DMA_INT_INT16     0x00010000                                   // DMA interrupts request on channel 16
  #define DMA_INT_INT17     0x00020000                                   // DMA interrupts request on channel 17
  #define DMA_INT_INT18     0x00040000                                   // DMA interrupts request on channel 18
  #define DMA_INT_INT19     0x00080000                                   // DMA interrupts request on channel 19
  #define DMA_INT_INT20     0x00100000                                   // DMA interrupts request on channel 20
  #define DMA_INT_INT21     0x00200000                                   // DMA interrupts request on channel 21
  #define DMA_INT_INT22     0x00400000                                   // DMA interrupts request on channel 22
  #define DMA_INT_INT23     0x00800000                                   // DMA interrupts request on channel 23
  #define DMA_INT_INT24     0x01000000                                   // DMA interrupts request on channel 24
  #define DMA_INT_INT25     0x02000000                                   // DMA interrupts request on channel 25
  #define DMA_INT_INT26     0x04000000                                   // DMA interrupts request on channel 26
  #define DMA_INT_INT27     0x08000000                                   // DMA interrupts request on channel 27
  #define DMA_INT_INT28     0x10000000                                   // DMA interrupts request on channel 28
  #define DMA_INT_INT29     0x20000000                                   // DMA interrupts request on channel 29
  #define DMA_INT_INT30     0x40000000                                   // DMA interrupts request on channel 30
  #define DMA_INT_INT31     0x80000000                                   // DMA interrupts request on channel 31

#define DMA_ERR             *(volatile unsigned long *)(eDMA_BLOCK + 0x02c) // DMA Error Register (write '1' to clear)
  #define DMA_ERR_ERR0      0x00000001                                   // DMA channel 0 encoutered an error
  #define DMA_ERR_ERR1      0x00000002                                   // DMA channel 1 encoutered an error
  #define DMA_ERR_ERR2      0x00000004                                   // DMA channel 2 encoutered an error
  #define DMA_ERR_ERR3      0x00000008                                   // DMA channel 3 encoutered an error
  #define DMA_ERR_ERR4      0x00000010                                   // DMA channel 4 encoutered an error
  #define DMA_ERR_ERR5      0x00000020                                   // DMA channel 5 encoutered an error
  #define DMA_ERR_ERR6      0x00000040                                   // DMA channel 6 encoutered an error
  #define DMA_ERR_ERR7      0x00000080                                   // DMA channel 7 encoutered an error
  #define DMA_ERR_ERR8      0x00000100                                   // DMA channel 8 encoutered an error
  #define DMA_ERR_ERR9      0x00000200                                   // DMA channel 9 encoutered an error
  #define DMA_ERR_ERR10     0x00000400                                   // DMA channel 10 encoutered an error
  #define DMA_ERR_ERR11     0x00000800                                   // DMA channel 11 encoutered an error
  #define DMA_ERR_ERR12     0x00001000                                   // DMA channel 12 encoutered an error
  #define DMA_ERR_ERR13     0x00002000                                   // DMA channel 13 encoutered an error
  #define DMA_ERR_ERR14     0x00004000                                   // DMA channel 14 encoutered an error
  #define DMA_ERR_ERR15     0x00008000                                   // DMA channel 15 encoutered an error
  #define DMA_ERR_ERR16     0x00010000                                   // DMA channel 0 encoutered an error
  #define DMA_ERR_ERR17     0x00020000                                   // DMA channel 1 encoutered an error
  #define DMA_ERR_ERR18     0x00040000                                   // DMA channel 2 encoutered an error
  #define DMA_ERR_ERR19     0x00080000                                   // DMA channel 3 encoutered an error
  #define DMA_ERR_ERR20     0x00100000                                   // DMA channel 4 encoutered an error
  #define DMA_ERR_ERR21     0x00200000                                   // DMA channel 5 encoutered an error
  #define DMA_ERR_ERR22     0x00400000                                   // DMA channel 6 encoutered an error
  #define DMA_ERR_ERR23     0x00800000                                   // DMA channel 7 encoutered an error
  #define DMA_ERR_ERR24     0x01000000                                   // DMA channel 8 encoutered an error
  #define DMA_ERR_ERR25     0x02000000                                   // DMA channel 9 encoutered an error
  #define DMA_ERR_ERR26     0x04000000                                   // DMA channel 10 encoutered an error
  #define DMA_ERR_ERR27     0x08000000                                   // DMA channel 11 encoutered an error
  #define DMA_ERR_ERR28     0x10000000                                   // DMA channel 12 encoutered an error
  #define DMA_ERR_ERR29     0x20000000                                   // DMA channel 13 encoutered an error
  #define DMA_ERR_ERR30     0x40000000                                   // DMA channel 14 encoutered an error
  #define DMA_ERR_ERR31     0x80000000                                   // DMA channel 15 encoutered an error

#define DMA_HRS             *(unsigned long *)(eDMA_BLOCK + 0x034)       // DMA Hardware Request Status Register

#define DMA_DCHPRI3         *(unsigned char *)(eDMA_BLOCK + 0x100)       // DMA Channel 3 Priority Register
  #define DMA_DCHPRI_DPA    0x40                                         // disable preempt ability
  #define DMA_DCHPRI_ECP    0x80                                         // enable channel preemption
#define DMA_DCHPRI2         *(unsigned char *)(eDMA_BLOCK + 0x101)       // DMA Channel 2 Priority Register
#define DMA_DCHPRI1         *(unsigned char *)(eDMA_BLOCK + 0x102)       // DMA Channel 1 Priority Register
#define DMA_DCHPRI0_ADD     (unsigned char *)(eDMA_BLOCK + 0x103)
#define DMA_DCHPRI0         *(unsigned char *)(eDMA_BLOCK + 0x103)       // DMA Channel 0 Priority Register
#define DMA_DCHPRI7         *(unsigned char *)(eDMA_BLOCK + 0x104)       // DMA Channel 7 Priority Register
#define DMA_DCHPRI6         *(unsigned char *)(eDMA_BLOCK + 0x105)       // DMA Channel 6 Priority Register
#define DMA_DCHPRI5         *(unsigned char *)(eDMA_BLOCK + 0x106)       // DMA Channel 5 Priority Register
#define DMA_DCHPRI4         *(unsigned char *)(eDMA_BLOCK + 0x107)       // DMA Channel 4 Priority Register
#define DMA_DCHPRI11        *(unsigned char *)(eDMA_BLOCK + 0x108)       // DMA Channel 11 Priority Register
#define DMA_DCHPRI10        *(unsigned char *)(eDMA_BLOCK + 0x109)       // DMA Channel 10 Priority Register
#define DMA_DCHPRI9         *(unsigned char *)(eDMA_BLOCK + 0x10a)       // DMA Channel 9 Priority Register
#define DMA_DCHPRI8         *(unsigned char *)(eDMA_BLOCK + 0x10b)       // DMA Channel 8 Priority Register
#define DMA_DCHPRI15        *(unsigned char *)(eDMA_BLOCK + 0x10c)       // DMA Channel 15 Priority Register
#define DMA_DCHPRI14        *(unsigned char *)(eDMA_BLOCK + 0x10d)       // DMA Channel 14 Priority Register
#define DMA_DCHPRI13        *(unsigned char *)(eDMA_BLOCK + 0x10e)       // DMA Channel 13 Priority Register
#define DMA_DCHPRI12        *(unsigned char *)(eDMA_BLOCK + 0x10f)       // DMA Channel 12 Priority Register

#if defined DEVICE_WITH_TWO_DMA_GROUPS
    #define DMA_DCHPRI19    *(unsigned char *)(eDMA_BLOCK + 0x110)       // DMA Channel 19 Priority Register
    #define DMA_DCHPRI18    *(unsigned char *)(eDMA_BLOCK + 0x111)       // DMA Channel 18 Priority Register
    #define DMA_DCHPRI17    *(unsigned char *)(eDMA_BLOCK + 0x112)       // DMA Channel 17 Priority Register
    #define DMA_DCHPRI16    *(unsigned char *)(eDMA_BLOCK + 0x113)       // DMA Channel 16 Priority Register
    #define DMA_DCHPRI23    *(unsigned char *)(eDMA_BLOCK + 0x114)       // DMA Channel 23 Priority Register
    #define DMA_DCHPRI22    *(unsigned char *)(eDMA_BLOCK + 0x115)       // DMA Channel 22 Priority Register
    #define DMA_DCHPRI21    *(unsigned char *)(eDMA_BLOCK + 0x116)       // DMA Channel 21 Priority Register
    #define DMA_DCHPRI20    *(unsigned char *)(eDMA_BLOCK + 0x117)       // DMA Channel 20 Priority Register
    #define DMA_DCHPRI27    *(unsigned char *)(eDMA_BLOCK + 0x118)       // DMA Channel 27 Priority Register
    #define DMA_DCHPRI26    *(unsigned char *)(eDMA_BLOCK + 0x119)       // DMA Channel 26 Priority Register
    #define DMA_DCHPRI25    *(unsigned char *)(eDMA_BLOCK + 0x11a)       // DMA Channel 25 Priority Register
    #define DMA_DCHPRI24    *(unsigned char *)(eDMA_BLOCK + 0x11b)       // DMA Channel 24 Priority Register
    #define DMA_DCHPRI31    *(unsigned char *)(eDMA_BLOCK + 0x11c)       // DMA Channel 31 Priority Register
    #define DMA_DCHPRI30    *(unsigned char *)(eDMA_BLOCK + 0x11d)       // DMA Channel 30 Priority Register
    #define DMA_DCHPRI29    *(unsigned char *)(eDMA_BLOCK + 0x11e)       // DMA Channel 29 Priority Register
    #define DMA_DCHPRI28    *(unsigned char *)(eDMA_BLOCK + 0x11f)       // DMA Channel 28 Priority Register
#endif

// eDMA Descriptor Memory
//
#define DMA_TCD0_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x000) // DMA TCD0 Source Address
#define DMA_TCD0_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x004)  // DMA TCD0 Signed Source Address Offset
#define DMA_TCD0_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x006)// DMA TCD0 Transfer Attributes
  #define DMA_TCD_ATTR_DSIZE_8   0x0000
  #define DMA_TCD_ATTR_DSIZE_16  0x0001
  #define DMA_TCD_ATTR_DSIZE_32  0x0002
  #define DMA_TCD_ATTR_DMOD_MASK 0x00f8
  #define DMA_TCD_ATTR_SSIZE_8   0x0000
  #define DMA_TCD_ATTR_SSIZE_16  0x0100
  #define DMA_TCD_ATTR_SSIZE_32  0x0200
  #define DMA_TCD_ATTR_SMOD_MASK 0xf800
#define DMA_TCD0_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x008) // DMA TCD0 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD0_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x008) // DMA TCD0 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD0_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x008) // DMA TCD0 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD0_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x00c) // DMA TCD0 Last Source Address Adjustment
#define DMA_TCD0_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x010) // DMA TCD0 Destination Address
#define DMA_TCD0_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x014)  // DMA TCD0 Signed Destination Address Offset
#define DMA_TCD0_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x016) // DMA TCD0 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD0_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x016) // DMA TCD0 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD0_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x018) // DMA TCD0 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD0_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x01c) // DMA TCD0 Control and Status
  #define DMA_TCD_CSR_START              0x0001                          // start by software request (self-clearing)
  #define DMA_TCD_CSR_INTMAJOR           0x0002                          // enable interrupt when major iteration count completes
  #define DMA_TCD_CSR_INTHALF            0x0004                          // enable interrupt on half-point
  #define DMA_TCD_CSR_DREQ               0x0008                          // clear ERQ bit when major iteration count reaches zero
  #define DMA_TCD_CSR_ESQ                0x0010                          // enable scatter-gather processing
  #define DMA_TCD_CSR_MAJORELINK         0x0020                          // enable channel-to-channel linking on major loop complete
  #define DMA_TCD_CSR_ACTIVE             0x0040                          // channel active
  #define DMA_TCD_CSR_DONE               0x0080                          // channel done (major loop completed)
  #define DMA_TCD_CSR_MAJORLINKCH_MASK   0x0f00                          // major link channel number - zero is disabled
  #define DMA_TCD_CSR_BWC_NO_STALLS      0x0000                          // no eDMA engine stalls
  #define DMA_TCD_CSR_BWC_4_CYCLE_STALLS 0x8000                          // eDMA engine stalls for 4 cycles after each r/w
  #define DMA_TCD_CSR_BWC_8_CYCLE_STALLS 0xc000                          // eDMA engine stalls for 8 cycles after each r/w
#define DMA_TCD0_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x01e) // DMA TCD0 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD0_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x01e) // DMA TCD0 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  #define DMA_TCD_BITER_ELINK_EN 0x8000                                  // enable channel-to-channel linking on minor loop complete
#define DMA_TCD1_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x020) // DMA TCD1 Source Address
#define DMA_TCD1_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x024)  // DMA TCD1 Signed Source Address Offset
#define DMA_TCD1_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x026)// DMA TCD1 Transfer Attributes
#define DMA_TCD1_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x028) // DMA TCD1 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD1_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x028) // DMA TCD1 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD1_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x028) // DMA TCD1 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD1_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x02c) // DMA TCD1 Last Source Address Adjustment
#define DMA_TCD1_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x030) // DMA TCD1 Destination Address
#define DMA_TCD1_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x034)  // DMA TCD1 Signed Destination Address Offset
#define DMA_TCD1_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x036) // DMA TCD1 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD1_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x036) // DMA TCD1 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD1_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x038) // DMA TCD1 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD1_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x03c) // DMA TCD1 Control and Status
#define DMA_TCD1_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x03e) // DMA TCD1 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD1_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x03e) // DMA TCD1 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD2_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x040) // DMA TCD2 Source Address
#define DMA_TCD2_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x044)  // DMA TCD2 Signed Source Address Offset
#define DMA_TCD2_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x046)// DMA TCD2 Transfer Attributes
#define DMA_TCD2_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x048) // DMA TCD2 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD2_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x048) // DMA TCD2 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD2_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x048) // DMA TCD2 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD2_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x04c) // DMA TCD2 Last Source Address Adjustment
#define DMA_TCD2_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x050) // DMA TCD2 Destination Address
#define DMA_TCD2_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x054)  // DMA TCD2 Signed Destination Address Offset
#define DMA_TCD2_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x056) // DMA TCD2 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD2_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x056) // DMA TCD2 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD2_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x058) // DMA TCD2 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD2_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x05c) // DMA TCD2 Control and Status
#define DMA_TCD2_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x05e) // DMA TCD2 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD2_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x05e) // DMA TCD2 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD3_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x060) // DMA TCD3 Source Address
#define DMA_TCD3_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x064)  // DMA TCD3 Signed Source Address Offset
#define DMA_TCD3_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x066)// DMA TCD3 Transfer Attributes
#define DMA_TCD3_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x068) // DMA TCD3 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD3_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x068) // DMA TCD3 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD3_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x068) // DMA TCD3 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD3_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x06c) // DMA TCD3 Last Source Address Adjustment
#define DMA_TCD3_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x070) // DMA TCD3 Destination Address
#define DMA_TCD3_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x074)  // DMA TCD3 Signed Destination Address Offset
#define DMA_TCD3_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x076) // DMA TCD3 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD3_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x076) // DMA TCD3 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD3_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x078) // DMA TCD3 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD3_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x07c) // DMA TCD3 Control and Status
#define DMA_TCD3_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x07e) // DMA TCD3 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD3_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x07e) // DMA TCD3 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#if defined irq_DMA4_ID
    #define DMA_TCD4_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x080) // DMA TCD4 Source Address
    #define DMA_TCD4_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x084)  // DMA TCD4 Signed Source Address Offset
    #define DMA_TCD4_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x086)// DMA TCD4 Transfer Attributes
    #define DMA_TCD4_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x088) // DMA TCD4 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD4_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x088) // DMA TCD4 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD4_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x088) // DMA TCD4 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD4_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x08c) // DMA TCD4 Last Source Address Adjustment
    #define DMA_TCD4_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x090) // DMA TCD4 Destination Address
    #define DMA_TCD4_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x094)  // DMA TCD4 Signed Destination Address Offset
    #define DMA_TCD4_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x096) // DMA TCD4 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD4_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x096) // DMA TCD4 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD4_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x098) // DMA TCD4 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD4_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x09c) // DMA TCD4 Control and Status
    #define DMA_TCD4_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x09e) // DMA TCD4 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD4_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x09e) // DMA TCD4 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD5_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0a0) // DMA TCD5 Source Address
    #define DMA_TCD5_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0a4)  // DMA TCD5 Signed Source Address Offset
    #define DMA_TCD5_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x0a6)// DMA TCD5 Transfer Attributes
    #define DMA_TCD5_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0a8) // DMA TCD5 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD5_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0a8) // DMA TCD5 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD5_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0a8) // DMA TCD5 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD5_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0ac) // DMA TCD5 Last Source Address Adjustment
    #define DMA_TCD5_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0b0) // DMA TCD5 Destination Address
    #define DMA_TCD5_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0b4)  // DMA TCD5 Signed Destination Address Offset
    #define DMA_TCD5_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0b6) // DMA TCD5 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD5_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0b6) // DMA TCD5 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD5_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0b8) // DMA TCD5 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD5_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x0bc) // DMA TCD5 Control and Status
    #define DMA_TCD5_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x0be) // DMA TCD5 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD5_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x0be) // DMA TCD5 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD6_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0c0) // DMA TCD6 Source Address
    #define DMA_TCD6_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0c4)  // DMA TCD6 Signed Source Address Offset
    #define DMA_TCD6_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x0c6)// DMA TCD6 Transfer Attributes
    #define DMA_TCD6_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0c8) // DMA TCD6 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD6_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0c8) // DMA TCD6 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD6_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0c8) // DMA TCD6 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD6_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0cc) // DMA TCD6 Last Source Address Adjustment
    #define DMA_TCD6_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0d0) // DMA TCD6 Destination Address
    #define DMA_TCD6_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0d4)  // DMA TCD6 Signed Destination Address Offset
    #define DMA_TCD6_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0d6) // DMA TCD6 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD6_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0d6) // DMA TCD6 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD6_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0d8) // DMA TCD6 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD6_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x0dc) // DMA TCD6 Control and Status
    #define DMA_TCD6_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x0de) // DMA TCD6 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD6_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x0de) // DMA TCD6 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD7_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0e0) // DMA TCD7 Source Address
    #define DMA_TCD7_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0e4)  // DMA TCD7 Signed Source Address Offset
    #define DMA_TCD7_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x0e6)// DMA TCD7 Transfer Attributes
    #define DMA_TCD7_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0e8) // DMA TCD7 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD7_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0e8) // DMA TCD7 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD7_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0e8) // DMA TCD7 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD7_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0ec) // DMA TCD7 Last Source Address Adjustment
    #define DMA_TCD7_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0f0) // DMA TCD7 Destination Address
    #define DMA_TCD7_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0f4)  // DMA TCD7 Signed Destination Address Offset
    #define DMA_TCD7_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0f6) // DMA TCD7 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD7_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0f6) // DMA TCD7 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD7_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0f8) // DMA TCD7 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD7_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x0fc) // DMA TCD7 Control and Status
    #define DMA_TCD7_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x0fe) // DMA TCD7 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD7_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x0fe) // DMA TCD7 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD8_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x100) // DMA TCD8 Source Address
    #define DMA_TCD8_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x104)  // DMA TCD8 Signed Source Address Offset
    #define DMA_TCD8_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x106)// DMA TCD8 Transfer Attributes
    #define DMA_TCD8_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x108) // DMA TCD8 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD8_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x108) // DMA TCD8 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD8_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x108) // DMA TCD8 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD8_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x10c) // DMA TCD8 Last Source Address Adjustment
    #define DMA_TCD8_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x110) // DMA TCD8 Destination Address
    #define DMA_TCD8_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x114)  // DMA TCD8 Signed Destination Address Offset
    #define DMA_TCD8_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x116) // DMA TCD8 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD8_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x116) // DMA TCD8 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD8_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x118) // DMA TCD8 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD8_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x11c) // DMA TCD8 Control and Status
    #define DMA_TCD8_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x11e) // DMA TCD8 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD8_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x11e) // DMA TCD8 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD9_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x120) // DMA TCD9 Source Address
    #define DMA_TCD9_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x124)  // DMA TCD9 Signed Source Address Offset
    #define DMA_TCD9_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x126)// DMA TCD9 Transfer Attributes
    #define DMA_TCD9_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x128) // DMA TCD9 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD9_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x128) // DMA TCD9 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD9_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x128) // DMA TCD9 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD9_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x12c) // DMA TCD9 Last Source Address Adjustment
    #define DMA_TCD9_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x130) // DMA TCD9 Destination Address
    #define DMA_TCD9_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x134)  // DMA TCD9 Signed Destination Address Offset
    #define DMA_TCD9_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x136) // DMA TCD9 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD9_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x136) // DMA TCD9 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD9_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x138) // DMA TCD9 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD9_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x13c) // DMA TCD9 Control and Status
    #define DMA_TCD9_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x13e) // DMA TCD9 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD9_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x13e) // DMA TCD9 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD10_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x140) // DMA TCD10 Source Address
    #define DMA_TCD10_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x144)  // DMA TCD10 Signed Source Address Offset
    #define DMA_TCD10_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x146)// DMA TCD10 Transfer Attributes
    #define DMA_TCD10_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x148) // DMA TCD10 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD10_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x148) // DMA TCD10 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD10_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x148) // DMA TCD10 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD10_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x14c) // DMA TCD10 Last Source Address Adjustment
    #define DMA_TCD10_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x150) // DMA TCD10 Destination Address
    #define DMA_TCD10_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x154)  // DMA TCD10 Signed Destination Address Offset
    #define DMA_TCD10_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x156) // DMA TCD10 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD10_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x156) // DMA TCD10 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD10_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x158) // DMA TCD10 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD10_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x15c) // DMA TCD10 Control and Status
    #define DMA_TCD10_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x15e) // DMA TCD10 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD10_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x15e) // DMA TCD10 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD11_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x160) // DMA TCD11 Source Address
    #define DMA_TCD11_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x164)  // DMA TCD11 Signed Source Address Offset
    #define DMA_TCD11_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x166)// DMA TCD11 Transfer Attributes
    #define DMA_TCD11_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x168) // DMA TCD11 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD11_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x168) // DMA TCD11 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD11_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x168) // DMA TCD11 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD11_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x16c) // DMA TCD11 Last Source Address Adjustment
    #define DMA_TCD11_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x170) // DMA TCD11 Destination Address
    #define DMA_TCD11_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x174)  // DMA TCD11 Signed Destination Address Offset
    #define DMA_TCD11_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x176) // DMA TCD11 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD11_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x176) // DMA TCD11 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD11_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x178) // DMA TCD11 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD11_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x17c) // DMA TCD11 Control and Status
    #define DMA_TCD11_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x17e) // DMA TCD11 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD11_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x17e) // DMA TCD11 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD12_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x180) // DMA TCD12 Source Address
    #define DMA_TCD12_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x184)  // DMA TCD12 Signed Source Address Offset
    #define DMA_TCD12_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x186)// DMA TCD12 Transfer Attributes
    #define DMA_TCD12_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x188) // DMA TCD12 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD12_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x188) // DMA TCD12 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD12_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x188) // DMA TCD12 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD12_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x18c) // DMA TCD12 Last Source Address Adjustment
    #define DMA_TCD12_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x190) // DMA TCD12 Destination Address
    #define DMA_TCD12_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x194)  // DMA TCD12 Signed Destination Address Offset
    #define DMA_TCD12_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x196) // DMA TCD12 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD12_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x196) // DMA TCD12 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD12_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x198) // DMA TCD12 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD12_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x19c) // DMA TCD12 Control and Status
    #define DMA_TCD12_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x19e) // DMA TCD12 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD12_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x19e) // DMA TCD12 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD13_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1a0) // DMA TCD13 Source Address
    #define DMA_TCD13_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1a4)  // DMA TCD13 Signed Source Address Offset
    #define DMA_TCD13_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x1a6)// DMA TCD13 Transfer Attributes
    #define DMA_TCD13_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1a8) // DMA TCD13 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD13_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1a8) // DMA TCD13 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD13_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1a8) // DMA TCD13 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD13_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1ac) // DMA TCD13 Last Source Address Adjustment
    #define DMA_TCD13_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1b0) // DMA TCD13 Destination Address
    #define DMA_TCD13_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1b4)  // DMA TCD13 Signed Destination Address Offset
    #define DMA_TCD13_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1b6) // DMA TCD13 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD13_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1b6) // DMA TCD13 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD13_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1b8) // DMA TCD13 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD13_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x1bc) // DMA TCD13 Control and Status
    #define DMA_TCD13_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x1be) // DMA TCD13 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD13_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x1be) // DMA TCD13 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD14_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1c0) // DMA TCD14 Source Address
    #define DMA_TCD14_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1c4)  // DMA TCD14 Signed Source Address Offset
    #define DMA_TCD14_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x1c6)// DMA TCD14 Transfer Attributes
    #define DMA_TCD14_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1c8) // DMA TCD14 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD14_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1c8) // DMA TCD14 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD14_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1c8) // DMA TCD14 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD14_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1cc) // DMA TCD14 Last Source Address Adjustment
    #define DMA_TCD14_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1d0) // DMA TCD14 Destination Address
    #define DMA_TCD14_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1d4)  // DMA TCD14 Signed Destination Address Offset
    #define DMA_TCD14_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1d6) // DMA TCD14 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD14_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1d6) // DMA TCD14 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD14_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1d8) // DMA TCD14 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD14_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x1dc) // DMA TCD14 Control and Status
    #define DMA_TCD14_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x1de) // DMA TCD14 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD14_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x1de) // DMA TCD14 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD15_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1e0) // DMA TCD15 Source Address
    #define DMA_TCD15_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1e4)  // DMA TCD15 Signed Source Address Offset
    #define DMA_TCD15_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x1e6)// DMA TCD15 Transfer Attributes
    #define DMA_TCD15_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1e8) // DMA TCD15 Minor Byte Count (Minor Loop Disabled)
    #define DMA_TCD15_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1e8) // DMA TCD15 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
    #define DMA_TCD15_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1e8) // DMA TCD15 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
    #define DMA_TCD15_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1ec) // DMA TCD15 Last Source Address Adjustment
    #define DMA_TCD15_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1f0) // DMA TCD15 Destination Address
    #define DMA_TCD15_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1f4)  // DMA TCD15 Signed Destination Address Offset
    #define DMA_TCD15_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1f6) // DMA TCD15 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD15_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1f6) // DMA TCD15 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #define DMA_TCD15_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1f8) // DMA TCD15 Last Destination Address Adjustment/Scatter Gather Address
    #define DMA_TCD15_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x1fc) // DMA TCD15 Control and Status
    #define DMA_TCD15_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x1fe) // DMA TCD15 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
    #define DMA_TCD15_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x1fe) // DMA TCD15 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
    #if defined DEVICE_WITH_TWO_DMA_GROUPS
        #define DMA_TCD16_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x200) // DMA TCD16 Source Address
        #define DMA_TCD16_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x204)  // DMA TCD16 Signed Source Address Offset
        #define DMA_TCD16_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x206)// DMA TCD16 Transfer Attributes
        #define DMA_TCD16_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x208) // DMA TCD16 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD16_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x208) // DMA TCD16 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD16_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x208) // DMA TCD16 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD16_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x20c) // DMA TCD16 Last Source Address Adjustment
        #define DMA_TCD16_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x210) // DMA TCD16 Destination Address
        #define DMA_TCD16_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x214)  // DMA TCD16 Signed Destination Address Offset
        #define DMA_TCD16_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x216) // DMA TCD16 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD16_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x216) // DMA TCD16 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD16_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x218) // DMA TCD16 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD16_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x21c) // DMA TCD16 Control and Status
        #define DMA_TCD16_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x21e) // DMA TCD16 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD16_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x21e) // DMA TCD16 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD17_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x220) // DMA TCD17 Source Address
        #define DMA_TCD17_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x224)  // DMA TCD17 Signed Source Address Offset
        #define DMA_TCD17_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x226)// DMA TCD17 Transfer Attributes
        #define DMA_TCD17_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x228) // DMA TCD17 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD17_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x228) // DMA TCD17 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD17_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x228) // DMA TCD17 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD17_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x22c) // DMA TCD17 Last Source Address Adjustment
        #define DMA_TCD17_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x230) // DMA TCD17 Destination Address
        #define DMA_TCD17_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x234)  // DMA TCD17 Signed Destination Address Offset
        #define DMA_TCD17_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x236) // DMA TCD17 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD17_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x236) // DMA TCD17 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD17_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x238) // DMA TCD17 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD17_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x23c) // DMA TCD17 Control and Status
        #define DMA_TCD17_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x23e) // DMA TCD17 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD17_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x23e) // DMA TCD17 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD18_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x240) // DMA TCD18 Source Address
        #define DMA_TCD18_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x244)  // DMA TCD18 Signed Source Address Offset
        #define DMA_TCD18_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x246)// DMA TCD18 Transfer Attributes
        #define DMA_TCD18_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x248) // DMA TCD18 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD18_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x248) // DMA TCD18 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD18_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x248) // DMA TCD18 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD18_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x24c) // DMA TCD18 Last Source Address Adjustment
        #define DMA_TCD18_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x250) // DMA TCD18 Destination Address
        #define DMA_TCD18_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x254)  // DMA TCD18 Signed Destination Address Offset
        #define DMA_TCD18_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x256) // DMA TCD18 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD18_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x256) // DMA TCD18 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD18_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x258) // DMA TCD18 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD18_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x25c) // DMA TCD18 Control and Status
        #define DMA_TCD18_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x25e) // DMA TCD18 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD18_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x25e) // DMA TCD18 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD19_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x260) // DMA TCD19 Source Address
        #define DMA_TCD19_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x264)  // DMA TCD19 Signed Source Address Offset
        #define DMA_TCD19_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x266)// DMA TCD19 Transfer Attributes
        #define DMA_TCD19_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x268) // DMA TCD19 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD19_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x268) // DMA TCD19 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD19_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x268) // DMA TCD19 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD19_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x26c) // DMA TCD19 Last Source Address Adjustment
        #define DMA_TCD19_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x270) // DMA TCD19 Destination Address
        #define DMA_TCD19_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x274)  // DMA TCD19 Signed Destination Address Offset
        #define DMA_TCD19_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x276) // DMA TCD19 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD19_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x276) // DMA TCD19 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD19_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x278) // DMA TCD19 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD19_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x27c) // DMA TCD19 Control and Status
        #define DMA_TCD19_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x27e) // DMA TCD19 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD19_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x27e) // DMA TCD19 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD20_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x280) // DMA TCD20 Source Address
        #define DMA_TCD20_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x284)  // DMA TCD20 Signed Source Address Offset
        #define DMA_TCD20_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x286)// DMA TCD20 Transfer Attributes
        #define DMA_TCD20_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x288) // DMA TCD20 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD20_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x288) // DMA TCD20 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD20_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x288) // DMA TCD20 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD20_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x28c) // DMA TCD20 Last Source Address Adjustment
        #define DMA_TCD20_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x290) // DMA TCD20 Destination Address
        #define DMA_TCD20_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x294)  // DMA TCD20 Signed Destination Address Offset
        #define DMA_TCD20_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x296) // DMA TCD20 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD20_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x296) // DMA TCD20 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD20_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x298) // DMA TCD20 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD20_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x29c) // DMA TCD20 Control and Status
        #define DMA_TCD20_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x29e) // DMA TCD20 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD20_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x29e) // DMA TCD20 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD21_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2a0) // DMA TCD21 Source Address
        #define DMA_TCD21_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2a4)  // DMA TCD21 Signed Source Address Offset
        #define DMA_TCD21_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x2a6)// DMA TCD21 Transfer Attributes
        #define DMA_TCD21_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2a8) // DMA TCD21 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD21_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2a8) // DMA TCD21 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD21_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2a8) // DMA TCD21 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD21_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2ac) // DMA TCD21 Last Source Address Adjustment
        #define DMA_TCD21_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2b0) // DMA TCD21 Destination Address
        #define DMA_TCD21_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2b4)  // DMA TCD21 Signed Destination Address Offset
        #define DMA_TCD21_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2b6) // DMA TCD21 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD21_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2b6) // DMA TCD21 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD21_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2b8) // DMA TCD21 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD21_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x2bc) // DMA TCD21 Control and Status
        #define DMA_TCD21_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x2be) // DMA TCD21 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD21_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x2be) // DMA TCD21 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled
        #define DMA_TCD22_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2c0) // DMA TCD22 Source Address
        #define DMA_TCD22_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2c4)  // DMA TCD22 Signed Source Address Offset
        #define DMA_TCD22_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x2c6)// DMA TCD22 Transfer Attributes
        #define DMA_TCD22_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2c8) // DMA TCD22 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD22_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2c8) // DMA TCD22 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD22_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2c8) // DMA TCD22 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD22_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2cc) // DMA TCD22 Last Source Address Adjustment
        #define DMA_TCD22_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2d0) // DMA TCD22 Destination Address
        #define DMA_TCD22_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2d4)  // DMA TCD22 Signed Destination Address Offset
        #define DMA_TCD22_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2d6) // DMA TCD22 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD22_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2d6) // DMA TCD22 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD22_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2d8) // DMA TCD22 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD22_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x2dc) // DMA TCD22 Control and Status
        #define DMA_TCD22_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x2de) // DMA TCD22 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD22_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x2de) // DMA TCD22 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD23_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2e0) // DMA TCD23 Source Address
        #define DMA_TCD23_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2e4)  // DMA TCD23 Signed Source Address Offset
        #define DMA_TCD23_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x2e6)// DMA TCD23 Transfer Attributes
        #define DMA_TCD23_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2e8) // DMA TCD23 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD23_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2e8) // DMA TCD23 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD23_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2e8) // DMA TCD23 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD23_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2ec) // DMA TCD23 Last Source Address Adjustment
        #define DMA_TCD23_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2f0) // DMA TCD23 Destination Address
        #define DMA_TCD23_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2f4)  // DMA TCD23 Signed Destination Address Offset
        #define DMA_TCD23_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2f6) // DMA TCD23 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD23_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2f6) // DMA TCD23 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD23_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2f8) // DMA TCD23 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD23_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x2fc) // DMA TCD23 Control and Status
        #define DMA_TCD23_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x2fe) // DMA TCD23 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD23_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x2fe) // DMA TCD23 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD24_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x300) // DMA TCD24 Source Address
        #define DMA_TCD24_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x304)  // DMA TCD24 Signed Source Address Offset
        #define DMA_TCD24_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x306)// DMA TCD24 Transfer Attributes
        #define DMA_TCD24_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x308) // DMA TCD24 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD24_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x308) // DMA TCD24 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD24_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x308) // DMA TCD24 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD24_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x30c) // DMA TCD24 Last Source Address Adjustment
        #define DMA_TCD24_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x310) // DMA TCD24 Destination Address
        #define DMA_TCD24_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x314)  // DMA TCD24 Signed Destination Address Offset
        #define DMA_TCD24_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x316) // DMA TCD24 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD24_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x316) // DMA TCD24 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD24_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x318) // DMA TCD24 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD24_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x31c) // DMA TCD24 Control and Status
        #define DMA_TCD24_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x31e) // DMA TCD24 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD24_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x31e) // DMA TCD24 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD25_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x320) // DMA TCD25 Source Address
        #define DMA_TCD25_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x324)  // DMA TCD25 Signed Source Address Offset
        #define DMA_TCD25_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x326)// DMA TCD25 Transfer Attributes
        #define DMA_TCD25_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x328) // DMA TCD25 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD25_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x328) // DMA TCD25 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD25_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x328) // DMA TCD25 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD25_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x32c) // DMA TCD25 Last Source Address Adjustment
        #define DMA_TCD25_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x330) // DMA TCD25 Destination Address
        #define DMA_TCD25_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x334)  // DMA TCD25 Signed Destination Address Offset
        #define DMA_TCD25_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x336) // DMA TCD25 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD25_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x336) // DMA TCD25 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD25_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x338) // DMA TCD25 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD25_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x33c) // DMA TCD25 Control and Status
        #define DMA_TCD25_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x33e) // DMA TCD25 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD25_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x33e) // DMA TCD25 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD26_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x340) // DMA TCD26 Source Address
        #define DMA_TCD26_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x344)  // DMA TCD26 Signed Source Address Offset
        #define DMA_TCD26_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x346)// DMA TCD26 Transfer Attributes
        #define DMA_TCD26_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x348) // DMA TCD26 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD26_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x348) // DMA TCD26 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD26_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x348) // DMA TCD26 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD26_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x34c) // DMA TCD26 Last Source Address Adjustment
        #define DMA_TCD26_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x350) // DMA TCD26 Destination Address
        #define DMA_TCD26_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x354)  // DMA TCD26 Signed Destination Address Offset
        #define DMA_TCD26_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x356) // DMA TCD26 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD26_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x356) // DMA TCD26 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD26_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x358) // DMA TCD26 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD26_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x35c) // DMA TCD26 Control and Status
        #define DMA_TCD26_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x35e) // DMA TCD26 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD26_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x35e) // DMA TCD26 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD27_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x360) // DMA TCD27 Source Address
        #define DMA_TCD27_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x364)  // DMA TCD27 Signed Source Address Offset
        #define DMA_TCD27_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x366)// DMA TCD27 Transfer Attributes
        #define DMA_TCD27_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x368) // DMA TCD27 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD27_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x368) // DMA TCD27 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD27_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x368) // DMA TCD27 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD27_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x36c) // DMA TCD27 Last Source Address Adjustment
        #define DMA_TCD27_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x370) // DMA TCD27 Destination Address
        #define DMA_TCD27_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x374)  // DMA TCD27 Signed Destination Address Offset
        #define DMA_TCD27_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x376) // DMA TCD27 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD27_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x376) // DMA TCD27 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD27_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x378) // DMA TCD27 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD27_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x37c) // DMA TCD27 Control and Status
        #define DMA_TCD27_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x37e) // DMA TCD27 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD27_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x37e) // DMA TCD27 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD28_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x380) // DMA TCD28 Source Address
        #define DMA_TCD28_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x384)  // DMA TCD28 Signed Source Address Offset
        #define DMA_TCD28_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x386)// DMA TCD28 Transfer Attributes
        #define DMA_TCD28_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x388) // DMA TCD28 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD28_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x388) // DMA TCD28 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD28_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x388) // DMA TCD28 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD28_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x38c) // DMA TCD28 Last Source Address Adjustment
        #define DMA_TCD28_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x390) // DMA TCD28 Destination Address
        #define DMA_TCD28_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x394)  // DMA TCD28 Signed Destination Address Offset
        #define DMA_TCD28_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x396) // DMA TCD28 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD28_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x396) // DMA TCD28 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD28_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x398) // DMA TCD28 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD28_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x39c) // DMA TCD28 Control and Status
        #define DMA_TCD28_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x39e) // DMA TCD28 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD28_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x39e) // DMA TCD28 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD29_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3a0) // DMA TCD29 Source Address
        #define DMA_TCD29_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3a4)  // DMA TCD29 Signed Source Address Offset
        #define DMA_TCD29_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x3a6)// DMA TCD29 Transfer Attributes
        #define DMA_TCD29_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3a8) // DMA TCD29 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD29_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3a8) // DMA TCD29 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD29_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3a8) // DMA TCD29 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD29_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3ac) // DMA TCD29 Last Source Address Adjustment
        #define DMA_TCD29_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3b0) // DMA TCD29 Destination Address
        #define DMA_TCD29_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3b4)  // DMA TCD29 Signed Destination Address Offset
        #define DMA_TCD29_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3b6) // DMA TCD29 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD29_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3b6) // DMA TCD29 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD29_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3b8) // DMA TCD29 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD29_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x3bc) // DMA TCD29 Control and Status
        #define DMA_TCD29_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x3be) // DMA TCD29 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD29_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x3be) // DMA TCD29 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD30_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3c0) // DMA TCD30 Source Address
        #define DMA_TCD30_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3c4)  // DMA TCD30 Signed Source Address Offset
        #define DMA_TCD30_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x3c6)// DMA TCD30 Transfer Attributes
        #define DMA_TCD30_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3c8) // DMA TCD30 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD30_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3c8) // DMA TCD30 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD30_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3c8) // DMA TCD30 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD30_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3cc) // DMA TCD30 Last Source Address Adjustment
        #define DMA_TCD30_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3d0) // DMA TCD30 Destination Address
        #define DMA_TCD30_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3d4)  // DMA TCD30 Signed Destination Address Offset
        #define DMA_TCD30_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3d6) // DMA TCD30 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD30_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3d6) // DMA TCD30 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD30_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3d8) // DMA TCD30 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD30_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x3dc) // DMA TCD30 Control and Status
        #define DMA_TCD30_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x3de) // DMA TCD30 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD30_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x3de) // DMA TCD30 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD31_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3e0) // DMA TCD31 Source Address
        #define DMA_TCD31_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3e4)  // DMA TCD31 Signed Source Address Offset
        #define DMA_TCD31_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x3e6)// DMA TCD31 Transfer Attributes
        #define DMA_TCD31_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3e8) // DMA TCD31 Minor Byte Count (Minor Loop Disabled)
        #define DMA_TCD31_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3e8) // DMA TCD31 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
        #define DMA_TCD31_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3e8) // DMA TCD31 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
        #define DMA_TCD31_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3ec) // DMA TCD31 Last Source Address Adjustment
        #define DMA_TCD31_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3f0) // DMA TCD31 Destination Address
        #define DMA_TCD31_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3f4)  // DMA TCD31 Signed Destination Address Offset
        #define DMA_TCD31_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3f6) // DMA TCD31 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD31_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3f6) // DMA TCD31 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
        #define DMA_TCD31_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3f8) // DMA TCD31 Last Destination Address Adjustment/Scatter Gather Address
        #define DMA_TCD31_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x3fc) // DMA TCD31 Control and Status
        #define DMA_TCD31_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x3fe) // DMA TCD31 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
        #define DMA_TCD31_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x3fe) // DMA TCD31 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled
        #define eDMA_DESCRIPTORS_END (unsigned long *)(eDMA_DESCRIPTORS + 0x400)
    #else
        #define eDMA_DESCRIPTORS_END (unsigned long *)(eDMA_DESCRIPTORS + 0x200)
    #endif
#else
    #define eDMA_DESCRIPTORS_END (unsigned long *)(eDMA_DESCRIPTORS + 0x80)
#endif

#define _SET_DMA_CHANNEL_PRIORITY(channel, priority) *(DMA_DCHPRI0_ADD + ((channel/4) * 4) - (channel%4)) = (priority); // macro to set DMA channel priority register for particualar channel
#define _SET_DMA_CHANNEL_CHARACTERISTIC(channel, characteristic) *(DMA_DCHPRI0_ADD + ((channel/4) * 4) - (channel%4)) |= (characteristic); // macro to set channel characteristics without modifying priority
#define _SET_DMA_CHANNEL_RESET(channel) *(DMA_DCHPRI0_ADD + ((channel/4) * 4) - (channel%4)) &= ~(DMA_DCHPRI_DPA | DMA_DCHPRI_ECP); // macro to reset channel characteristics without modifying priority

typedef struct stKINETIS_DMA_TDC
{
    volatile unsigned long  DMA_TCD_SADDR;
    volatile signed short   DMA_TCD_SOFF;
    unsigned short          DMA_TCD_ATTR;
    volatile unsigned long  DMA_TCD_NBYTES_ML;
    volatile unsigned long  DMA_TCD_SLAST;
    volatile unsigned long  DMA_TCD_DADDR;
    volatile signed short   DMA_TCD_DOFF;
    volatile signed short   DMA_TCD_CITER_ELINK;
    volatile unsigned long  DMA_TCD_DLASTSGA;
    volatile unsigned short DMA_TCD_CSR;
    unsigned short          DMA_TCD_BITER_ELINK;
} KINETIS_DMA_TDC;
#endif

#define DMA_BYTES                 0x00000001
#define DMA_HALF_WORDS            0x00000002
#define DMA_LONG_WORDS            0x00000004
#define DMA_AUTOREPEAT            0x00000008
#define DMA_HALF_BUFFER_INTERRUPT 0x00000010
#define DMA_DIRECTION_INPUT       0x00000000
#define DMA_DIRECTION_OUTPUT      0x00000020
#define DMA_FIXED_ADDRESSES       0x00000040
#define DMA_NO_MODULO             0x00000080

extern void fnConfigDMA_buffer(unsigned char ucDMA_channel, unsigned char ucDmaTriggerSource, unsigned long ulBufLength, void *ptrBufSource, void *ptrBufDest, unsigned long ulRules, void(*int_handler)(void), int int_priority);

#if !defined KINETIS_KL
// FlexBus Module
//
#define CSAR0               *(unsigned long *)(FLEXBUS_ADD + 0x00)       // Chip Select Address Register - CS 0
  #define CSA_MASK          0xffff0000
#define CSMR0               *(unsigned long *)(FLEXBUS_ADD + 0x04)       // Chip Select Mask Register - CS 0
  #define BAM_MASK          0xffff0000                                   // Base Address mask
  #define FB_WP             0x00000010                                   // Write Protect
  #define FB_CS_VALID       0x00000001                                   // Chip Select Valid
#define CSCR0               *(unsigned long *)(FLEXBUS_ADD + 0x08)       // Chip Select Control Register - CS 0
  #define SECONDARY_WAIT_STATE_SHIFT 26                                  // Secondary Wait States
  #define SWSEN             0x00800000                                   // Secondary Wait State Enable
  #define ASET_FIRST_EDGE   0x00000000                                   // Address set up - assert CSx on first rising clock edge after address is asserted (reduced by 1 when FB_AA is set)
  #define ASET_SECOND_EDGE  0x00100000                                   // Address set up - assert CSx on second rising clock edge after address is asserted (reduced by 1 when FB_AA is set)
  #define ASET_THIRD_EDGE   0x00200000                                   // Address set up - assert CSx on third rising clock edge after address is asserted (reduced by 1 when FB_AA is set)
  #define ASET_FOURTH_EDGE  0x00300000                                   // Address set up - assert CSx on fourth rising clock edge after address is asserted (reduced by 1 when FB_AA is set)
  #define RDAH_1            0x00000000                                   // Read Address Hold - one cycle after CS deselect
  #define RDAH_2            0x00040000                                   // Read Address Hold - two cycles after CS deselect
  #define RDAH_3            0x00080000                                   // Read Address Hold - three cycles after CS deselect
  #define RDAH_4            0x000c0000                                   // Read Address Hold - four cycles after CS deselect
  #define WRAH_1            0x00000000                                   // Write Address Hold - one cycle after CS deselect
  #define WRAH_2            0x00010000                                   // Write Address Hold - two cycles after CS deselect
  #define WRAH_3            0x00020000                                   // Write Address Hold - three cycles after CS deselect
  #define WRAH_4            0x00030000                                   // Write Address Hold - four cycles after CS deselect
  #define WAIT_STATE_MASK   0x0000fc00                                   // Wait State mask
  #define WAIT_STATE_SHIFT  10                                           // Wait States
  #define FB_BLS            0x00000200                                   // Byte-Lane Shift
  #define FB_AA             0x00000100                                   // Auto-acknowledge enable
  #define PORT_SIZE_32      0x00000000                                   // Port Size 32 bits wide
  #define PORT_SIZE_16      0x00000080                                   // Port Size 16 bits wide
  #define PORT_SIZE_8       0x00000040                                   // Port Size 8 bits wide
  #define BEM               0x00000020                                   // Byte Enable Mode (note that these are no longer noted in the user's manual)
  #define BSTR              0x00000010                                   // Burst Read Enable (")
  #define BSTW              0x00000008                                   // Burst Write Enable(")
  #define MAX_WAIT_STATES   63
  #define MAX_SEC_WAIT_STATES 31
#define CSAR1               *(unsigned long *)(FLEXBUS_ADD + 0x0c)       // Chip Select Address Register - CS 1
#define CSMR1               *(unsigned long *)(FLEXBUS_ADD + 0x10)       // Chip Select Mask Register - CS 1
#define CSCR1               *(unsigned long *)(FLEXBUS_ADD + 0x14)       // Chip Select Control Register - CS 1
#define CSAR2               *(unsigned long *)(FLEXBUS_ADD + 0x18)       // Chip Select Address Register - CS 2
#define CSMR2               *(unsigned long *)(FLEXBUS_ADD + 0x1c)       // Chip Select Mask Register - CS 2
#define CSCR2               *(unsigned long *)(FLEXBUS_ADD + 0x20)       // Chip Select Control Register - CS 2
#define CSAR3               *(unsigned long *)(FLEXBUS_ADD + 0x24)       // Chip Select Address Register - CS 3
#define CSMR3               *(unsigned long *)(FLEXBUS_ADD + 0x28)       // Chip Select Mask Register - CS 3
#define CSCR3               *(unsigned long *)(FLEXBUS_ADD + 0x2c)       // Chip Select Control Register - CS 3
#define CSAR4               *(unsigned long *)(FLEXBUS_ADD + 0x30)       // Chip Select Address Register - CS 4
#define CSMR4               *(unsigned long *)(FLEXBUS_ADD + 0x34)       // Chip Select Mask Register - CS 4
#define CSCR4               *(unsigned long *)(FLEXBUS_ADD + 0x38)       // Chip Select Control Register - CS 4
#define CSAR5               *(unsigned long *)(FLEXBUS_ADD + 0x3c)       // Chip Select Address Register - CS 5
#define CSMR5               *(unsigned long *)(FLEXBUS_ADD + 0x40)       // Chip Select Mask Register - CS 5
#define CSCR5               *(unsigned long *)(FLEXBUS_ADD + 0x44)       // Chip Select Control Register - CS 5

#define CSPMCR              *(unsigned long *)(FLEXBUS_ADD + 0x60)       // Chip Select Port Multiplexing Control Register
#endif

// Memory Protection Unit
//
#if defined MPU_AVAILABLE
    #define MPU_CESR        *(volatile unsigned long *)(MPU_BLOCK + 0x000) // Control/Error Status Register
      #define MPU_CESR_VLD        0x00000001                             // MPU is enabled (default)
      #define MPU_CESR_NRGD_MASK  0x00000f00                             // number of region descriptors (read-only)
      #define MPU_CESR_NSP_MASK   0x0000f000                             // number of slave ports (read-only)
      #define MPU_CESR_HRL_MASK   0x000f0000                             // hardware revision level (read-only)
      #define MPU_CESR_SPERR_7    0x01000000                             // slave port 7 error (write '1' to clear)
      #define MPU_CESR_SPERR_6    0x02000000                             // slave port 6 error (write '1' to clear)
      #define MPU_CESR_SPERR_5    0x04000000                             // slave port 5 error (write '1' to clear)
      #define MPU_CESR_SPERR_4    0x08000000                             // slave port 4 error (write '1' to clear)
      #define MPU_CESR_SPERR_3    0x10000000                             // slave port 3 error (write '1' to clear)
      #define MPU_CESR_SPERR_2    0x20000000                             // slave port 2 error (write '1' to clear)
      #define MPU_CESR_SPERR_1    0x40000000                             // slave port 1 error (write '1' to clear)
      #define MPU_CESR_SPERR_0    0x80000000                             // slave port 0 error (write '1' to clear)
    #define MPU_EAR0        *(volatile unsigned long *)(MPU_BLOCK + 0x010) // error address register, slave port 0 (read-only)
    #define MPU_EDR0        *(volatile unsigned long *)(MPU_BLOCK + 0x014) // error detail register, slave port 0 (read-only)
      #define MPU_EDR_ERW_READ    0x00000000                             // error access was read
      #define MPU_EDR_ERW_WRITE   0x00000001                             // error access was write
      #define MPU_EDR_EATTR_UI    0x00000000                             // error attribute - user mode instruction access
      #define MPU_EDR_EATTR_UD    0x00000002                             // error attribute - user mode data access
      #define MPU_EDR_EATTR_SI    0x00000004                             // error attribute - supervisor mode instruction access
      #define MPU_EDR_EATTR_SD    0x00000006                             // error attribute - supervisor mode data access
      #define MPU_EDR_EMN_MASK    0x000000f0                             // error master number
      #define MPU_EDR_EPID_MASK   0x0000ff00                             // error process identification
      #define MPU_EDR_EACD_MASK   0xffff0000                             // error access control detail
    #define MPU_EAR1        *(volatile unsigned long *)(MPU_BLOCK + 0x018) // error address register, slave port 1 (read-only)
    #define MPU_EDR1        *(volatile unsigned long *)(MPU_BLOCK + 0x01c) // error detail register, slave port 1 (read-only)
    #define MPU_EAR2        *(volatile unsigned long *)(MPU_BLOCK + 0x020) // error address register, slave port 2 (read-only)
    #define MPU_EDR2        *(volatile unsigned long *)(MPU_BLOCK + 0x024) // error detail register, slave port 2 (read-only)
    #define MPU_EAR3        *(volatile unsigned long *)(MPU_BLOCK + 0x028) // error address register, slave port 3 (read-only)
    #define MPU_EDR3        *(volatile unsigned long *)(MPU_BLOCK + 0x02c) // error detail register, slave port 3 (read-only)
    #define MPU_EAR4        *(volatile unsigned long *)(MPU_BLOCK + 0x030) // error address register, slave port 4 (read-only)
    #define MPU_EDR4        *(volatile unsigned long *)(MPU_BLOCK + 0x034) // error detail register, slave port 4 (read-only)
    #define MPU_EAR5        *(volatile unsigned long *)(MPU_BLOCK + 0x038) // error address register, slave port 5 (read-only)
    #define MPU_EDR5        *(volatile unsigned long *)(MPU_BLOCK + 0x03c) // error detail register, slave port 5 (read-only)
    #define MPU_EAR6        *(volatile unsigned long *)(MPU_BLOCK + 0x040) // error address register, slave port 6 (read-only)
    #define MPU_EDR6        *(volatile unsigned long *)(MPU_BLOCK + 0x044) // error detail register, slave port 6 (read-only)
    #define MPU_EAR7        *(volatile unsigned long *)(MPU_BLOCK + 0x048) // error address register, slave port 7 (read-only)
    #define MPU_EDR7        *(volatile unsigned long *)(MPU_BLOCK + 0x04c) // error detail register, slave port 7 (read-only)
    #define MPU_RGD0_WORD0  *(unsigned long *)(MPU_BLOCK + 0x400)        // region descriptor 0, word 0
    #define MPU_RGD0_WORD1  *(unsigned long *)(MPU_BLOCK + 0x404)        // region descriptor 0, word 1
    #define MPU_RGD0_WORD2  *(unsigned long *)(MPU_BLOCK + 0x408)        // region descriptor 0, word 2
    #define MPU_RGD0_WORD3  *(unsigned long *)(MPU_BLOCK + 0x40c)        // region descriptor 0, word 3
    #define MPU_RGD1_WORD0  *(unsigned long *)(MPU_BLOCK + 0x410)        // region descriptor 1, word 0
    #define MPU_RGD1_WORD1  *(unsigned long *)(MPU_BLOCK + 0x414)        // region descriptor 1, word 1
    #define MPU_RGD1_WORD2  *(unsigned long *)(MPU_BLOCK + 0x418)        // region descriptor 1, word 2
    #define MPU_RGD1_WORD3  *(unsigned long *)(MPU_BLOCK + 0x41c)        // region descriptor 1, word 3
    #define MPU_RGD2_WORD0  *(unsigned long *)(MPU_BLOCK + 0x420)        // region descriptor 2, word 0
    #define MPU_RGD2_WORD1  *(unsigned long *)(MPU_BLOCK + 0x424)        // region descriptor 2, word 1
    #define MPU_RGD2_WORD2  *(unsigned long *)(MPU_BLOCK + 0x428)        // region descriptor 2, word 2
    #define MPU_RGD2_WORD3  *(unsigned long *)(MPU_BLOCK + 0x42c)        // region descriptor 2, word 3
    #define MPU_RGD3_WORD0  *(unsigned long *)(MPU_BLOCK + 0x430)        // region descriptor 3, word 0
    #define MPU_RGD3_WORD1  *(unsigned long *)(MPU_BLOCK + 0x434)        // region descriptor 3, word 1
    #define MPU_RGD3_WORD2  *(unsigned long *)(MPU_BLOCK + 0x438)        // region descriptor 3, word 2
    #define MPU_RGD3_WORD3  *(unsigned long *)(MPU_BLOCK + 0x43c)        // region descriptor 3, word 3
    #define MPU_RGD4_WORD0  *(unsigned long *)(MPU_BLOCK + 0x440)        // region descriptor 4, word 0
    #define MPU_RGD4_WORD1  *(unsigned long *)(MPU_BLOCK + 0x444)        // region descriptor 4, word 1
    #define MPU_RGD4_WORD2  *(unsigned long *)(MPU_BLOCK + 0x448)        // region descriptor 4, word 2
    #define MPU_RGD4_WORD3  *(unsigned long *)(MPU_BLOCK + 0x44c)        // region descriptor 4, word 3
    #define MPU_RGD5_WORD0  *(unsigned long *)(MPU_BLOCK + 0x450)        // region descriptor 5, word 0
    #define MPU_RGD5_WORD1  *(unsigned long *)(MPU_BLOCK + 0x454)        // region descriptor 5, word 1
    #define MPU_RGD5_WORD2  *(unsigned long *)(MPU_BLOCK + 0x458)        // region descriptor 5, word 2
    #define MPU_RGD5_WORD3  *(unsigned long *)(MPU_BLOCK + 0x45c)        // region descriptor 5, word 3
    #define MPU_RGD6_WORD0  *(unsigned long *)(MPU_BLOCK + 0x460)        // region descriptor 6, word 0
    #define MPU_RGD6_WORD1  *(unsigned long *)(MPU_BLOCK + 0x464)        // region descriptor 6, word 1
    #define MPU_RGD6_WORD2  *(unsigned long *)(MPU_BLOCK + 0x468)        // region descriptor 6, word 2
    #define MPU_RGD6_WORD3  *(unsigned long *)(MPU_BLOCK + 0x46c)        // region descriptor 6, word 3
    #define MPU_RGD7_WORD0  *(unsigned long *)(MPU_BLOCK + 0x470)        // region descriptor 7, word 0
    #define MPU_RGD7_WORD1  *(unsigned long *)(MPU_BLOCK + 0x474)        // region descriptor 7, word 1
    #define MPU_RGD7_WORD2  *(unsigned long *)(MPU_BLOCK + 0x478)        // region descriptor 7, word 2
    #define MPU_RGD7_WORD3  *(unsigned long *)(MPU_BLOCK + 0x47c)        // region descriptor 7, word 3
    #define MPU_RGD8_WORD0  *(unsigned long *)(MPU_BLOCK + 0x480)        // region descriptor 8, word 0
    #define MPU_RGD8_WORD1  *(unsigned long *)(MPU_BLOCK + 0x484)        // region descriptor 8, word 1
    #define MPU_RGD8_WORD2  *(unsigned long *)(MPU_BLOCK + 0x488)        // region descriptor 8, word 2
    #define MPU_RGD8_WORD3  *(unsigned long *)(MPU_BLOCK + 0x48c)        // region descriptor 8, word 3
    #define MPU_RGD9_WORD0  *(unsigned long *)(MPU_BLOCK + 0x490)        // region descriptor 9, word 0
    #define MPU_RGD9_WORD1  *(unsigned long *)(MPU_BLOCK + 0x494)        // region descriptor 9, word 1
    #define MPU_RGD9_WORD2  *(unsigned long *)(MPU_BLOCK + 0x498)        // region descriptor 9, word 2
    #define MPU_RGD9_WORD3  *(unsigned long *)(MPU_BLOCK + 0x49c)        // region descriptor 9, word 3
    #define MPU_RGD10_WORD0 *(unsigned long *)(MPU_BLOCK + 0x4a0)        // region descriptor 10, word 0
    #define MPU_RGD10_WORD1 *(unsigned long *)(MPU_BLOCK + 0x4a4)        // region descriptor 10, word 1
    #define MPU_RGD10_WORD2 *(unsigned long *)(MPU_BLOCK + 0x4a8)        // region descriptor 10, word 2
    #define MPU_RGD10_WORD3 *(unsigned long *)(MPU_BLOCK + 0x4ac)        // region descriptor 10, word 3
    #define MPU_RGD11_WORD0 *(unsigned long *)(MPU_BLOCK + 0x4b0)        // region descriptor 11, word 0
    #define MPU_RGD11_WORD1 *(unsigned long *)(MPU_BLOCK + 0x4b4)        // region descriptor 11, word 1
    #define MPU_RGD11_WORD2 *(unsigned long *)(MPU_BLOCK + 0x4b8)        // region descriptor 11, word 2
    #define MPU_RGD11_WORD3 *(unsigned long *)(MPU_BLOCK + 0x4bc)        // region descriptor 11, word 3
    #define MPU_RGD12_WORD0 *(unsigned long *)(MPU_BLOCK + 0x4c0)        // region descriptor 12, word 0
    #define MPU_RGD12_WORD1 *(unsigned long *)(MPU_BLOCK + 0x4c4)        // region descriptor 12, word 1
    #define MPU_RGD12_WORD2 *(unsigned long *)(MPU_BLOCK + 0x4c8)        // region descriptor 12, word 2
    #define MPU_RGD12_WORD3 *(unsigned long *)(MPU_BLOCK + 0x4cc)        // region descriptor 12, word 3
    #define MPU_RGD13_WORD0 *(unsigned long *)(MPU_BLOCK + 0x4d0)        // region descriptor 13, word 0
    #define MPU_RGD13_WORD1 *(unsigned long *)(MPU_BLOCK + 0x4d4)        // region descriptor 13, word 1
    #define MPU_RGD13_WORD2 *(unsigned long *)(MPU_BLOCK + 0x4d8)        // region descriptor 13, word 2
    #define MPU_RGD13_WORD3 *(unsigned long *)(MPU_BLOCK + 0x4dc)        // region descriptor 13, word 3
    #define MPU_RGD14_WORD0 *(unsigned long *)(MPU_BLOCK + 0x4e0)        // region descriptor 14, word 0
    #define MPU_RGD14_WORD1 *(unsigned long *)(MPU_BLOCK + 0x4e4)        // region descriptor 14, word 1
    #define MPU_RGD14_WORD2 *(unsigned long *)(MPU_BLOCK + 0x4e8)        // region descriptor 14, word 2
    #define MPU_RGD14_WORD3 *(unsigned long *)(MPU_BLOCK + 0x4ec)        // region descriptor 14, word 3
    #define MPU_RGD15_WORD0 *(unsigned long *)(MPU_BLOCK + 0x4f0)        // region descriptor 15, word 0
    #define MPU_RGD15_WORD1 *(unsigned long *)(MPU_BLOCK + 0x4f4)        // region descriptor 15, word 1
    #define MPU_RGD15_WORD2 *(unsigned long *)(MPU_BLOCK + 0x4f8)        // region descriptor 15, word 2
    #define MPU_RGD15_WORD3 *(unsigned long *)(MPU_BLOCK + 0x4fc)        // region descriptor 15, word 3
    #define MPU_RGDAAC0     *(unsigned long *)(MPU_BLOCK + 0x800)        // region descriptor alternate access control 0
    #define MPU_RGDAAC1     *(unsigned long *)(MPU_BLOCK + 0x804)        // region descriptor alternate access control 1
    #define MPU_RGDAAC2     *(unsigned long *)(MPU_BLOCK + 0x808)        // region descriptor alternate access control 2
    #define MPU_RGDAAC3     *(unsigned long *)(MPU_BLOCK + 0x80c)        // region descriptor alternate access control 3
    #define MPU_RGDAAC4     *(unsigned long *)(MPU_BLOCK + 0x810)        // region descriptor alternate access control 4
    #define MPU_RGDAAC5     *(unsigned long *)(MPU_BLOCK + 0x814)        // region descriptor alternate access control 5
    #define MPU_RGDAAC6     *(unsigned long *)(MPU_BLOCK + 0x818)        // region descriptor alternate access control 6
    #define MPU_RGDAAC7     *(unsigned long *)(MPU_BLOCK + 0x81c)        // region descriptor alternate access control 7
    #define MPU_RGDAAC8     *(unsigned long *)(MPU_BLOCK + 0x820)        // region descriptor alternate access control 8
    #define MPU_RGDAAC9     *(unsigned long *)(MPU_BLOCK + 0x824)        // region descriptor alternate access control 9
    #define MPU_RGDAAC10    *(unsigned long *)(MPU_BLOCK + 0x828)        // region descriptor alternate access control 10
    #define MPU_RGDAAC11    *(unsigned long *)(MPU_BLOCK + 0x82c)        // region descriptor alternate access control 11
    #define MPU_RGDAAC12    *(unsigned long *)(MPU_BLOCK + 0x830)        // region descriptor alternate access control 12
    #define MPU_RGDAAC13    *(unsigned long *)(MPU_BLOCK + 0x834)        // region descriptor alternate access control 13
    #define MPU_RGDAAC14    *(unsigned long *)(MPU_BLOCK + 0x838)        // region descriptor alternate access control 14
    #define MPU_RGDAAC15    *(unsigned long *)(MPU_BLOCK + 0x83c)        // region descriptor alternate access control 15
#endif

#if !defined KINETIS_KL
    // Flash Memory Controller
    //
    #define FMC_PFAPR           *(unsigned long *)(FMC_BLOCK + 0x000)    // Flash Access Protection Register
      #define FMC_PFAPR_M0AP_NONE 0x00000000                             // master 0 - no access rights
      #define FMC_PFAPR_M0AP_RD   0x00000001                             // master 0 - read access rights
      #define FMC_PFAPR_M0AP_WR   0x00000002                             // master 0 - write access rights
      #define FMC_PFAPR_M0AP_RW   0x00000003                             // master 0 - read/write access rights
      #define FMC_PFAPR_M1AP_NONE 0x00000000                             // master 1 - no access rights
      #define FMC_PFAPR_M1AP_RD   0x00000004                             // master 1 - read access rights
      #define FMC_PFAPR_M1AP_WR   0x00000008                             // master 1 - write access rights
      #define FMC_PFAPR_M1AP_RW   0x0000000c                             // master 1 - read/write access rights
      #define FMC_PFAPR_M2AP_NONE 0x00000000                             // master 2 - no access rights
      #define FMC_PFAPR_M2AP_RD   0x00000010                             // master 2 - read access rights
      #define FMC_PFAPR_M2AP_WR   0x00000020                             // master 2 - write access rights
      #define FMC_PFAPR_M2AP_RW   0x00000030                             // master 2 - read/write access rights
      #define FMC_PFAPR_M3AP_NONE 0x00000000                             // master 3 - no access rights
      #define FMC_PFAPR_M3AP_RD   0x00000040                             // master 3 - read access rights
      #define FMC_PFAPR_M3AP_WR   0x00000080                             // master 3 - write access rights
      #define FMC_PFAPR_M3AP_RW   0x000000c0                             // master 3 - read/write access rights
      #define FMC_PFAPR_M4AP_NONE 0x00000000                             // master 4 - no access rights
      #define FMC_PFAPR_M4AP_RD   0x00000100                             // master 4 - read access rights
      #define FMC_PFAPR_M4AP_WR   0x00000200                             // master 4 - write access rights
      #define FMC_PFAPR_M4AP_RW   0x00000300                             // master 4 - read/write access rights
      #define FMC_PFAPR_M5AP_NONE 0x00000000                             // master 5 - no access rights
      #define FMC_PFAPR_M5AP_RD   0x00000400                             // master 5 - read access rights
      #define FMC_PFAPR_M5AP_WR   0x00000800                             // master 5 - write access rights
      #define FMC_PFAPR_M5AP_RW   0x00000c00                             // master 5 - read/write access rights
      #define FMC_PFAPR_M6AP_NONE 0x00000000                             // master 6 - no access rights
      #define FMC_PFAPR_M6AP_RD   0x00001000                             // master 6 - read access rights
      #define FMC_PFAPR_M6AP_WR   0x00002000                             // master 6 - write access rights
      #define FMC_PFAPR_M6AP_RW   0x00003000                             // master 6 - read/write access rights
      #define FMC_PFAPR_M7AP_NONE 0x00000000                             // master 7 - no access rights
      #define FMC_PFAPR_M7AP_RD   0x00004000                             // master 7 - read access rights
      #define FMC_PFAPR_M7AP_WR   0x00008000                             // master 7 - write access rights
      #define FMC_PFAPR_M7AP_RW   0x0000c000                             // master 7 - read/write access rights
      #define FMC_PFAPR_M7AP_RW   0x0000c000                             // master 7 - read/write access rights
      #define FMC_PFAPR_M0PFD     0x00010000                             // master 0 - pre-fetch disable
      #define FMC_PFAPR_M1PFD     0x00020000                             // master 1 - pre-fetch disable
      #define FMC_PFAPR_M2PFD     0x00040000                             // master 2 - pre-fetch disable
      #define FMC_PFAPR_M3PFD     0x00080000                             // master 3 - pre-fetch disable
      #define FMC_PFAPR_M4PFD     0x00100000                             // master 4 - pre-fetch disable
      #define FMC_PFAPR_M5PFD     0x00200000                             // master 5 - pre-fetch disable
      #define FMC_PFAPR_M6PFD     0x00400000                             // master 6 - pre-fetch disable
      #define FMC_PFAPR_M7PFD     0x00800000                             // master 7 - pre-fetch disable
      #define FMC_PFAPR_DEFAULT   (FMC_PFAPR_M0AP_RW | FMC_PFAPR_M1AP_RW | FMC_PFAPR_M2AP_RW | FMC_PFAPR_M3PFD | FMC_PFAPR_M4PFD | FMC_PFAPR_M5PFD | FMC_PFAPR_M6PFD | FMC_PFAPR_M0PFD)
    #define FMC_PFB0CR          *(unsigned long *)(FMC_BLOCK + 0x004)    // Flash Bank 0 Control Registe
      #define BANKDCE             0x00000010                             // data cache enable
      #define BANKICE             0x00000008                             // instruction cache enable
      #define BANK_DPE            0x00000004                             // bank data prefetch enable
      #define BANKIPE             0x00000002                             // instruction prefetch enable
      #define BANKSEBE            0x00000001                             // single entry buffer enable
    #define FMC_PFB1CR          *(unsigned long *)(FMC_BLOCK + 0x008)    // Flash Bank 1 Control Register

    #define FMC_TAGVDW0S0       *(unsigned long *)(FMC_BLOCK + 0x100)    // Cache Directory Storage
    #define FMC_TAGVDW0S1       *(unsigned long *)(FMC_BLOCK + 0x104)    // Cache Directory Storage
    #define FMC_TAGVDW0S2       *(unsigned long *)(FMC_BLOCK + 0x108)    // Cache Directory Storage
    #define FMC_TAGVDW0S3       *(unsigned long *)(FMC_BLOCK + 0x10c)    // Cache Directory Storage
    #define FMC_TAGVDW0S4       *(unsigned long *)(FMC_BLOCK + 0x110)    // Cache Directory Storage
    #define FMC_TAGVDW0S5       *(unsigned long *)(FMC_BLOCK + 0x114)    // Cache Directory Storage
    #define FMC_TAGVDW0S6       *(unsigned long *)(FMC_BLOCK + 0x118)    // Cache Directory Storage
    #define FMC_TAGVDW0S7       *(unsigned long *)(FMC_BLOCK + 0x11c)    // Cache Directory Storage
    #define FMC_TAGVDW1S0       *(unsigned long *)(FMC_BLOCK + 0x120)    // Cache Directory Storage
    #define FMC_TAGVDW1S1       *(unsigned long *)(FMC_BLOCK + 0x124)    // Cache Directory Storage
    #define FMC_TAGVDW1S2       *(unsigned long *)(FMC_BLOCK + 0x128)    // Cache Directory Storage
    #define FMC_TAGVDW1S3       *(unsigned long *)(FMC_BLOCK + 0x12c)    // Cache Directory Storage
    #define FMC_TAGVDW1S4       *(unsigned long *)(FMC_BLOCK + 0x130)    // Cache Directory Storage
    #define FMC_TAGVDW1S5       *(unsigned long *)(FMC_BLOCK + 0x134)    // Cache Directory Storage
    #define FMC_TAGVDW1S6       *(unsigned long *)(FMC_BLOCK + 0x138)    // Cache Directory Storage
    #define FMC_TAGVDW1S7       *(unsigned long *)(FMC_BLOCK + 0x13c)    // Cache Directory Storage
    #define FMC_TAGVDW2S0       *(unsigned long *)(FMC_BLOCK + 0x140)    // Cache Directory Storage
    #define FMC_TAGVDW2S1       *(unsigned long *)(FMC_BLOCK + 0x144)    // Cache Directory Storage
    #define FMC_TAGVDW2S2       *(unsigned long *)(FMC_BLOCK + 0x148)    // Cache Directory Storage
    #define FMC_TAGVDW2S3       *(unsigned long *)(FMC_BLOCK + 0x14c)    // Cache Directory Storage
    #define FMC_TAGVDW2S4       *(unsigned long *)(FMC_BLOCK + 0x150)    // Cache Directory Storage
    #define FMC_TAGVDW2S5       *(unsigned long *)(FMC_BLOCK + 0x154)    // Cache Directory Storage
    #define FMC_TAGVDW2S6       *(unsigned long *)(FMC_BLOCK + 0x158)    // Cache Directory Storage
    #define FMC_TAGVDW2S7       *(unsigned long *)(FMC_BLOCK + 0x15c)    // Cache Directory Storage
    #define FMC_TAGVDW3S0       *(unsigned long *)(FMC_BLOCK + 0x160)    // Cache Directory Storage
    #define FMC_TAGVDW3S1       *(unsigned long *)(FMC_BLOCK + 0x164)    // Cache Directory Storage
    #define FMC_TAGVDW3S2       *(unsigned long *)(FMC_BLOCK + 0x168)    // Cache Directory Storage
    #define FMC_TAGVDW3S3       *(unsigned long *)(FMC_BLOCK + 0x16c)    // Cache Directory Storage
    #define FMC_TAGVDW3S4       *(unsigned long *)(FMC_BLOCK + 0x170)    // Cache Directory Storage
    #define FMC_TAGVDW3S5       *(unsigned long *)(FMC_BLOCK + 0x174)    // Cache Directory Storage
    #define FMC_TAGVDW3S6       *(unsigned long *)(FMC_BLOCK + 0x178)    // Cache Directory Storage
    #define FMC_TAGVDW3S7       *(unsigned long *)(FMC_BLOCK + 0x17c)    // Cache Directory Storage

    #define FMC_DATAW0S0U       *(unsigned long *)(FMC_BLOCK + 0x200)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S0L       *(unsigned long *)(FMC_BLOCK + 0x204)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S1U       *(unsigned long *)(FMC_BLOCK + 0x208)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S1L       *(unsigned long *)(FMC_BLOCK + 0x20c)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S2U       *(unsigned long *)(FMC_BLOCK + 0x210)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S2L       *(unsigned long *)(FMC_BLOCK + 0x214)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S3U       *(unsigned long *)(FMC_BLOCK + 0x218)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S3L       *(unsigned long *)(FMC_BLOCK + 0x21c)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S4U       *(unsigned long *)(FMC_BLOCK + 0x220)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S4L       *(unsigned long *)(FMC_BLOCK + 0x224)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S5U       *(unsigned long *)(FMC_BLOCK + 0x228)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S5L       *(unsigned long *)(FMC_BLOCK + 0x22c)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S6U       *(unsigned long *)(FMC_BLOCK + 0x230)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S6L       *(unsigned long *)(FMC_BLOCK + 0x234)    // Cache Data Storage (lower word)
    #define FMC_DATAW0S7U       *(unsigned long *)(FMC_BLOCK + 0x238)    // Cache Data Storage (upper word)
    #define FMC_DATAW0S7L       *(unsigned long *)(FMC_BLOCK + 0x23c)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S0U       *(unsigned long *)(FMC_BLOCK + 0x240)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S0L       *(unsigned long *)(FMC_BLOCK + 0x244)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S1U       *(unsigned long *)(FMC_BLOCK + 0x248)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S1L       *(unsigned long *)(FMC_BLOCK + 0x24c)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S2U       *(unsigned long *)(FMC_BLOCK + 0x250)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S2L       *(unsigned long *)(FMC_BLOCK + 0x254)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S3U       *(unsigned long *)(FMC_BLOCK + 0x258)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S3L       *(unsigned long *)(FMC_BLOCK + 0x25c)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S4U       *(unsigned long *)(FMC_BLOCK + 0x260)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S4L       *(unsigned long *)(FMC_BLOCK + 0x264)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S5U       *(unsigned long *)(FMC_BLOCK + 0x268)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S5L       *(unsigned long *)(FMC_BLOCK + 0x26c)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S6U       *(unsigned long *)(FMC_BLOCK + 0x270)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S6L       *(unsigned long *)(FMC_BLOCK + 0x274)    // Cache Data Storage (lower word)
    #define FMC_DATAW1S7U       *(unsigned long *)(FMC_BLOCK + 0x278)    // Cache Data Storage (upper word)
    #define FMC_DATAW1S7L       *(unsigned long *)(FMC_BLOCK + 0x27c)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S0U       *(unsigned long *)(FMC_BLOCK + 0x280)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S0L       *(unsigned long *)(FMC_BLOCK + 0x284)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S1U       *(unsigned long *)(FMC_BLOCK + 0x288)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S1L       *(unsigned long *)(FMC_BLOCK + 0x28c)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S2U       *(unsigned long *)(FMC_BLOCK + 0x290)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S2L       *(unsigned long *)(FMC_BLOCK + 0x294)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S3U       *(unsigned long *)(FMC_BLOCK + 0x298)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S3L       *(unsigned long *)(FMC_BLOCK + 0x29c)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S4U       *(unsigned long *)(FMC_BLOCK + 0x2a0)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S4L       *(unsigned long *)(FMC_BLOCK + 0x2a4)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S5U       *(unsigned long *)(FMC_BLOCK + 0x2a8)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S5L       *(unsigned long *)(FMC_BLOCK + 0x2ac)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S6U       *(unsigned long *)(FMC_BLOCK + 0x2b0)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S6L       *(unsigned long *)(FMC_BLOCK + 0x2b4)    // Cache Data Storage (lower word)
    #define FMC_DATAW2S7U       *(unsigned long *)(FMC_BLOCK + 0x2b8)    // Cache Data Storage (upper word)
    #define FMC_DATAW2S7L       *(unsigned long *)(FMC_BLOCK + 0x2bc)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S0U       *(unsigned long *)(FMC_BLOCK + 0x2c0)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S0L       *(unsigned long *)(FMC_BLOCK + 0x2c4)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S1U       *(unsigned long *)(FMC_BLOCK + 0x2c8)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S1L       *(unsigned long *)(FMC_BLOCK + 0x2cc)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S2U       *(unsigned long *)(FMC_BLOCK + 0x2d0)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S2L       *(unsigned long *)(FMC_BLOCK + 0x2d4)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S3U       *(unsigned long *)(FMC_BLOCK + 0x2d8)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S3L       *(unsigned long *)(FMC_BLOCK + 0x2dc)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S4U       *(unsigned long *)(FMC_BLOCK + 0x2e0)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S4L       *(unsigned long *)(FMC_BLOCK + 0x2e4)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S5U       *(unsigned long *)(FMC_BLOCK + 0x2e8)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S5L       *(unsigned long *)(FMC_BLOCK + 0x2ec)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S6U       *(unsigned long *)(FMC_BLOCK + 0x2f0)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S6L       *(unsigned long *)(FMC_BLOCK + 0x2f4)    // Cache Data Storage (lower word)
    #define FMC_DATAW3S7U       *(unsigned long *)(FMC_BLOCK + 0x2f8)    // Cache Data Storage (upper word)
    #define FMC_DATAW3S7L       *(unsigned long *)(FMC_BLOCK + 0x2fc)    // Cache Data Storage (lower word)
#endif

// Crossbar switch master assignments
//
#define FMC_FPAPR_ARM_CORE_CODE_BUS     FMC_PFAPR_M0AP_RD
#define FMC_FPAPR_ARM_CORE_SYSTEM_BUS   FMC_PFAPR_M1AP_RD
#define FMC_FPAPR_DMA_EZPORT            FMC_PFAPR_M2AP_RD
#if (KINETIS_MAX_SPEED < 100000000) && !(defined KINETIS_K21 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_K64 || defined KINETIS_KV30 || defined KINETIS_KW2X)
    #define FMC_FPAPR_USB_FS            FMC_PFAPR_M3AP_RD                // USB FS is bus master 3
    #define CROSSBAR_MASTER_USB_FS      MASTER_M3
#else
    #if defined KINETIS_K65 || defined KINETIS_K66                       // {95}
        #define FMC_FPAPR_ETHERNET              FMC_PFAPR_M3AP_RD        // Ethernet is bus master 3
        #define FMC_FPAPR_USB_FS                FMC_PFAPR_M4AP_RD        // USB FS is bus master 4
        #define FMC_FPAPR_SDHC                  FMC_PFAPR_M5AP_RD        // SDHC is bus master 5
        #define FMC_FPAPR_USB_HS                FMC_PFAPR_M6AP_RD        // USB HS is bus master 6
        #define CROSSBAR_MASTER_ETHERNET        MASTER_M3
        #define CROSSBAR_MASTER_USB_FS          MASTER_M4
        #define CROSSBAR_MASTER_SDHC            MASTER_M5
        #define CROSSBAR_MASTER_USB_HS          MASTER_M6
    #elif defined KINETIS_K_FPU && !(defined KINETIS_K21 || defined KINETIS_K22 || (defined KINETIS_K24 && (SIZE_OF_FLASH == (1024 * 1024))) || defined KINETIS_K64)
        #define FMC_FPAPR_SDHC_NFC_USB_FS       FMC_PFAPR_M3AP_RD
        #define FMC_FPAPR_USB_FS                FMC_PFAPR_M3AP_RD        // USB FS is bus master 3
        #define FMC_FPAPR_LCD_BACKGROUND_PLANE  FMC_PFAPR_M4AP_RD
        #define FMC_FPAPR_LCD_GRAPHIC_WINDOW    FMC_PFAPR_M5AP_RD
        #define FMC_FPAPR_USB_HS                FMC_PFAPR_M6AP_RD        // {25} USB HS is bus master 6
        #define FMC_FPAPR_ETHERNET              FMC_PFAPR_M7AP_RD
        #define CROSSBAR_MASTER_SDHC            MASTER_M3
        #define CROSSBAR_MASTER_NFC             MASTER_M3
        #define CROSSBAR_MASTER_USB_FS          MASTER_M3
        #define CROSSBAR_MASTER_LCDC_BACKGROUND MASTER_M4                // only K70
        #define CROSSBAR_MASTER_LCDC_GRAPHIC    MASTER_M5                // only K70
        #define CROSSBAR_MASTER_USB_HS          MASTER_M6
        #define CROSSBAR_MASTER_ETHERNET        MASTER_M7
    #else
        #define FMC_FPAPR_ETHERNET              FMC_PFAPR_M3AP_RD
        #define FMC_FPAPR_USB_FS                FMC_PFAPR_M4AP_RD        // USB FS is bus master 4
        #define FMC_FPAPR_SDHC                  FMC_PFAPR_M5AP_RD
        #define CROSSBAR_MASTER_ETHERNET        MASTER_M3
        #define CROSSBAR_MASTER_USB_FS          MASTER_M4
        #define CROSSBAR_MASTER_SDHC            MASTER_M5
    #endif
#endif

#define CROSSBAR_MASTER_ARM_CORE_CODE    MASTER_M0
#define CROSSBAR_MASTER_ARM_CORE_SYSTEM  MASTER_M0
#if !defined KINETIS_KL2
    #define CROSSBAR_MASTER_DMA          MASTER_M2
    #if !defined KINETIS_KL
        #define CROSSBAR_MASTER_EZPORT   MASTER_M2
    #endif
#endif

#define CROSSBAR_SLAVE_FLASH_CONTROLLER  SLAVE_S0
#define CROSSBAR_SLAVE_SRAML_SRAMU       SLAVE_S1
#define CROSSBAR_SLAVE_SRAM_BACKDOOR     SLAVE_S1
#define CROSSBAR_SLAVE_BME               SLAVE_S2
#define CROSSBAR_SLAVE_PERIPH_BRIDGE_0   SLAVE_S2
#define CROSSBAR_SLAVE_PERIPH_BRIDGE_1   SLAVE_S3
#define CROSSBAR_SLAVE_GPIO_CONTROLLER   SLAVE_S3
#define CROSSBAR_SLAVE_FLEXBUS           SLAVE_S4
#define CROSSBAR_SLAVE_DRAM1             SLAVE_S5
#define CROSSBAR_SLAVE_DRAM2             SLAVE_S6
#define CROSSBAR_SLAVE_DRAM3             SLAVE_S7


// Flash Memory Module
//
#if defined KINETIS_KE
    #if defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define FTMRH_FCCOBIX       *(unsigned char *)(FTFL_BLOCK + 0x1) // Flash CCOB Index Register
        #define FTMRH_FSEC          *(volatile unsigned char *)(FTFL_BLOCK + 0x2) // Flash Security Register (read-only)
          #define FTMRH_FSEC_SEC_SECURE       0x00
          #define FTMRH_FSEC_SEC_UNSECURE     0x02
          #define FTMRH_FSEC_KEYEN_ENABLED    0x80
          #define FTMRH_FSEC_KEYEN_DISABLED   0xc0
        #define FTMRH_FCLKDIV       *(unsigned char *)(FTFL_BLOCK + 0x3) // Flash Clock Divider Register

        #define FTMRH_FSTAT_ADDR    (volatile unsigned char *)(FTFL_BLOCK + 0x5)
        #define FTMRH_FSTAT         *(volatile unsigned char *)(FTFL_BLOCK + 0x5) // Flash Status Register
          #define FTMRH_STAT_MGSTAT  0x03                                // error detected during sequence (mask with MGSTAT0 and MGSTAT1) (read-only)
          #define FTMRH_STAT_MBUSY   0x08                                // memory controller is busy executing a command (CCIF == 0) (read-only)
          #define FTMRH_STAT_FPVIOL  0x10                                // Flash protection violation flag
          #define FTMRH_STAT_ACCERR  0x20                                // Flash access error flag
          #define FTMRH_STAT_CCIF    0x80                                // command complete interrupt flag

        #define FTMRH_FCNFG         *(unsigned char *)(FTFL_BLOCK + 0x7) // Flash Configuration Register
        #define FTMRH_FCCOBLO       *(volatile unsigned char *)(FTFL_BLOCK + 0x8) // Flash Common Command Object Register: Low
        #define FTMRH_FCCOBHI       *(volatile unsigned char *)(FTFL_BLOCK + 0x9) // Flash Common Command Object Register: High

        #define FTMRH_FPROT         *(volatile unsigned char *)(FTFL_BLOCK + 0xb) // Flash Protection Register (read-only)
          #define FTMRH_FPROT_FPLS   0x03                                // flash protection lower address size mask
          #define FTMRH_FPROT_FPLDIS 0x04                                // flash protection lower address range disable
          #define FTMRH_FPROT_FPHS   0x18                                // flash protection higher address size mask
          #define FTMRH_FPROT_FPHDIS 0x20                                // flash protection higher address range disable
          #define FTMRH_FPROT_RNV6   0x40                                // reserved non-volatile bit - should remain at '1'
          #define FTMRH_FPROT_FPOPEN 0x80                                // flash protection operation enable
          #define KE_NO_FLASH_PROTECTION         (FTMRH_FPROT_FPOPEN | FTMRH_FPROT_FPHDIS | FTMRH_FPROT_FPLDIS | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_PROTECTED_LOW_RANGE         (FTMRH_FPROT_FPOPEN | FTMRH_FPROT_FPHDIS | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_PROTECTED_HIGH_RANGE        (FTMRH_FPROT_FPOPEN | FTMRH_FPROT_FPLDIS | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_PROTECTED_HIGH_LOW_RANGES   (FTMRH_FPROT_FPOPEN | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_FULL_FLASH_PROTECTED        (FTMRH_FPROT_FPHDIS | FTMRH_FPROT_FPLDIS | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_UNPROTECTED_LOW_RANGE       (FTMRH_FPROT_FPHDIS | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_UNPROTECTED_HIGH_RANGE      (FTMRH_FPROT_FPLDIS | FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
          #define KE_UNPROTECTED_HIGH_LOW_RANGES (FTMRH_FPROT_FPLS | FTMRH_FPROT_FPHS | FTMRH_FPROT_RNV6)
        #define FTMRH_FOPT          *(volatile unsigned char *)(FTFL_BLOCK + 0xf) // Flash Option Register (read-only)
    #else
        #define FTMRH_FCLKDIV       *(unsigned char *)(FTFL_BLOCK + 0x0) // Flash Clock Divider Register
        #define FTMRH_FSEC          *(volatile unsigned char *)(FTFL_BLOCK + 0x1) // Flash Security Register (read-only)
          #define FTMRH_FSEC_SEC_SECURE       0x3c
          #define FTMRH_FSEC_SEC_UNSECURE     0x3e
          #define FTMRH_FSEC_KEYEN_ENABLED    0x80
          #define FTMRH_FSEC_KEYEN_DISABLED   0xc0
        #define FTMRH_FCCOBIX       *(unsigned char *)(FTFL_BLOCK + 0x2) // Flash CCOB Index Register

        #define FTMRH_FCNFG         *(unsigned char *)(FTFL_BLOCK + 0x4) // Flash Configuration Register
        #define FTMRH_FERCNFG       *(unsigned char *)(FTFL_BLOCK + 0x5) // Flash Error Configuration Register
        #define FTMRH_FSTAT_ADDR    (volatile unsigned char *)(FTFL_BLOCK + 0x6)
        #define FTMRH_FSTAT         *(volatile unsigned char *)(FTFL_BLOCK + 0x6) // Flash Status Register
          #define FTMRH_STAT_MGSTAT  0x03                                // error detected during sequence (mask)
          #define FTMRH_STAT_MBUSY   0x08                                // memory controller is busy executing a command (CCIF == 0)
          #define FTMRH_STAT_FPVIOL  0x10                                // Flash protection violation flag
          #define FTMRH_STAT_ACCERR  0x20                                // Flash access error flag
          #define FTMRH_STAT_CCIF    0x80                                // command complete interrupt flag
        #define FTMRH_FERSTAT       *(volatile unsigned char *)(FTFL_BLOCK + 0x7) // Flash Error Status Register
        #define FTMRH_FPROT         *(volatile unsigned char *)(FTFL_BLOCK + 0x8) // Flash Protection Register (read-only)
          #define FTMRH_FPROT_FPLS   0x03                                // flash protection lower address size mask
          #define FTMRH_FPROT_FPLDIS 0x04                                // flash protection lower address range disable
          #define FTMRH_FPROT_FPHS   0x18                                // flash protection higher address size mask
          #define FTMRH_FPROT_FPHDIS 0x20                                // flash protection higher address range disable
          #define FTMRH_FPROT_RNV6   0x40                                // reserved non-volatile bit - should remain at '1'
          #define FTMRH_FPROT_FPOPEN 0x80                                // flash protection operation enable
          #define KE_NO_FLASH_PROTECTION         (FTMRH_FPROT_FPOPEN | FTMRH_FPROT_RNV6 | FTMRH_FPROT_FPHDIS | FTMRH_FPROT_FPHS | FTMRH_FPROT_FPLDIS | FTMRH_FPROT_FPLS)
        #define FTMRH_EEPROT        *(volatile unsigned char *)(FTFL_BLOCK + 0x9) // EEPROM Protection Register
        #define FTMRH_FCCOBHI       *(volatile unsigned char *)(FTFL_BLOCK + 0xa) // Flash Common Command Object Register: High
        #define FTMRH_FCCOBLO       *(volatile unsigned char *)(FTFL_BLOCK + 0xb) // Flash Common Command Object Register: Low
        #define FTMRH_FOPT          *(volatile unsigned char *)(FTFL_BLOCK + 0xc) // Flash Option Register (read-only)
    #endif

      #define FCMD_ERASE_VERIFY_ALL_BLOCKS    0x01                       // verifies that all flash and EEPROM blocks are erased
      #define FCMD_ERASE_VERIFY_BLOCK         0x02
      #define FCMD_ERASE_VERIFY_FLASH_SECTION 0x03
      #define FCMD_READ_ONCE                  0x04
      #define FCMD_PROGRAM_PHRASE             0x06                       // program (up to) 8 bytes phrase
      #define FCMD_PROGRAM_ONCE               0x07
      #define FCMD_ERASE_ALL_BLOCKS           0x08
      #define FCMD_ERASE_FLASH_BLOCK          0x09
      #define FCMD_ERASE_FLASH_SECTOR         0x0a
      #define FCMD_UNSECURE_FLASH             0x0b
      #define FCMD_VERIFY_BACKDOOR_ACCESS_KEY 0x0c
      #define FCMD_SET_USER_MARGIN_LEVEL      0x0d
      #define FCMD_SET_FACTORY_MARGIN_LEVEL   0x0e
      #if defined KINETIS_KE02
          #define FCMD_ERASE_VERIFY_EEPROM_SECTION 0x10
          #define FCMD_PROGRAM_EEPROM              0x11
          #define FCMD_ERASE_EEPROM_SECTOR         0x12
      #endif

    #define FTFL_FSTAT          FTMRH_FSTAT                              // for compatibility
    #define FTFL_STAT_CCIF      FTMRH_STAT_CCIF
    #define FTFL_STAT_ACCERR    FTMRH_STAT_ACCERR
    #define FTFL_STAT_FPVIOL    FTMRH_STAT_FPVIOL
    #define FTFL_STAT_MGSTAT0   FTMRH_STAT_MGSTAT
    #define FTFL_FCCOB0         FTMRH_FCCOBHI
    #define FCMD_PROGRAM        FCMD_PROGRAM_PHRASE
    #define FTFL_FCCOB1         FTMRH_FCCOBLO
    #define FTFL_FCCOB2         FTMRH_FCCOBHI
    #define FTFL_FCCOB3         FTMRH_FCCOBLO

    #define FLASH_STATUS_REGISTER     FTMRH_FSTAT_ADDR
#else
    #define FTFL_FSTAT          *(volatile unsigned char *)(FTFL_BLOCK + 0x00) // Flash Status Register
      #define FTFL_STAT_MGSTAT0  0x01                                    // error detected during sequence (read-only)
      #define FTFL_STAT_FPVIOL   0x10                                    // Flash protection violation flag (write '1' to clear)
      #define FTFL_STAT_ACCERR   0x20                                    // Flash access error flag (write '1' to clear)
      #if defined KINETIS_K64 || defined KINETIS_K22
        #define FTFL_STAT_RDCOLERR 0x40                                  // Read collision error flag (write '1' to clear)
      #endif
      #define FTFL_STAT_CCIF     0x80                                    // command complete interrupt flag (write '1' to clear)
    #define FTFL_FCNFG          *(unsigned char *)(FTFL_BLOCK + 0x01)    // Flash Configuration Register
    #define FTFL_FSEC           *(volatile unsigned char *)(FTFL_BLOCK + 0x02) // Flash Security Register (read-only)
      #define FTFL_FSEC_SEC_SECURE       0x00                            // MCU security status is secure
      #define FTFL_FSEC_SEC_UNSECURE     0x02                            // MCU security status is unsecure (standard shipping state of new devices)
      #define FTFL_FSEC_SEC_MASK         0x03
      #define FTFL_FSEC_FSLACC_DENIED    0x04                            // freescale factory access denied (only relevant in secure mode)
      #define FTFL_FSEC_FSLACC_GRANTED   0x0c                            // freescale factory access granted
      #define FTFL_FSEC_MEEN_DISABLED    0x20                            // mass erase is disabled (only relevant in secure mode)
      #define FTFL_FSEC_MEEN_ENABLED     0x30                            // mass erase is enabled
      #define FTFL_FSEC_KEYEN_ENABLED    0x80                            // backdoor key access enabled
      #define FTFL_FSEC_KEYEN_DISABLED   0xc0                            // backdoor key access disabled
    #define FTFL_FOPT           *(volatile unsigned char *)(FTFL_BLOCK + 0x03) // Flash Option Register (read-only)
    #if defined KINETIS_KL || defined KINETIS_KV
      #define FTFL_FOPT_LPBOOT_CLK_DIV_8  0x00
      #define FTFL_FOPT_LPBOOT_CLK_DIV_4  0x01
      #define FTFL_FOPT_LPBOOT_CLK_DIV_2  0x10
      #define FTFL_FOPT_LPBOOT_CLK_DIV_0  0x11
      #if defined ROM_BOOTLOADER
        #define FTFL_FOPT_BOOTPIN_OPT_ENABLE  0x00                       // boot from ROM if the BOOTCFG0 input is asserted
        #define FTFL_FOPT_BOOTPIN_OPT_DISABLE 0x02                       // BOOTCFG0 input is not used
        #define FTFL_FOPT_BOOTSRC_SEL_FLASH 0x00                         // boot from flash
        #define FTFL_FOPT_BOOTSRC_SEL_ROM 0x80                           // boot from ROM
      #endif
      #define FTFL_FOPT_NMI_DISABLED      0x00
      #define FTFL_FOPT_NMI_ENABLED       0x04
      #define FTFL_FOPT_RESET_PIN_ENABLED 0x08
      #define FTFL_FOPT_FAST_INIT         0x20
    #else
      #define FTFL_FOPT_LPBOOT_LOW_POWER  0x00
      #define FTFL_FOPT_LPBOOT_NORMAL     0x01
      #define FTFL_FOPT_EZPORT_DISABLED   0x00
      #define FTFL_FOPT_EZPORT_ENABLED    0x02
      #define FTFL_FOPT_NMI_DISABLED      0x00
      #define FTFL_FOPT_NMI_ENABLED       0x04                            // NMI pin/interrupts reset default to enabled (only functional on revision 2 parts)
    #endif
    #define FTFL_FCCOB3_0       *(unsigned long *)(FTFL_BLOCK + 0x04)    // long word address
    #define FTFL_FCCOB3         *(unsigned char *)(FTFL_BLOCK + 0x04)    // Flash Common Command Object Registers
    #define FTFL_FCCOB2         *(unsigned char *)(FTFL_BLOCK + 0x05)    // Flash Common Command Object Registers
    #define FTFL_FCCOB1         *(unsigned char *)(FTFL_BLOCK + 0x06)    // Flash Common Command Object Registers
    #define FTFL_FCCOB0         *(unsigned char *)(FTFL_BLOCK + 0x07)    // Flash Common Command Object Registers
      #define FCMD_READ_1S_BLOCK              0x00
      #define FCMD_READ_1S_SECTION            0x01
      #define FCMD_PROGRAM_CHECK              0x02
      #define FCMD_READ_RESOURCE              0x03
        #if defined PHRASE_PROGRAMMING_METHOD
      #define FCMD_PROGRAM_PHRASE             0x07                       // program 8 bytes phrase
      #define FCMD_PROGRAM                    FCMD_PROGRAM_PHRASE
        #else
      #define FCMD_PROGRAM_LONG_WORD          0x06                       // program a long word
      #define FCMD_PROGRAM                    FCMD_PROGRAM_LONG_WORD
        #endif
      #define FCMD_ERASE_FLASH_BLOCK          0x08
      #define FCMD_ERASE_FLASH_SECTOR         0x09
      #define FCMD_PROGRAM_SECTOR             0x0b
      #define FCMD_READ_1S_ALL_BLOCKS         0x40
      #define FCMD_READ_ONCE                  0x41
      #define FCMD_PROGRAM_ONCE               0x43
      #define FCMD_ERASE_ALL_BLOCKS           0x44
      #define FCMD_VERIFY_BACKDOOR_ACCESS_KEY 0x45
      #define FCMD_SWAP                       0x46
      #define FCMD_PROGRAM_PARTITION          0x80
      #define FCMD_SET_FLEXRAM_FUNCTION       0x81
    #define FTFL_FCCOB7_4       *(unsigned long *)(FTFL_BLOCK + 0x08)    // long word access
    #define FTFL_FCCOB7         *(unsigned char *)(FTFL_BLOCK + 0x08)    // Flash Common Command Object Registers
    #define FTFL_FCCOB6         *(unsigned char *)(FTFL_BLOCK + 0x09)    // Flash Common Command Object Registers
    #define FTFL_FCCOB5         *(unsigned char *)(FTFL_BLOCK + 0x0a)    // Flash Common Command Object Registers
    #define FTFL_FCCOB4         *(unsigned char *)(FTFL_BLOCK + 0x0b)    // Flash Common Command Object Registers
    #define FTFL_FCCOBB_8       *(unsigned long *)(FTFL_BLOCK + 0x0c)    // long word access
    #define FTFL_FCCOBB         *(unsigned char *)(FTFL_BLOCK + 0x0c)    // Flash Common Command Object Registers
    #define FTFL_FCCOBA         *(unsigned char *)(FTFL_BLOCK + 0x0d)    // Flash Common Command Object Registers
    #define FTFL_FCCOB9         *(unsigned char *)(FTFL_BLOCK + 0x0e)    // Flash Common Command Object Registers
    #define FTFL_FCCOB8         *(unsigned char *)(FTFL_BLOCK + 0x0f)    // Flash Common Command Object Registers
    #define FTFL_FPROT3_0       *(unsigned long *)(FTFL_BLOCK + 0x10)    // long word access
    #define FTFL_FPROT3         *(unsigned char *)(FTFL_BLOCK + 0x10)    // Program Flash Protection Register
    #define FTFL_FPROT2         *(unsigned char *)(FTFL_BLOCK + 0x11)    // Program Flash Protection Register
    #define FTFL_FPROT1         *(unsigned char *)(FTFL_BLOCK + 0x12)    // Program Flash Protection Register
    #define FTFL_FPROT0         *(unsigned char *)(FTFL_BLOCK + 0x13)    // Program Flash Protection Register
    #define FTFL_FEPROT         *(unsigned char *)(FTFL_BLOCK + 0x16)    // Eprom Protection Register
    #define FTFL_FDPROT         *(unsigned char *)(FTFL_BLOCK + 0x17)    // Data Flash Protection Register

    #define FLASH_STATUS_REGISTER     FTFL_BLOCK

    // Swap instructions
    //
    #define SWAP_CONTROL_CODE_INITIALISE_SWAP_SYSTEM     0x01
    #define SWAP_CONTROL_CODE_SET_SWAP_IN_UPDATE_STATE   0x02
    #define SWAP_CONTROL_CODE_SET_SWAP_IN_COMPLETE_STATE 0x04
    #define SWAP_CONTROL_CODE_REPORT_SWAP_STATUS         0x08

    // Swap states
    //
    #define CURRENT_SWAP_MODE_UNINITIALISED              0x00
    #define CURRENT_SWAP_MODE_READY                      0x01
    #define CURRENT_SWAP_MODE_UPDATE                     0x02
    #define CURRENT_SWAP_MODE_UPDATE_ERASED              0x03
    #define CURRENT_SWAP_MODE_COMPLETE                   0x04

    // Swap block status
    //
    #define CURRENT_SWAP_BLOCK_IS_0                      0x00
    #define CURRENT_SWAP_BLOCK_IS_1                      0x01

    // Swap block status
    //
    #define NEXT_SWAP_BLOCK_WILL_BE_0                    0x00
    #define NEXT_SWAP_BLOCK_WILL_BE_1                    0x01
#endif

typedef struct _PACK stBOOT_ROM_CONFIGURATION                            // loaded from FLASH 0x000003c0 at reset
{
    unsigned char  ucTag[4];                                             // magic number "kcfg"
    unsigned char  ucRes0[4];
    unsigned char  ucRes1[4];
    unsigned char  ucRes2[4];
    unsigned char  ucEnabledPeripherals;
    unsigned char  ucI2C_slave_address;
    unsigned char  ucPeripheralDetectionTimeout[2];
    unsigned char  ucUSB_VID[2];
    unsigned char  ucUSB_PID[2];
    unsigned char  ucUSB_strings_pointer[4];
    unsigned char  ucClockFlags;
    unsigned char  ucClockDivider;
    unsigned char  ucPadByte;
    unsigned char  ucRes3[4];
    unsigned char  ucPad[29];
} BOOT_ROM_CONFIGURATION;

typedef struct _PACK stKINETIS_FLASH_CONFIGURATION                       // loaded from FLASH 0x00000400 at reset
{
    unsigned char  ucBackdoorComparisonKey[8];
    #if defined KINETIS_KE                                               // {81}
    unsigned long  ulReserved;
    unsigned char  ucEEPROM_protection;
    unsigned char  ucProgramFlashProtection;
    unsigned char  ucFlashSecurity;
    unsigned char  ucNonvolatileOption;
    #else
    unsigned long  ulProgramFlashProtection;                             // {67}
    unsigned char  ucFlashSecurity;
    unsigned char  ucNonvolatileOption;
    unsigned char  ucEEPROM_protection;
    unsigned char  ucDataFlashProtection;
    #endif
} KINETIS_FLASH_CONFIGURATION;

typedef struct stRESET_VECTOR_VALIDATION                                 // {20}
{
    void  *ptrResetSP;                                                   // initial stack pointer
    void  (*ptrResetPC)(void);                                           // initial program counter
    unsigned long ulValSupport[2];                                       // signal that val. supported
    unsigned long ulValidated[2];                                        // space for validation programming
#if defined _GNU && !defined _BM_BUILD
    unsigned long ulEmpty[250];
    KINETIS_FLASH_CONFIGURATION flash_congiguration;
#endif    
} RESET_VECTOR_VALIDATION;


extern int fnProgramOnce(int iCommand, unsigned long *ptrBuffer, unsigned char ucBlockNumber, unsigned char ucLength);
    #define PROGRAM_ONCE_READ    0
    #define PROGRAM_ONCE_WRITE   1

// DMAMUX 0
//
#define DMAMUX0_CHCFG_ADD   (unsigned char *)(DMAMUX0_BLOCK + 0x00)
#define DMAMUX0_CHCFG0     *(unsigned char *)(DMAMUX0_BLOCK + 0x00)      // Channel 0 Configuration Register
  #define DMAMUX_CHCFG_SOURCE_DISABLED       0                           // 0x00
#if defined KINETIS_K66
  #define DMAMUX_CHCFG_SOURCE_TSI0           1                           // 0x01 TSI0
#endif
  #define DMAMUX_CHCFG_SOURCE_UART0_RX       2                           // 0x02 UART0 RX - DMAMUX_CHCFG_xx are available on DMA MUX 0 and on DMA MUX 1 (when available)
  #define DMAMUX_CHCFG_SOURCE_UART0_TX       3                           // 0x03 UART0 TX
  #define DMAMUX_CHCFG_SOURCE_UART1_RX       4                           // 0x04 UART1 RX
  #define DMAMUX_CHCFG_SOURCE_UART1_TX       5                           // 0x05 UART1 TX
  #define DMAMUX_CHCFG_SOURCE_UART2_RX       6                           // 0x06 UART2 RX
  #define DMAMUX_CHCFG_SOURCE_UART2_TX       7                           // 0x07 UART2 TX
  #define DMAMUX_CHCFG_SOURCE_UART3_RX       8                           // 0x08 UART3 RX
  #define DMAMUX_CHCFG_SOURCE_UART3_TX       9                           // 0x09 UART3 TX
#if defined KINETIS_K21 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_K64 || defined KINETIS_K66 || defined KINETIS_K80 || defined KINETIS_KV30
  #define DMAMUX_CHCFG_SOURCE_UART4_TX       10                          // 0x0a UART4 TX or RX
  #define DMAMUX_CHCFG_SOURCE_UART5_TX       11                          // 0x0b UART5 TX or RX
  #define DMAMUX_CHCFG_SOURCE_I2S0_RX        12                          // 0x0c I2S0 RX
  #define DMAMUX_CHCFG_SOURCE_I2S0_TX        13                          // 0x0d I2S0 TX
  #define DMAMUX_CHCFG_SOURCE_SPI0_RX        14                          // 0x0e SPI0 RX
  #define DMAMUX_CHCFG_SOURCE_SPI0_TX        15                          // 0x0f SPI0 TX
    #if defined KINETIS_K66 || defined KINETIS_K80
  #define DMAMUX_CHCFG_SOURCE_SPI1_RX        16                          // 0x10 SPI1 RX
  #define DMAMUX_CHCFG_SOURCE_SPI1_TX        17                          // 0x11 SPI2 TX
  #define DMAMUX0_CHCFG_SOURCE_I2C0_3        18                          // 0x12 I2C0 (or I2C3)
  #define DMAMUX0_CHCFG_SOURCE_I2C1_2        19                          // 0x13 I2C1 (or I2C2)
    #else
  #define DMAMUX_CHCFG_SOURCE_SPI1_TX        16                          // 0x10 SPI1 TX or RX
  #define DMAMUX_CHCFG_SOURCE_SPI2_TX        17                          // 0x11 SPI2 TX or RX
  #define DMAMUX0_CHCFG_SOURCE_I2C0          18                          // 0x12 I2C0 - DMAMUX0_CHCFG_xx are only available on DMA MUX 0
  #define DMAMUX0_CHCFG_SOURCE_I2C1_2        19                          // 0x13 I2C1 (or I2C2)
    #endif
  #define DMAMUX_CHCFG_SOURCE_FTM0_C0        20                          // 0x14 FTM0 channel 0
  #define DMAMUX_CHCFG_SOURCE_FTM0_C1        21                          // 0x15 FTM0 channel 1
  #define DMAMUX_CHCFG_SOURCE_FTM0_C2        22                          // 0x16 FTM0 channel 2
  #define DMAMUX_CHCFG_SOURCE_FTM0_C3        23                          // 0x17 FTM0 channel 3
  #define DMAMUX_CHCFG_SOURCE_FTM0_C4        24                          // 0x18 FTM0 channel 4
  #define DMAMUX_CHCFG_SOURCE_FTM0_C5        25                          // 0x19 FTM0 channel 5
  #define DMAMUX_CHCFG_SOURCE_FTM0_C6        26                          // 0x1a FTM0 channel 6
  #define DMAMUX_CHCFG_SOURCE_FTM0_C7        27                          // 0x1b FTM0 channel 7
  #define DMAMUX0_CHCFG_SOURCE_FTM1_C0       28                          // 0x1c FTM1 channel 0
  #define DMAMUX0_CHCFG_SOURCE_FTM1_C1       29                          // 0x1d FTM1 channel 1
  #define DMAMUX0_CHCFG_SOURCE_FTM2_C0       30                          // 0x1e FTM2 channel 0
  #define DMAMUX0_CHCFG_SOURCE_FTM2_C1       31                          // 0x1f FTM2 channel 1
  #define DMAMUX_CHCFG_SOURCE_FTM3_C0        32                          // 0x20 FTM0 channel 0
  #define DMAMUX_CHCFG_SOURCE_FTM3_C1        33                          // 0x21 FTM0 channel 1
  #define DMAMUX_CHCFG_SOURCE_FTM3_C2        34                          // 0x22 FTM0 channel 2
  #define DMAMUX_CHCFG_SOURCE_FTM3_C3        35                          // 0x23 FTM0 channel 3
  #define DMAMUX_CHCFG_SOURCE_FTM3_C4        36                          // 0x24 FTM0 channel 4
  #define DMAMUX_CHCFG_SOURCE_FTM3_C5        37                          // 0x25 FTM0 channel 5
  #define DMAMUX_CHCFG_SOURCE_FTM3_C6        38                          // 0x26 FTM0 channel 6
  #define DMAMUX_CHCFG_SOURCE_FTM3_C7        39                          // 0x27 FTM0 channel 7
#else
  #define DMAMUX_CHCFG_SOURCE_UART4_RX       10                          // 0x0a UART4 RX
  #define DMAMUX_CHCFG_SOURCE_UART4_TX       11                          // 0x0b UART4 TX
  #define DMAMUX_CHCFG_SOURCE_UART5_RX       12                          // 0x0c UART5 RX
  #define DMAMUX_CHCFG_SOURCE_UART5_TX       13                          // 0x0d UART5 TX
  #define DMAMUX_CHCFG_SOURCE_I2S0_RX        14                          // 0x0e I2S0 RX
  #define DMAMUX_CHCFG_SOURCE_I2S0_TX        15                          // 0x0f I2S0 TX
  #define DMAMUX_CHCFG_SOURCE_SPI0_RX        16                          // 0x10 SPI0 RX
  #define DMAMUX_CHCFG_SOURCE_SPI0_TX        17                          // 0x11 SPI0 TX
  #define DMAMUX_CHCFG_SOURCE_SPI1_RX        18                          // 0x12 SPI1 RX
  #define DMAMUX_CHCFG_SOURCE_SPI1_TX        19                          // 0x13 SPI1 TX
  #define DMAMUX_CHCFG_SOURCE_SPI2_RX        20                          // 0x14 SPI2 RX
  #define DMAMUX_CHCFG_SOURCE_SPI2_TX        21                          // 0x15 SPI2 TX
  #define DMAMUX0_CHCFG_SOURCE_I2C0          22                          // 0x16 I2C0 - DMAMUX0_CHCFG_xx are only available on DMA MUX 0
  #define DMAMUX0_CHCFG_SOURCE_I2C1_2        23                          // 0x17 I2C1 (or I2C2)
  #define DMAMUX_CHCFG_SOURCE_FTM0_C0        24                          // 0x18 FTM0/TPM0 channel 0
  #define DMAMUX_CHCFG_SOURCE_FTM0_C1        25                          // 0x19 FTM0/TPM0 channel 1
  #define DMAMUX_CHCFG_SOURCE_FTM0_C2        26                          // 0x1a FTM0/TPM0 channel 2
  #define DMAMUX_CHCFG_SOURCE_FTM0_C3        27                          // 0x1b FTM0/TPM0 channel 3
  #define DMAMUX_CHCFG_SOURCE_FTM0_C4        28                          // 0x1c FTM0/TPM0 channel 4
  #define DMAMUX_CHCFG_SOURCE_FTM0_C5        29                          // 0x1d FTM0/TPM0 channel 5
  #define DMAMUX_CHCFG_SOURCE_FTM0_C6        30                          // 0x1e FTM0/TPM0 channel 6
  #define DMAMUX_CHCFG_SOURCE_FTM0_C7        31                          // 0x1f FTM0/TPM0 channel 7
  #define DMAMUX0_CHCFG_SOURCE_FTM1_C0       32                          // 0x20 FTM1/TPM1 channel 0
  #define DMAMUX0_CHCFG_SOURCE_FTM1_C1       33                          // 0x21 FTM1/TPM1 channel 1
  #define DMAMUX0_CHCFG_SOURCE_FTM2_C0       34                          // 0x22 FTM2/TPM2 channel 0
  #define DMAMUX0_CHCFG_SOURCE_FTM2_C1       35                          // 0x23 FTM2/TPM2 channel 1
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T0    36                          // 0x24 IEEE 1588 timer 0 (alternative)
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C1       36                          // 0x24 FTM3 channel 1
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T1    37                          // 0x25 IEEE 1588 timer 1 (alternative)
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C2       37                          // 0x25 FTM3 channel 2
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T2    38                          // 0x26 IEEE 1588 timer 2 (alternative)
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C3       38                          // 0x26 FTM3 channel 3
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T3    39                          // 0x27 IEEE 1588 timer 3 (alternative)
 #endif
  #define DMAMUX_CHCFG_SOURCE_ADC0           40                          // 0x28 ADC0
  #define DMAMUX_CHCFG_SOURCE_ADC1           41                          // 0x29 ADC1
  #define DMAMUX0_CHCFG_SOURCE_CMP0          42                          // 0x2a CMP0
  #define DMAMUX0_CHCFG_SOURCE_CMP1          43                          // 0x2b CMP1
  #define DMAMUX0_CHCFG_SOURCE_CMP2          44                          // 0x2c CMP2
  #define DMAMUX_CHCFG_SOURCE_DAC0           45                          // 0x2d DAC0
  #define DMAMUX_CHCFG_SOURCE_DAC1           46                          // 0x2e DAC1
  #define DMAMUX0_CHCFG_SOURCE_CMT           47                          // 0x2f CMT
  #define DMAMUX0_CHCFG_SOURCE_PDB           48                          // 0x30 PDB
  #define DMAMUX0_CHCFG_SOURCE_PORTA         49                          // 0x31 port A
  #define DMAMUX0_CHCFG_SOURCE_PORTB         50                          // 0x32 port B
  #define DMAMUX0_CHCFG_SOURCE_PORTC         51                          // 0x33 port C
  #define DMAMUX0_CHCFG_SOURCE_PORTD         52                          // 0x34 port D
  #define DMAMUX0_CHCFG_SOURCE_PORTE         53                          // 0x35 port E
#if defined KINETIS_K64 || defined KINETIS_K66
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T0    54                          // 0x36 IEEE 1588 timer 0
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T1    55                          // 0x37 IEEE 1588 timer 1 (or)
  #define DMAMUX0_CHCFG_SOURCE_TPM1_OVERFLOW 55                          // 0x37 TPM1 overflow
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T2    56                          // 0x38 IEEE 1588 timer 2 (or)
  #define DMAMUX0_CHCFG_SOURCE_TPM2_OVERFLOW 56                          // 0x38 TPM2 overflow
  #define DMAMUX_CHCFG_SOURCE_IEEE1588_T3    57                          // 0x39 IEEE 1588 timer 3
#elif defined KINETIS_KL
  #define DMAMUX0_CHCFG_SOURCE_TPM0_OVERFLOW 54                          // 0x36 TPM0 overflow
  #define DMAMUX0_CHCFG_SOURCE_TPM1_OVERFLOW 55                          // 0x37 TPM1 overflow
  #define DMAMUX0_CHCFG_SOURCE_TPM2_OVERFLOW 56                          // 0x38 TPM2 overflow
  #define DMAMUX0_CHCFG_SOURCE_TSI           57                          // 0x39 TSI
#elif !defined KINETIS_K21
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C4       54                          // 0x36 FTM3 channel 4
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C5       55                          // 0x37 FTM3 channel 5
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C6       56                          // 0x38 FTM3 channel 6
  #define DMAMUX0_CHCFG_SOURCE_FTM3_C7       57                          // 0x39 FTM3 channel 7
#endif
#if defined KINETIS_K80
  #define DMAMUX0_CHCFG_SOURCE_SPI2_RX       (58)                        // 0x3a SPI2 RX
  #define DMAMUX0_CHCFG_SOURCE_SPI2_TX       (59)                        // 0x3b SPI2 TX
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX0       (60 | DMAMUX_CHCFG_TRIG)    // 0x3c DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX1       (61 | DMAMUX_CHCFG_TRIG)    // 0x3d DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX2       (62 | DMAMUX_CHCFG_TRIG)    // 0x3e DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX3       (63 | DMAMUX_CHCFG_TRIG)    // 0x3f DMA MUX - always enable
  // For compatibility
  //
  #define DMAMUX0_CHCFG_SOURCE_LPUART0_RX    DMAMUX_CHCFG_SOURCE_UART0_RX
  #define DMAMUX0_CHCFG_SOURCE_LPUART0_TX    DMAMUX_CHCFG_SOURCE_UART0_TX
  #define DMAMUX0_CHCFG_SOURCE_LPUART1_RX    DMAMUX_CHCFG_SOURCE_UART1_RX
  #define DMAMUX0_CHCFG_SOURCE_LPUART1_TX    DMAMUX_CHCFG_SOURCE_UART1_TX
  #define DMAMUX0_CHCFG_SOURCE_LPUART2_RX    DMAMUX_CHCFG_SOURCE_UART2_RX
  #define DMAMUX0_CHCFG_SOURCE_LPUART2_TX    DMAMUX_CHCFG_SOURCE_UART2_TX
  #define DMAMUX0_CHCFG_SOURCE_LPUART3_RX    DMAMUX_CHCFG_SOURCE_UART3_RX
  #define DMAMUX0_CHCFG_SOURCE_LPUART3_TX    DMAMUX_CHCFG_SOURCE_UART3_TX
  #define DMAMUX0_CHCFG_SOURCE_LPUART4_RX    DMAMUX_CHCFG_SOURCE_UART4_RX
  #define DMAMUX0_CHCFG_SOURCE_LPUART4_TX    DMAMUX_CHCFG_SOURCE_UART4_TX
#elif LPUARTS_AVAILABLE > 0
  #define DMAMUX0_CHCFG_SOURCE_LPUART0_RX    58                          // 0x3a LPUART0 RX
  #define DMAMUX0_CHCFG_SOURCE_LPUART0_TX    59                          // 0x3b LPUART0 TX
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX0       (60 | DMAMUX_CHCFG_TRIG)    // 0x3c DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX1       (61 | DMAMUX_CHCFG_TRIG)    // 0x3d DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX2       (62 | DMAMUX_CHCFG_TRIG)    // 0x3e DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX3       (63 | DMAMUX_CHCFG_TRIG)    // 0x3f DMA MUX - always enabled
#else
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX0       (58 | DMAMUX_CHCFG_TRIG)    // 0x3a DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX1       (59 | DMAMUX_CHCFG_TRIG)    // 0x3b DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX2       (60 | DMAMUX_CHCFG_TRIG)    // 0x3c DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX3       (61 | DMAMUX_CHCFG_TRIG)    // 0x3d DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX4       (62 | DMAMUX_CHCFG_TRIG)    // 0x3e DMA MUX - always enabled
  #define DMAMUX0_CHCFG_SOURCE_DMAMUX5       (63 | DMAMUX_CHCFG_TRIG)    // 0x3f DMA MUX - always enabled
#endif
  #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT0    (DMAMUX0_CHCFG_SOURCE_DMAMUX0)
  #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT1    (DMAMUX0_CHCFG_SOURCE_DMAMUX1)
  #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT2    (DMAMUX0_CHCFG_SOURCE_DMAMUX2)
  #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT3    (DMAMUX0_CHCFG_SOURCE_DMAMUX3)
  #define DMAMUX_CHCFG_TRIG                  0x40                        // DMA channel trigger enable
  #define DMAMUX_CHCFG_ENBL                  0x80                        // DMA channel enable
#define DMAMUX0_CHCFG1     *(unsigned char *)(DMAMUX0_BLOCK + 0x01)      // Channel 1 Configuration Register
#define DMAMUX0_CHCFG2     *(unsigned char *)(DMAMUX0_BLOCK + 0x02)      // Channel 2 Configuration Register
#define DMAMUX0_CHCFG3     *(unsigned char *)(DMAMUX0_BLOCK + 0x03)      // Channel 3 Configuration Register
#if !defined KINETIS_KL
    #define DMAMUX0_CHCFG4     *(unsigned char *)(DMAMUX0_BLOCK + 0x04)  // Channel 4 Configuration Register
    #define DMAMUX0_CHCFG5     *(unsigned char *)(DMAMUX0_BLOCK + 0x05)  // Channel 5 Configuration Register
    #define DMAMUX0_CHCFG6     *(unsigned char *)(DMAMUX0_BLOCK + 0x06)  // Channel 6 Configuration Register
    #define DMAMUX0_CHCFG7     *(unsigned char *)(DMAMUX0_BLOCK + 0x07)  // Channel 7 Configuration Register
    #define DMAMUX0_CHCFG8     *(unsigned char *)(DMAMUX0_BLOCK + 0x08)  // Channel 8 Configuration Register
    #define DMAMUX0_CHCFG9     *(unsigned char *)(DMAMUX0_BLOCK + 0x09)  // Channel 9 Configuration Register
    #define DMAMUX0_CHCFG10    *(unsigned char *)(DMAMUX0_BLOCK + 0x0a)  // Channel 10 Configuration Register
    #define DMAMUX0_CHCFG11    *(unsigned char *)(DMAMUX0_BLOCK + 0x0b)  // Channel 11 Configuration Register
    #define DMAMUX0_CHCFG12    *(unsigned char *)(DMAMUX0_BLOCK + 0x0c)  // Channel 12 Configuration Register
    #define DMAMUX0_CHCFG13    *(unsigned char *)(DMAMUX0_BLOCK + 0x0d)  // Channel 13 Configuration Register
    #define DMAMUX0_CHCFG14    *(unsigned char *)(DMAMUX0_BLOCK + 0x0e)  // Channel 14 Configuration Register
    #define DMAMUX0_CHCFG15    *(unsigned char *)(DMAMUX0_BLOCK + 0x0f)  // Channel 15 Configuration Register
#endif

// DMAMUX 1
//
#if defined DMAMUX1_AVAILABLE
    #define DMAMUX1_CHCFG_ADD   (unsigned char *)(DMAMUX1_BLOCK + 0x00)
    #define DMAMUX1_CHCFG0     *(unsigned char *)(DMAMUX1_BLOCK + 0x00)  // Channel 0 Configuration Register
      #define DMAMUX1_CHCFG_SOURCE_ADC2          42                      // 0x2a ADC2 - DMAMUX1_CHCFG_xx are only available on DMA MUX 1
      #define DMAMUX1_CHCFG_SOURCE_ADC3          43                      // 0x2b ADC3
      #define DMAMUX1_CHCFG_SOURCE_CMP0          47                      // 0x2f CMP0
      #define DMAMUX1_CHCFG_SOURCE_CMP1          48                      // 0x30 CMP1
      #define DMAMUX1_CHCFG_SOURCE_CMP2          49                      // 0x31 CMP2
      #define DMAMUX1_CHCFG_SOURCE_CMP3          50                      // 0x32 CMP2
      #define DMAMUX1_CHCFG_SOURCE_PORTF         53                      // 0x35 port F
    #define DMAMUX1_CHCFG1     *(unsigned char *)(DMAMUX1_BLOCK + 0x01)  // Channel 1 Configuration Register
    #define DMAMUX1_CHCFG2     *(unsigned char *)(DMAMUX1_BLOCK + 0x02)  // Channel 2 Configuration Register
    #define DMAMUX1_CHCFG3     *(unsigned char *)(DMAMUX1_BLOCK + 0x03)  // Channel 3 Configuration Register
    #define DMAMUX1_CHCFG4     *(unsigned char *)(DMAMUX1_BLOCK + 0x04)  // Channel 4 Configuration Register
    #define DMAMUX1_CHCFG5     *(unsigned char *)(DMAMUX1_BLOCK + 0x05)  // Channel 5 Configuration Register
    #define DMAMUX1_CHCFG6     *(unsigned char *)(DMAMUX1_BLOCK + 0x06)  // Channel 6 Configuration Register
    #define DMAMUX1_CHCFG7     *(unsigned char *)(DMAMUX1_BLOCK + 0x07)  // Channel 7 Configuration Register
    #define DMAMUX1_CHCFG8     *(unsigned char *)(DMAMUX1_BLOCK + 0x08)  // Channel 8 Configuration Register
    #define DMAMUX1_CHCFG9     *(unsigned char *)(DMAMUX1_BLOCK + 0x09)  // Channel 9 Configuration Register
    #define DMAMUX1_CHCFG10    *(unsigned char *)(DMAMUX1_BLOCK + 0x0a)  // Channel 10 Configuration Register
    #define DMAMUX1_CHCFG11    *(unsigned char *)(DMAMUX1_BLOCK + 0x0b)  // Channel 11 Configuration Register
    #define DMAMUX1_CHCFG12    *(unsigned char *)(DMAMUX1_BLOCK + 0x0c)  // Channel 12 Configuration Register
    #define DMAMUX1_CHCFG13    *(unsigned char *)(DMAMUX1_BLOCK + 0x0d)  // Channel 13 Configuration Register
    #define DMAMUX1_CHCFG14    *(unsigned char *)(DMAMUX1_BLOCK + 0x0e)  // Channel 14 Configuration Register
    #define DMAMUX1_CHCFG15    *(unsigned char *)(DMAMUX1_BLOCK + 0x0f)  // Channel 15 Configuration Register
#endif


// I2S (SAI - Synchronous Audio Interface)
//
#if defined I2S_AVAILABLE                                                // {73}
    #define I2S0_TCSR          *(volatile unsigned long *)(I2S0_BLOCK + 0x000)    // I2S0 transmit control register
        #define I2S_TCSR_FWDE  0x00000002                                // FIFO warning DMA enable
        #define I2S_TCSR_FWIE  0x00000200                                // FIFO warning interrupt enable
        #define I2S_TCSR_FEIE  0x00000400                                // FIFO error interrupt enable
        #define I2S_TCSR_WSIE  0x00000800                                // word start interrupt enable
        #define I2S_TCSR_FWF   0x00020000                                // FIFO warning flag (read-only)
        #define I2S_TCSR_FEF   0x00040000                                // FIFO error flag (write '1' to clear)
        #define I2S_TCSR_SEF   0x00080000                                // sync error flag (write '1' to clear)
        #define I2S_TCSR_WSF   0x00100000                                // word start flag (write '1' to clear)
        #define I2S_TCSR_SR    0x01000000                                // software reset
        #define I2S_TCSR_FR    0x02000000                                // FIFO reset (reads always '0')
        #define I2S_TCSR_BCE   0x10000000                                // bit clock enable
        #define I2S_TCSR_DBGE  0x20000000                                // debug enable
        #define I2S_TCSR_STOPE 0x40000000                                // stop enable
        #define I2S_TCSR_TE    0x80000000                                // transmitter enable
    #define I2S0_TCR2          *(unsigned long *)(I2S0_BLOCK + 0x008)    // I2S0 transmit configuration 2 register
        #define I2S_TCR2_DIV_MASK        0x000000ff                      // bit clock divide mask ((DIV + 1) * 2)
        #define I2S_TCR2_BCD_EXT_SLAVE   0x00000000                      // bit clock direction - generated externally in slave mode
        #define I2S_TCR2_BCD_INT_MASTER  0x01000000                      // bit clock direction - generated internally in master mode
        #define I2S_TCR2_BCP_ACT_HIGH    0x00000000                      // bit clock polarity - active high [drive outputs on rising edge and sample inputs on falling edge]
        #define I2S_TCR2_BCP_ACT_LOW     0x02000000                      // bit clock polarity - active low [drive outputs on falling edge and sample inputs on rising edge]
        #define I2S_TCR2_MSEL_BUS        0x00000000                      // MCLK select - bus clock selected
        #define I2S_TCR2_MSEL1           0x04000000                      // MCLK select - master clock 1 option
        #define I2S_TCR2_MSEL2           0x08000000                      // MCLK select - master clock 2 option
        #define I2S_TCR2_MSEL3           0x0c000000                      // MCLK select - master clock 3 option
        #define I2S_TCR2_BCI             0x10000000                      // bit clock input
        #define I2S_TCR2_BCS             0x20000000                      // bit clock swap
        #define I2S_TCR2_SYNC_ASYN       0x00000000                      // asynchronous mode
        #define I2S_TCR2_SYNC_SYN_RX     0x40000000                      // synchronous with receiver
        #define I2S_TCR2_SYNC_SYN_SAI_TX 0x80000000                      // synchronous with another SAI transmitter
        #define I2S_TCR2_SYNC_SYN_SAI_RX 0xc0000000                      // synchronous with another SAI receiver
    #define I2S0_TCR3          *(unsigned long *)(I2S0_BLOCK + 0x00c)    // I2S0 transmit configuration 3 register
        #define I2S_TCR3_WDFL_FIRST      0x00000000                      // word flag configuration - first in frame
        #define I2S_TCR3_WDFL_SECOND     0x00000001                      // word flag configuration - second in frame
        #define I2S_TCR3_TCE             0x00010000                      // transmit channel enable
    #define I2S0_TCR4          *(unsigned long *)(I2S0_BLOCK + 0x010)    // I2S0 transmit configuration 4 register
        #define I2S_TCR4_FSD_EXT_SLAVE   0x00000000                      // frame sync direction - generated externally (slave)
        #define I2S_TCR4_FSD_INT_MASTER  0x00000001                      // frame sync direction - generated internally (master)
        #define I2S_TCR4_FSP_LOW         0x00000000                      // frame sync polarity - active low
        #define I2S_TCR4_FSP_HIGH        0x00000002                      // frame sync polarity - active high
        #define I2S_TCR4_ONDEM           0x00000004                      // on demand mode
        #define I2S_TCR4_FSE             0x00000008                      // frame sync early
        #define I2S_TCR4_MF_LSB          0x00000000                      // LSB first
        #define I2S_TCR4_MF_MSB          0x00000010                      // MSB first
        #define I2S_TCR4_SYWD_MASK       0x00001f00                      // synch width (bits - 1)
        #define I2S_TCR4_SYWD_SHIFT      8
        #define I2S_TCR4_FRSZ_1          0x00000000                      // frame size one word
        #define I2S_TCR4_FRSZ_2          0x00010000                      // frame size two word
        #define I2S_TCR4_FPACK_OFF       0x00000000                      // FIFO packing mode - FIFO packing disabled
        #define I2S_TCR4_FPACK_8         0x02000000                      // FIFO packing mode - 8-bit FIFO packing enabled
        #define I2S_TCR4_FPACK_16        0x03000000                      // FIFO packing mode - 16-bit FIFO packing enabled
        #define I2S_TCR4_FCONT           0x10000000                      // FIFO continue on error
    #define I2S0_TCR5          *(unsigned long *)(I2S0_BLOCK + 0x014)    // I2S0 transmit configuration 5 register
        #define I2S_TCR5_FBT_MASK        0x00001f00                      // first bit shifted mask
        #define I2S_TCR5_FBT_SHIFT       8
        #define I2S_TCR5_W0W_MASK        0x001f0000                      // word 0 width mask
        #define I2S_TCR5_W0W_SHIFT       16
        #define I2S_TCR5_WNW_MASK        0x1f000000                      // word N width
        #define I2S_TCR5_WNW_SHIFT       24
    #define I2S0_TDR0          *(volatile unsigned long *)(I2S0_BLOCK + 0x020) // I2S0 transmit data register (write-only - always reads 0)
    #define I2S0_TMR           *(unsigned long *)(I2S0_BLOCK + 0x060)    // I2S0 transmit mask register
        #define I2S_TMR_CH0_MASK         0x00000001                      // word 0 is masked (not copied to FIFO)
        #define I2S_TMR_CH1_MASK         0x00000002                      // word 1 is masked (not copied to FIFO)
    #define I2S0_RCSR          *(volatile unsigned long *)(I2S0_BLOCK + 0x080) // I2S0 receive control register
        #define I2S_RCSR_FWDE  0x00000002                                // FIFO warning DMA enable
        #define I2S_RCSR_FWIE  0x00000200                                // FIFO warning interrupt enable
        #define I2S_RCSR_FEIE  0x00000400                                // FIFO error interrupt enable
        #define I2S_RCSR_WSIE  0x00000800                                // word start interrupt enable
        #define I2S_RCSR_FWF   0x00020000                                // FIFO warning flag (read-only)
        #define I2S_RCSR_FEF   0x00040000                                // FIFO error flag (write '1' to clear)
        #define I2S_RCSR_SEF   0x00080000                                // sync error flag (write '1' to clear)
        #define I2S_RCSR_WSF   0x00100000                                // word start flag (write '1' to clear)
        #define I2S_RCSR_SR    0x01000000                                // software reset
        #define I2S_RCSR_FR    0x02000000                                // FIFO reset (reads always '0')
        #define I2S_RCSR_BCE   0x10000000                                // bit clock enable
        #define I2S_RCSR_DBGE  0x20000000                                // debug enable
        #define I2S_RCSR_STOPE 0x40000000                                // stop enable
        #define I2S_RCSR_RE    0x80000000                                // receiver enable
    #define I2S0_RCR2          *(unsigned long *)(I2S0_BLOCK + 0x088)    // I2S0 receive configuration 2 register
        #define I2S_RCR2_DIV_MASK        0x000000ff                      // bit clock divide mask ((DIV + 1) * 2)
        #define I2S_RCR2_BCD_EXT_SLAVE   0x00000000                      // bit clock direction - generated externally in slave mode
        #define I2S_RCR2_BCD_INT_MASTER  0x01000000                      // bit clock direction - generated internally in master mode
        #define I2S_RCR2_BCP_ACT_HIGH    0x00000000                      // bit clock polarity - active high [drive outputs on rising edge and sample inputs on falling edge]
        #define I2S_RCR2_BCP_ACT_LOW     0x02000000                      // bit clock polarity - active low [drive outputs on falling edge and sample inputs on rising edge]
        #define I2S_RCR2_MSEL_BUS        0x00000000                      // MCLK select - bus clock selected
        #define I2S_RCR2_MSEL1           0x04000000                      // MCLK select - master clock 1 option
        #define I2S_RCR2_MSEL2           0x08000000                      // MCLK select - master clock 2 option
        #define I2S_RCR2_MSEL3           0x0c000000                      // MCLK select - master clock 3 option
        #define I2S_RCR2_BCI             0x10000000                      // bit clock input
        #define I2S_RCR2_BCS             0x20000000                      // bit clock swap
        #define I2S_RCR2_SYNC_ASYN       0x00000000                      // asynchronous mode
        #define I2S_RCR2_SYNC_SYN_TX     0x40000000                      // synchronous with transmitter
        #define I2S_RCR2_SYNC_SYN_SAI_RX 0x80000000                      // synchronous with another SAI receiver
        #define I2S_RCR2_SYNC_SYN_SAI_TX 0xc0000000                      // synchronous with another SAI transmitter
    #define I2S0_RCR3          *(unsigned long *)(I2S0_BLOCK + 0x08c)    // I2S0 receive configuration 3 register
        #define I2S_RCR3_WDFL_FIRST      0x00000000                      // word flag configuration - first in frame
        #define I2S_RCR3_WDFL_SECOND     0x00000001                      // word flag configuration - second in frame
        #define I2S_RCR3_RCE             0x00010000                      // receive channel enable
    #define I2S0_RCR4          *(unsigned long *)(I2S0_BLOCK + 0x090)    // I2S0 receive configuration 4 register
        #define I2S_RCR4_FSD_EXT_SLAVE   0x00000000                      // frame sync direction - generated externally (slave)
        #define I2S_RCR4_FSD_INT_MASTER  0x00000001                      // frame sync direction - generated internally (master)
        #define I2S_RCR4_FSP_LOW         0x00000000                      // frame sync polarity - active low
        #define I2S_RCR4_FSP_HIGH        0x00000002                      // frame sync polarity - active high
        #define I2S_RCR4_ONDEM           0x00000004                      // on demand mode
        #define I2S_RCR4_FSE             0x00000008                      // frame sync early
        #define I2S_RCR4_MF_LSB          0x00000000                      // LSB first
        #define I2S_RCR4_MF_MSB          0x00000010                      // MSB first
        #define I2S_RCR4_SYWD_MASK       0x00001f00                      // synch width (bits - 1)
        #define I2S_RCR4_SYWD_SHIFT      8
        #define I2S_RCR4_FRSZ_1          0x00000000                      // frame size one word
        #define I2S_RCR4_FRSZ_2          0x00010000                      // frame size two word
        #define I2S_RCR4_FPACK_OFF       0x00000000                      // FIFO packing mode - FIFO packing disabled
        #define I2S_RCR4_FPACK_8         0x02000000                      // FIFO packing mode - 8-bit FIFO packing enabled
        #define I2S_RCR4_FPACK_16        0x03000000                      // FIFO packing mode - 16-bit FIFO packing enabled
        #define I2S_RCR4_FCONT           0x10000000                      // FIFO continue on error
    #define I2S0_RCR5          *(unsigned long *)(I2S0_BLOCK + 0x094)    // I2S0 receive configuration 5 register
        #define I2S_RCR5_FBT_MASK        0x00001f00                      // first bit shifted mask
        #define I2S_RCR5_FBT_SHIFT       8
        #define I2S_RCR5_W0W_MASK        0x001f0000                      // word 0 width mask
        #define I2S_RCR5_W0W_SHIFT       16
        #define I2S_RCR5_WNW_MASK        0x1f000000                      // word N width
        #define I2S_RCR5_WNW_SHIFT       24
    #define I2S0_RDR0          *(volatile unsigned long *)(I2S0_BLOCK + 0x0a0) // I2S0 receive data register (read-only)
    #define I2S0_RMR           *(unsigned long *)(I2S0_BLOCK + 0x0e0)    // I2S0 receive mask register
        #define I2S_RMR_CH0_MASK         0x00000001                      // word 0 is masked (not copied to FIFO)
        #define I2S_RMR_CH1_MASK         0x00000002                      // word 1 is masked (not copied to FIFO)
    #define I2S0_MCR           *(volatile unsigned long *)(I2S0_BLOCK + 0x100)    // I2S0 MCLK control register
        #define I2S_MCR_MICS_0  0x00000000                               // MCLK divider input clock 0 select
        #define I2S_MCR_MICS_1  0x01000000                               // MCLK divider input clock 1 select
        #define I2S_MCR_MICS_2  0x02000000                               // MCLK divider input clock 2 select
        #define I2S_MCR_MICS_3  0x03000000                               // MCLK divider input clock 3 select
        #define I2S_MCR_MOE_IN  0x00000000                               // MCLK is input (slave)
        #define I2S_MCR_MOE_OUT 0x40000000                               // MCLK output enable (master)
        #define I2S_MCR_DUF     0x80000000                               // divide update flag (read-only)

    typedef struct st_KINETIS_I2S_SAI                                    // I2S/SAI control struct
    {
    volatile unsigned long I2S_TCSR;
    unsigned long ulRes0;
    unsigned long I2S_TCR2;
    unsigned long I2S_TCR3;
    unsigned long I2S_TCR4;
    unsigned long I2S_TCR5;
    unsigned long ulRes1[2];
    volatile unsigned long I2S_TDR0;
    unsigned long ulRes2[15];
    unsigned long I2S_TMR;
    unsigned long ulRes3[7];
    volatile unsigned long I2S_RCSR;
    unsigned long ulRes4;
    unsigned long I2S_RCR2;
    unsigned long I2S_RCR3;
    unsigned long I2S_RCR4;
    unsigned long I2S_RCR5;
    unsigned long ulRes5[2];
    volatile unsigned long I2S_RDR0;
    unsigned long ulRes6[15];
    unsigned long I2S_RMR;
    unsigned long ulRes7[7];
    volatile unsigned long I2S_MCR;
    } _KINETIS_I2S_SAI;
#endif

#if defined KINETIS_KL || defined KINETIS_KE                             // KL and KE have SPI instead of DSPI
  #if defined KINETIS_KL26 || defined KINETIS_KL27 || defined KINETIS_KL43 || defined KINETIS_KL46 // KL devices supporting 16 bit words
    #define SPI0_S             *(volatile unsigned char *)(SPI0_BLOCK + 0x0) // SPI0 status register (read only)
    #if defined KINETIS_KL43
      #define SPI_S_RFIFOEF     0x01                                     // receive FIFO empty flag
    #else
      #define SPI_S_RXFULLF     0x01                                     // receive FIFO empty flag
    #endif
      #define SPI_S_TXFULLF     0x02                                     // transmit FIFO full flag
      #define SPI_S_TNEAREF     0x04                                     // transmit FIFO nearly empty flag
      #define SPI_S_RNFULLF     0x08                                     // receive FIFO nearly full flag
      #define SPI_S_MODF        0x10                                     // master mode fault flag
      #define SPI_S_SPTEF       0x20                                     // SPI transmit buffer empty flag
      #define SPI_S_SPMF        0x40                                     // SPI match flag
      #define SPI_S_SPRF        0x80                                     // SPI read buffer full flag
    #define SPI0_BR             *(unsigned char *)(SPI0_BLOCK + 0x1)     // SPI0 baud rate register
      #define SPI_BR_SPR_DIV_2   0x00                                    // baud rate divisor 2
      #define SPI_BR_SPR_DIV_4   0x01                                    // baud rate divisor 4
      #define SPI_BR_SPR_DIV_8   0x02                                    // baud rate divisor 8
      #define SPI_BR_SPR_DIV_16  0x03                                    // baud rate divisor 16
      #define SPI_BR_SPR_DIV_32  0x04                                    // baud rate divisor 32
      #define SPI_BR_SPR_DIV_64  0x05                                    // baud rate divisor 64
      #define SPI_BR_SPR_DIV_128 0x06                                    // baud rate divisor 128
      #define SPI_BR_SPR_DIV_256 0x07                                    // baud rate divisor 256
      #define SPI_BR_SPR_DIV_512 0x08                                    // baud rate divisor 512
      #define SPI_BR_SPPR_PRE_1  0x00                                    // baud rate prescaler divisor 1
      #define SPI_BR_SPPR_PRE_2 0x10                                     // baud rate prescaler divisor 2
      #define SPI_BR_SPPR_PRE_3 0x20                                     // baud rate prescaler divisor 3
      #define SPI_BR_SPPR_PRE_4 0x30                                     // baud rate prescaler divisor 4
      #define SPI_BR_SPPR_PRE_5 0x40                                     // baud rate prescaler divisor 5
      #define SPI_BR_SPPR_PRE_6 0x50                                     // baud rate prescaler divisor 6
      #define SPI_BR_SPPR_PRE_7 0x60                                     // baud rate prescaler divisor 7
      #define SPI_BR_SPPR_PRE_8 0x70                                     // baud rate prescaler divisor 8
    #define SPI0_C2             *(unsigned char *)(SPI0_BLOCK + 0x2)     // SPI0 control register 2
      #define SPI_C2_SPC0       0x01                                     // SPI pin control 0
      #define SPI_C2_SPISWAI    0x02                                     // SPI stop in wait mode
      #define SPI_C2_RXDMAE     0x04                                     // receive DMA enable
      #define SPI_C2_BIDIROE    0x08                                     // bi-directional mode output enable
      #define SPI_C2_MODFEN     0x10                                     // master mode-fault function enable
      #define SPI_C2_TXDMAE     0x20                                     // transmit DMA enable
      #define SPI_C2_SPIMODE_8  0x00                                     // 8 bit mode
      #define SPI_C2_SPIMODE_16 0x40                                     // 16 bit mode
      #define SPI_C2_SPMIE      0x80                                     // SPI match interrupt enable
    #define SPI0_C1             *(unsigned char *)(SPI0_BLOCK + 0x3)     // SPI0 control register 1
      #define SPI_C1_LSBFE      0x01                                     // LSB first
      #define SPI_C1_SSOE       0x02                                     // slave select output data
      #define SPI_C1_CPHA       0x04                                     // clock phase (first edge on SPCLK occurs at the start if the first cycle of data
      #define SPI_C1_CPOL       0x08                                     // clock polarity (idles high)
      #define SPI_C1_MSTR       0x10                                     // SPI master device
      #define SPI_C1_SPTIE      0x20                                     // SPI transmit interrupt enable
      #define SPI_C1_SPE        0x40                                     // SPI system enable
      #define SPI_C1_SPIE       0x80                                     // SPI interrupt enable
    #define SPI0_ML             *(unsigned char *)(SPI0_BLOCK + 0x4)     // SPI0 match register hlow
    #define SPI0_MH             *(unsigned char *)(SPI0_BLOCK + 0x5)     // SPI0 match register high
    #define SPI0_DL             *(volatile unsigned char *)(SPI0_BLOCK + 0x6) // SPI0 data register low
    #define SPI0_DH             *(volatile unsigned char *)(SPI0_BLOCK + 0x7) // SPI0 data register high

    #define SPI0_D              SPI0_DL                                  // for compatibility
    #if !defined KINETIS_KL43
        #define SPI0_CI         *(volatile unsigned char *)(SPI0_BLOCK + 0xa) // SPI0 clear interrupt register
        #define SPI0_C3         *(unsigned char *)(SPI0_BLOCK + 0xb)     // SPI0 control register 3
    #endif

    #define SPI1_S              *(volatile unsigned char *)(SPI1_BLOCK + 0x0) // SPI1 status register
    #define SPI1_BR             *(unsigned char *)(SPI1_BLOCK + 0x1)     // SPI1 baud rate register
    #define SPI1_C2             *(unsigned char *)(SPI1_BLOCK + 0x2)     // SPI1 control register 2
    #define SPI1_C1             *(unsigned char *)(SPI1_BLOCK + 0x3)     // SPI1 control register 1
    #define SPI1_ML             *(unsigned char *)(SPI1_BLOCK + 0x4)     // SPI1 match register hlow
    #define SPI1_MH             *(unsigned char *)(SPI1_BLOCK + 0x5)     // SPI1 match register high
    #define SPI1_DL             *(volatile unsigned char *)(SPI1_BLOCK + 0x6) // SPI1 data register low
    #define SPI1_DH             *(volatile unsigned char *)(SPI1_BLOCK + 0x7) // SPI1 data register high

    #define SPI1_D              SPI1_DL                                  // for compatibility

    #define SPI1_CI             *(unsigned char *)(SPI1_BLOCK + 0xa)     // SPI1 clear interrupt register
    #define SPI1_C3             *(unsigned char *)(SPI1_BLOCK + 0xb)     // SPI1 control register 3
  #elif defined KINETIS_KL03
    #define SPI0_S              *(volatile unsigned char *)(SPI0_BLOCK + 0x0) // SPI0 status register
      #define SPI_S_MODF        0x10                                     // master mode fault flag
      #define SPI_S_SPTEF       0x20                                     // SPI transmit buffer empty flag
      #define SPI_S_SPMF        0x40                                     // SPI match flag
      #define SPI_S_SPRF        0x80                                     // SPI read buffer full flag
    #define SPI0_BR             *(unsigned char *)(SPI0_BLOCK + 0x1)     // SPI0 baud rate register
      #define SPI_BR_SPR_DIV_2   0x00                                    // baud rate divisor 2
      #define SPI_BR_SPR_DIV_4   0x01                                    // baud rate divisor 4
      #define SPI_BR_SPR_DIV_8   0x02                                    // baud rate divisor 8
      #define SPI_BR_SPR_DIV_16  0x03                                    // baud rate divisor 16
      #define SPI_BR_SPR_DIV_32  0x04                                    // baud rate divisor 32
      #define SPI_BR_SPR_DIV_64  0x05                                    // baud rate divisor 64
      #define SPI_BR_SPR_DIV_128 0x06                                    // baud rate divisor 128
      #define SPI_BR_SPR_DIV_256 0x07                                    // baud rate divisor 256
      #define SPI_BR_SPR_DIV_512 0x08                                    // baud rate divisor 512
      #define SPI_BR_SPPR_PRE_1  0x00                                    // baud rate prescaler divisor 1
      #define SPI_BR_SPPR_PRE_2 0x10                                     // baud rate prescaler divisor 2
      #define SPI_BR_SPPR_PRE_3 0x20                                     // baud rate prescaler divisor 3
      #define SPI_BR_SPPR_PRE_4 0x30                                     // baud rate prescaler divisor 4
      #define SPI_BR_SPPR_PRE_5 0x40                                     // baud rate prescaler divisor 5
      #define SPI_BR_SPPR_PRE_6 0x50                                     // baud rate prescaler divisor 6
      #define SPI_BR_SPPR_PRE_7 0x60                                     // baud rate prescaler divisor 7
      #define SPI_BR_SPPR_PRE_8 0x70                                     // baud rate prescaler divisor 8
    #define SPI0_C2             *(unsigned char *)(SPI0_BLOCK + 0x2)     // SPI0 control register 2
      #define SPI_C2_SPC0       0x01                                     // SPI pin control 0
      #define SPI_C2_SPISWAI    0x02                                     // SPI stop in wait mode
      #define SPI_C2_BIDIROE    0x08                                     // bi-directional mode output enable
      #define SPI_C2_MODFEN     0x10                                     // master mode-fault function enable
      #define SPI_C2_SPMIE      0x80                                     // SPI match interrupt enable
    #define SPI0_C1             *(unsigned char *)(SPI0_BLOCK + 0x3)     // SPI0 control register 1
      #define SPI_C1_LSBFE      0x01                                     // LSB first
      #define SPI_C1_SSOE       0x02                                     // slave select output data
      #define SPI_C1_CPHA       0x04                                     // clock phase (first edge on SPCLK occurs at the start if the first cycle of data
      #define SPI_C1_CPOL       0x08                                     // clock polarity (idles high)
      #define SPI_C1_MSTR       0x10                                     // SPI master device
      #define SPI_C1_SPTIE      0x20                                     // SPI transmit interrupt enable
      #define SPI_C1_SPE        0x40                                     // SPI system enable
      #define SPI_C1_SPIE       0x80                                     // SPI interrupt enable
    #define SPI0_M              *(volatile unsigned char *)(SPI0_BLOCK + 0x4) // SPI0 match register

    #define SPI0_D              *(volatile unsigned char *)(SPI0_BLOCK + 0x6) // SPI0 data register
  #else
    #define SPI0_C1             *(unsigned char *)(SPI0_BLOCK + 0x0)     // SPI0 control register 1
      #define SPI_C1_LSBFE      0x01                                     // LSB first
      #define SPI_C1_SSOE       0x02                                     // slave select output data
      #define SPI_C1_CPHA       0x04                                     // clock phase (first edge on SPCLK occurs at the start if the first cycle of data
      #define SPI_C1_CPOL       0x08                                     // clock polarity (idles high)
      #define SPI_C1_MSTR       0x10                                     // SPI master device
      #define SPI_C1_SPTIE      0x20                                     // SPI transmit interrupt enable
      #define SPI_C1_SPE        0x40                                     // SPI system enable
      #define SPI_C1_SPIE       0x80                                     // SPI interrupt enable
    #define SPI0_C2             *(unsigned char *)(SPI0_BLOCK + 0x1)     // SPI0 control register 2
      #define SPI_C2_SPC0       0x01                                     // SPI pin control 0
      #define SPI_C2_SPISWAI    0x02                                     // SPI stop in wait mode
      #define SPI_C2_RXDMAE     0x04                                     // receive DMA enable
      #define SPI_C2_BIDIROE    0x08                                     // bi-directional mode output enable
      #define SPI_C2_MODFEN     0x10                                     // master mode-fault function enable
      #define SPI_C2_TXDMAE     0x20                                     // transmit DMA enable
      #define SPI_C2_SPMIE      0x80                                     // SPI match interrupt enable
    #define SPI0_BR             *(unsigned char *)(SPI0_BLOCK + 0x2)     // SPI0 baud rate register
      #define SPI_BR_SPR_DIV_2   0x00                                    // baud rate divisor 2
      #define SPI_BR_SPR_DIV_4   0x01                                    // baud rate divisor 4
      #define SPI_BR_SPR_DIV_8   0x02                                    // baud rate divisor 8
      #define SPI_BR_SPR_DIV_16  0x03                                    // baud rate divisor 16
      #define SPI_BR_SPR_DIV_32  0x04                                    // baud rate divisor 32
      #define SPI_BR_SPR_DIV_64  0x05                                    // baud rate divisor 64
      #define SPI_BR_SPR_DIV_128 0x06                                    // baud rate divisor 128
      #define SPI_BR_SPR_DIV_256 0x07                                    // baud rate divisor 256
      #define SPI_BR_SPR_DIV_512 0x08                                    // baud rate divisor 512
      #define SPI_BR_SPPR_PRE_1  0x00                                    // baud rate prescaler divisor 1
      #define SPI_BR_SPPR_PRE_2 0x10                                     // baud rate prescaler divisor 2
      #define SPI_BR_SPPR_PRE_3 0x20                                     // baud rate prescaler divisor 3
      #define SPI_BR_SPPR_PRE_4 0x30                                     // baud rate prescaler divisor 4
      #define SPI_BR_SPPR_PRE_5 0x40                                     // baud rate prescaler divisor 5
      #define SPI_BR_SPPR_PRE_6 0x50                                     // baud rate prescaler divisor 6
      #define SPI_BR_SPPR_PRE_7 0x60                                     // baud rate prescaler divisor 7
      #define SPI_BR_SPPR_PRE_8 0x70                                     // baud rate prescaler divisor 8
    #define SPI0_S              *(volatile unsigned char *)(SPI0_BLOCK + 0x3)// SPI0 status register
      #define SPI_S_MODF        0x10                                     // master mode fault flag
      #define SPI_S_SPTEF       0x20                                     // SPI transmit buffer empty flag
      #define SPI_S_SPMF        0x40                                     // SPI match flag
      #define SPI_S_SPRF        0x80                                     // SPI read buffer full flag

    #define SPI0_D              *(volatile unsigned char *)(SPI0_BLOCK + 0x5)// SPI0 data register

    #define SPI0_M              *(volatile unsigned char *)(SPI0_BLOCK + 0x7)// SPI0 match register

    #define SPI1_C1             *(unsigned char *)(SPI1_BLOCK + 0x0)     // SPI1 control register 1
    #define SPI1_C2             *(unsigned char *)(SPI1_BLOCK + 0x1)     // SPI1 control register 2
    #define SPI1_BR             *(unsigned char *)(SPI1_BLOCK + 0x2)     // SPI1 baud rate register
    #define SPI1_S              *(volatile unsigned char *)(SPI1_BLOCK + 0x3) // SPI1 status register

    #define SPI1_D              *(volatile unsigned char *)(SPI1_BLOCK + 0x5) // SPI1 data register

    #define SPI1_M              *(volatile unsigned char *)(SPI1_BLOCK + 0x7) // SPI1 match register
  #endif
#else
// DSPI
//
#define SPI0_MCR            *(volatile unsigned long *)(DSPI0_BLOCK + 0x00) // SPI0 Module Configuration Register
  #define SPI_MCR_HALT      0x00000001                                   // halts transfers
  #define SPI_MCR_SMPL_PT0  0x00000000
  #define SPI_MCR_SMPL_PT1  0x00000100
  #define SPI_MCR_SMPL_PT2  0x00000200
  #define SPI_MCR_CLR_RXF   0x00000400                                   // clear the rx FIFO (self-clearing)
  #define SPI_MCR_CLR_TXF   0x00000800                                   // clear the tx FIFO (self-clearing)
  #define SPI_MCR_DIS_RXF   0x00001000
  #define SPI_MCR_DIS_TXF   0x00002000
  #define SPI_MCR_MDIS      0x00004000
  #define SPI_MCR_DOZE      0x00008000
  #define SPI_MCR_PCSIS_CS0 0x00010000                                   // inactive state of CS0 is high
  #define SPI_MCR_PCSIS_CS1 0x00020000                                   // inactive state of CS1 is high
  #define SPI_MCR_PCSIS_CS2 0x00040000                                   // inactive state of CS2 is high
  #define SPI_MCR_PCSIS_CS3 0x00080000                                   // inactive state of CS3 is high
  #define SPI_MCR_PCSIS_CS4 0x00100000                                   // inactive state of CS4 is high
  #define SPI_MCR_PCSIS_CS5 0x00200000                                   // inactive state of CS5 is high
  #define SPI_MCR_ROOE      0x01000000
  #define SPI_MCR_PCSSE     0x02000000
  #define SPI_MCR_MTFE      0x04000000
  #define SPI_MCR_FRZ       0x08000000
  #define SPI_MCR_DCONF_SPI 0x00000000                                   // SPI mode selected (the only configuration supported)
  #define SPI_MCR_CONT_SCKE 0x40000000                                   // enable continuous SPI clock when master
  #define SPI_MCR_MSTR      0x80000000                                   // SPI master mode of operation
  #define SPI_MCR_SLAVE     0x00000000                                   // SPI slave mode of operation
#define SPI0_TCR            *(volatile unsigned long *)(DSPI0_BLOCK + 0x08) // SPI0 Transfer Count Register
#define SPI0_CTAR0          *(volatile unsigned long *)(DSPI0_BLOCK + 0x0c) // SPI0 Clock and Transfer Attributes Register in Master Mode
  #define SPI_CTAR_BR_2    0x00000000                                    // baud rate scaler - divide 2
  #define SPI_CTAR_BR_4    0x00000001                                    // baud rate scaler - divide 4
  #define SPI_CTAR_BR_6    0x00000002                                    // baud rate scaler - divide 6
  #define SPI_CTAR_BR_8    0x00000003                                    // baud rate scaler - divide 8
  #define SPI_CTAR_BR_16   0x00000004                                    // baud rate scaler - divide 16
  #define SPI_CTAR_BR_32   0x00000005                                    // baud rate scaler - divide 32
  #define SPI_CTAR_BR_64   0x00000006                                    // baud rate scaler - divide 64
  #define SPI_CTAR_BR_128  0x00000007                                    // baud rate scaler - divide 128
  #define SPI_CTAR_BR_256  0x00000008                                    // baud rate scaler - divide 256
  #define SPI_CTAR_BR_512  0x00000009                                    // baud rate scaler - divide 512
  #define SPI_CTAR_BR_1024 0x0000000a                                    // baud rate scaler - divide 1024
  #define SPI_CTAR_BR_2048 0x0000000b                                    // baud rate scaler - divide 2048
  #define SPI_CTAR_BR_4096 0x0000000c                                    // baud rate scaler - divide 4096
  #define SPI_CTAR_BR_8192 0x0000000d                                    // baud rate scaler - divide 8192
  #define SPI_CTAR_BR_16384 0x0000000e                                   // baud rate scaler - divide 16384
  #define SPI_CTAR_BR_32768 0x0000000f                                   // baud rate scaler - divide 32768
  #define SPI_CTAR_DT      0x000000f0                                    // delay after transfer scaler mask
  #define SPI_CTAR_ASC_0   0x00000000                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_1   0x00000100                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_2   0x00000200                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_3   0x00000300                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_4   0x00000400                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_5   0x00000500                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_6   0x00000600                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_7   0x00000700                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_8   0x00000800                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_9   0x00000900                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_10  0x00000a00                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_11  0x00000b00                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_12  0x00000c00                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_13  0x00000d00                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_14  0x00000e00                                    // after SCK delay scaler mask
  #define SPI_CTAR_ASC_15  0x00000f00                                    // after SCK delay scaler mask
  #define SPI_CTAR_CSSCK   0x0000f000                                    // PCS to SCK delay scaler mask
  #define SPI_CTAR_PBR_2   0x00000000                                    // baud rate prescaler - divide 2
  #define SPI_CTAR_PBR_3   0x00010000                                    // baud rate prescaler - divide 3
  #define SPI_CTAR_PBR_5   0x00020000                                    // baud rate prescaler - divide 5
  #define SPI_CTAR_PBR_7   0x00030000                                    // baud rate prescaler - divide 7
  #define SPI_CTAR_PDT_2   0x00000000                                    // delay after transfer prescaler - divide 2
  #define SPI_CTAR_PDT_3   0x00040000                                    // delay after transfer prescaler - divide 3
  #define SPI_CTAR_PDT_5   0x00080000                                    // delay after transfer prescaler - divide 5
  #define SPI_CTAR_PDT_7   0x000c0000                                    // delay after transfer prescaler - divide 7
  #define SPI_CTAR_PASC_2  0x00000000                                    // after SCK delay prescaler - divide 2
  #define SPI_CTAR_PASC_3  0x00100000                                    // after SCK delay prescaler - divide 3
  #define SPI_CTAR_PASC_5  0x00200000                                    // after SCK delay prescaler - divide 5
  #define SPI_CTAR_PASC_7  0x00300000                                    // after SCK delay prescaler - divide 7
  #define SPI_CTAR_PCSSCK_2 0x00000000                                   // PCS to SCK delay prescaler - divide 2
  #define SPI_CTAR_PCSSCK_3 0x00400000                                   // PCS to SCK delay prescaler - divide 3
  #define SPI_CTAR_PCSSCK_5 0x00800000                                   // PCS to SCK delay prescaler - divide 5
  #define SPI_CTAR_PCSSCK_7 0x00c00000                                   // PCS to SCK delay prescaler - divide 7
  #define SPI_CTAR_LSBFE   0x01000000                                    // LSB transmitted first
  #define SPI_CTAR_CPHA    0x02000000                                    // clock phase - data is changed on the rising edge and captured on the falling edge
  #define SPI_CTAR_CPOL    0x04000000                                    // clock polarity - the active state value of SCK is high
  #define SPI_CTAR_FMSZ_4  0x18000000                                    // 4 bit words
  #define SPI_CTAR_FMSZ_5  0x20000000                                    // 5 bit words
  #define SPI_CTAR_FMSZ_6  0x28000000                                    // 6 bit words
  #define SPI_CTAR_FMSZ_7  0x30000000                                    // 7 bit words
  #define SPI_CTAR_FMSZ_8  0x38000000                                    // 8 bit words
  #define SPI_CTAR_FMSZ_9  0x40000000                                    // 9 bit words
  #define SPI_CTAR_FMSZ_10 0x48000000                                    // 10 bit words
  #define SPI_CTAR_FMSZ_11 0x50000000                                    // 11 bit words
  #define SPI_CTAR_FMSZ_12 0x58000000                                    // 12 bit words
  #define SPI_CTAR_FMSZ_13 0x60000000                                    // 13 bit words
  #define SPI_CTAR_FMSZ_14 0x68000000                                    // 14 bit words
  #define SPI_CTAR_FMSZ_15 0x70000000                                    // 15 bit words
  #define SPI_CTAR_FMSZ_16 0x78000000                                    // 16 bit words
  #define SPI_CTAR_DBR     0x80000000                                    // double baud rate
#define SPI0_CTAR0_SLAVE    *(volatile unsigned long *)(DSPI0_BLOCK + 0x0c) // SPI0 Clock and Transfer Attributes Register in Slave Mode
#define SPI0_CTAR1          *(volatile unsigned long *)(DSPI0_BLOCK + 0x10) // SPI0 Clock and Transfer Attributes Register in Master Mode
#define SPI0_SR             *(volatile unsigned long *)(DSPI0_BLOCK + 0x2c) // SPI0 Status Register (flags cleared by writing them with 1)
  #define SPI_SR_POPNXTPTR  0x0000000f                                   // pop next pointer
  #define SPI_SR_RXCTR      0x000000f0                                   // rx FIFO counter (number of entries waiting to be read)
  #define SPI_SR_TXNXTPTR   0x00000f00                                   // transmit next pointer
  #define SPI_SR_TXCTR      0x0000f000                                   // tx FIFO counter
  #define SPI_SR_RFDF       0x00020000                                   // rx drain flag - RxFIFO is not empty
  #define SPI_SR_RFOF       0x00080000                                   // receive FIFO overflow flag
  #define SPI_SR_TFFF       0x02000000                                   // transmit FIFO fill flag - FIFO is not full
  #define SPI_SR_TFUF       0x08000000                                   // transmit FIFO underflow flag
  #define SPI_SR_EOQF       0x10000000                                   // end of queue flag
  #define SPI_SR_TXRXS      0x40000000                                   // DSPI is in running state
  #define SPI_SR_TCF        0x80000000                                   // transfer complete
#define SPI0_RSER           *(volatile unsigned long *)(DSPI0_BLOCK + 0x30) // SPI0 DMA/Interrupt Request Select and Enable Register
  #define SPI_SRER_RFDF_DIRS 0x00010000                                  // receive FIFO drain DMA request select
  #define SPI_SRER_RFDF_RE  0x00020000                                   // receive FIFO drain interrupt request enable
  #define SPI_SRER_RFOF_RE  0x00080000                                   // receive FIFO overflow interrupt request enable
  #define SPI_SRER_TFFF_DIRS 0x01000000                                  // transmit FIFO fill DMA request select
  #define SPI_SRER_TFFF_RE  0x02000000                                   // transmit FIFO fill interrupt request enable
  #define SPI_SRER_TFUF_RE  0x08000000                                   // transmit FIFO underflow interrupt request enable
  #define SPI_SRER_EOQF_RE  0x10000000                                   // DSPI finished interrupt request enable
  #define SPI_SRER_TCF_RE   0x80000000                                   // transmission complete interrupt request enable
#define SPI0_PUSHR          *(volatile unsigned long *)(DSPI0_BLOCK + 0x34) // {22} SPI0 PUSH TX FIFO Register in Master Mode
  #define SPI_PUSHR_PCS_NONE 0x00000000                                  // {64} no CS used
  #define SPI_PUSHR_PCS0    0x00010000                                   // negate CS0
  #define SPI_PUSHR_PCS1    0x00020000                                   // negate CS1
  #define SPI_PUSHR_PCS2    0x00040000                                   // negate CS2
  #define SPI_PUSHR_PCS3    0x00080000                                   // negate CS3
  #define SPI_PUSHR_PCS4    0x00100000                                   // negate CS4
  #define SPI_PUSHR_PCS5    0x00200000                                   // negate CS5
  #define SPI_PUSHR_CTCNT   0x04000000                                   // 
  #define SPI_PUSHR_EOQ     0x08000000                                   // end of queue - last data to be transferred
  #define SPI_PUSHR_CTAS_CTAR0 0x00000000                                // clock and transfer attributes select - use CTAR0
  #define SPI_PUSHR_CTAS_CTAR1 0x10000000                                // clock and transfer attributes select - use CTAR1
  #define SPI_PUSHR_CONT    0x80000000                                   // keep CS asserted between transfers
#define SPI0_PUSHR_SLAVE    *(volatile unsigned long *)(DSPI0_BLOCK + 0x34) // SPI0 PUSH TX FIFO Register in Slave Mode
#define SPI0_POPR           *(volatile unsigned long *)(DSPI0_BLOCK + 0x38) // SPI0 POP RX FIFO Register (read-only)
#define SPI0_TXFR0          *(volatile unsigned long *)(DSPI0_BLOCK + 0x3c) // SPI0 Transmit FIFO Registers (read-only)
#define SPI0_TXFR1          *(volatile unsigned long *)(DSPI0_BLOCK + 0x40) // SPI0 Transmit FIFO Registers (read-only)
#define SPI0_TXFR2          *(volatile unsigned long *)(DSPI0_BLOCK + 0x44) // SPI0 Transmit FIFO Registers (read-only)
#define SPI0_TXFR3          *(volatile unsigned long *)(DSPI0_BLOCK + 0x48) // SPI0 Transmit FIFO Registers (read-only)
#define SPI0_RXFR0          *(volatile unsigned long *)(DSPI0_BLOCK + 0x7c) // SPI0 Receive FIFO Registers (read-only)
#define SPI0_RXFR1          *(volatile unsigned long *)(DSPI0_BLOCK + 0x80) // SPI0 Receive FIFO Registers (read-only)
#define SPI0_RXFR2          *(volatile unsigned long *)(DSPI0_BLOCK + 0x84) // SPI0 Receive FIFO Registers (read-only)
#define SPI0_RXFR3          *(volatile unsigned long *)(DSPI0_BLOCK + 0x88) // SPI0 Receive FIFO Registers (read-only)
    #if SPI_AVAILABLE > 1
        #define SPI1_MCR            *(volatile unsigned long *)(DSPI1_BLOCK + 0x00) // SPI1 Module Configuration Register
        #define SPI1_TCR            *(volatile unsigned long *)(DSPI1_BLOCK + 0x08) // SPI1 Transfer Count Register
        #define SPI1_CTAR0          *(volatile unsigned long *)(DSPI1_BLOCK + 0x0c) // SPI1 Clock and Transfer Attributes Register in Master Mode
        #define SPI1_CTAR0_SLAVE    *(volatile unsigned long *)(DSPI1_BLOCK + 0x0c) // SPI1 Clock and Transfer Attributes Register in Slave Mode
        #define SPI1_CTAR1          *(volatile unsigned long *)(DSPI1_BLOCK + 0x10) // SPI1 Clock and Transfer Attributes Register in Master Mode
        #define SPI1_SR             *(volatile unsigned long *)(DSPI1_BLOCK + 0x2c) // SPI1 Status Register
        #define SPI1_RSER           *(volatile unsigned long *)(DSPI1_BLOCK + 0x30) // SPI1 DMA/Interrupt Request Select and Enable Register
        #define SPI1_PUSHR          *(volatile unsigned long *)(DSPI1_BLOCK + 0x34) // {22} SPI1 PUSH TX FIFO Register in Master Mode
        #define SPI1_PUSHR_SLAVE    *(volatile unsigned long *)(DSPI1_BLOCK + 0x34) // SPI1 PUSH TX FIFO Register in Slave Mode
        #define SPI1_POPR           *(volatile unsigned long *)(DSPI1_BLOCK + 0x38) // SPI1 POP RX FIFO Register (read-only)
        #define SPI1_TXFR0          *(volatile unsigned long *)(DSPI1_BLOCK + 0x3c) // SPI1 Transmit FIFO Registers (write-only)
        #define SPI1_TXFR1          *(volatile unsigned long *)(DSPI1_BLOCK + 0x40) // SPI1 Transmit FIFO Registers (write-only)
        #define SPI1_TXFR2          *(volatile unsigned long *)(DSPI1_BLOCK + 0x44) // SPI1 Transmit FIFO Registers (write-only)
        #define SPI1_TXFR3          *(volatile unsigned long *)(DSPI1_BLOCK + 0x48) // SPI1 Transmit FIFO Registers (write-only)
        #define SPI1_RXFR0          *(volatile unsigned long *)(DSPI1_BLOCK + 0x7c) // SPI1 Receive FIFO Registers (read-only)
        #define SPI1_RXFR1          *(volatile unsigned long *)(DSPI1_BLOCK + 0x80) // SPI1 Receive FIFO Registers (read-only)
        #define SPI1_RXFR2          *(volatile unsigned long *)(DSPI1_BLOCK + 0x84) // SPI1 Receive FIFO Registers (read-only)
        #define SPI1_RXFR3          *(volatile unsigned long *)(DSPI1_BLOCK + 0x88) // SPI1 Receive FIFO Registers (read-only)
    #endif
    #if SPI_AVAILABLE > 2
        #define SPI2_MCR            *(volatile unsigned long *)(DSPI2_BLOCK + 0x00) // SPI2 Module Configuration Register
        #define SPI2_TCR            *(volatile unsigned long *)(DSPI2_BLOCK + 0x08) // SPI2 Transfer Count Register
        #define SPI2_CTAR0          *(volatile unsigned long *)(DSPI2_BLOCK + 0x0c) // SPI2 Clock and Transfer Attributes Register in Master Mode
        #define SPI2_CTAR0_SLAVE    *(volatile unsigned long *)(DSPI2_BLOCK + 0x0c) // SPI2 Clock and Transfer Attributes Register in Slave Mode
        #define SPI2_CTAR1          *(volatile unsigned long *)(DSPI2_BLOCK + 0x10) // SPI2 Clock and Transfer Attributes Register in Master Mode
        #define SPI2_SR             *(volatile unsigned long *)(DSPI2_BLOCK + 0x2c) // SPI2 Status Register
        #define SPI2_RSER           *(volatile unsigned long *)(DSPI2_BLOCK + 0x30) // SPI2 DMA/Interrupt Request Select and Enable Register
        #define SPI2_PUSHR          *(volatile unsigned long *)(DSPI2_BLOCK + 0x34) // {22} SPI2 PUSH TX FIFO Register in Master Mode
        #define SPI2_PUSHR_SLAVE    *(volatile unsigned long *)(DSPI2_BLOCK + 0x34) // SPI2 PUSH TX FIFO Register in Slave Mode
        #define SPI2_POPR           *(volatile unsigned long *)(DSPI2_BLOCK + 0x38) // SPI2 POP RX FIFO Register (read-only)
        #define SPI2_TXFR0          *(volatile unsigned long *)(DSPI2_BLOCK + 0x3c) // SPI2 Transmit FIFO Registers (write-only)
        #define SPI2_TXFR1          *(volatile unsigned long *)(DSPI2_BLOCK + 0x40) // SPI2 Transmit FIFO Registers (write-only)
        #define SPI2_TXFR2          *(volatile unsigned long *)(DSPI2_BLOCK + 0x44) // SPI2 Transmit FIFO Registers (write-only)
        #define SPI2_TXFR3          *(volatile unsigned long *)(DSPI2_BLOCK + 0x48) // SPI2 Transmit FIFO Registers (write-only)
        #define SPI2_RXFR0          *(volatile unsigned long *)(DSPI2_BLOCK + 0x7c) // SPI2 Receive FIFO Registers (read-only)
        #define SPI2_RXFR1          *(volatile unsigned long *)(DSPI2_BLOCK + 0x80) // SPI2 Receive FIFO Registers (read-only)
        #define SPI2_RXFR2          *(volatile unsigned long *)(DSPI2_BLOCK + 0x84) // SPI2 Receive FIFO Registers (read-only)
        #define SPI2_RXFR3          *(volatile unsigned long *)(DSPI2_BLOCK + 0x88) // SPI2 Receive FIFO Registers (read-only)
    #endif
#endif

#if defined LTC_AVAILABLE                                                // {92}
    // LTC
    //
    #define LTC0_MD             *(unsigned long *)(LTC_BLOCK + 0x000)    // LTC mode (non-PKHA/non-RNG use)
      #define LTC_MD_ENC_DECRYPT       0x00000000
      #define LTC_MD_ENC_ENCRYPT       0x00000001
      #define LTC_MD_ICV_TEST          0x00000002
      #define LTC_MD_AS_UPDATE         0x00000000
      #define LTC_MD_AS_INITIALISE     0x00000004
      #define LTC_MD_AS_FINALISE       0x00000008
      #define LTC_MD_AS_INIT_FINAL     0x0000000c
      #define LTC_MD_AAI_CTR           0x00000000
      #define LTC_MD_AAI_CBC           0x00000100
      #define LTC_MD_AAI_ECB           0x00000200
      #define LTC_MD_AAI_CMAC          0x00000600
      #define LTC_MD_AAI_XCBC_MAC      0x00000700
      #define LTC_MD_AAI_CCM           0x00000800
      #define LTC_MD_AAI_GCM           0x00000900
      #define LTC_MD_ALG_AES           0x00100000
      #define LTC_MD_ALG_DES           0x00200000
      #define LTC_MD_ALG_3DES          0x00210000
    #define LTC0_MDPK           *(unsigned long *)(LTC_BLOCK + 0x000)    // LTC mode (public key)
    #define LTC0_KS             *(unsigned long *)(LTC_BLOCK + 0x008)    // LTC key size
    #define LTC0_DS             *(unsigned long *)(LTC_BLOCK + 0x010)    // LTC data size
    #define LTC0_ICVS           *(unsigned long *)(LTC_BLOCK + 0x018)    // LTC ICV size
    #define LTC0_COM            *(volatile unsigned long *)(LTC_BLOCK + 0x030) // LTC command (write-only)
    #define LTC0_CTL            *(volatile unsigned long *)(LTC_BLOCK + 0x034) // LTC control
      #define LTC_CTL_IM         0x00000001                              // interrupt masked (only cleared by hard reset)
      #define LTC_CTL_PDE        0x00000010                              // PKHA register DMA enable
      #define LTC_CTL_IFE        0x00000100                              // input FIFO DMA enable
      #define LTC_CTL_IFR_1      0x00000000                              // input FIFO request size 1 entrie
      #define LTC_CTL_IFR_4      0x00000200                              // input FIFO request size 4 entries
      #define LTC_CTL_OFE        0x00001000                              // output FIFO DMA enable
      #define LTC_CTL_OFR_1      0x00000000                              // output FIFO request size 1 entrie
      #define LTC_CTL_OFR_4      0x00002000                              // output FIFO request size 4 entries
      #define LTC_CTL_IFS        0x00010000                              // input FIFO byte swap data
      #define LTC_CTL_OFS        0x00020000                              // output FIFO byte swap data
      #define LTC_CTL_KIS        0x00100000                              // key register input byte swap data
      #define LTC_CTL_KOS        0x00200000                              // key register output byte swap data
      #define LTC_CTL_CIS        0x00400000                              // context register input byte swap data
      #define LTC_CTL_COS        0x00800000                              // context register output byte swap data
      #define LTC_CTL_KAL        0x80000000                              // key register access lock (only cleared by hard reset)
    #define LTC0_CW             *(volatile unsigned long *)(LTC_BLOCK + 0x040) // LTC clear written (write-only)
      #define LTC_CW_CM          0x00000001                              // clear mode register
      #define LTC_CW_CDS         0x00000004                              // clear data size register (and also AAD size)
      #define LTC_CW_CICV        0x00000080                              // clear ICV size register
      #define LTC_CW_CCR         0x00000020                              // clear context register
      #define LTC_CW_CKR         0x00000040                              // clear key register
      #define LTC_CW_CPKA        0x00001000                              // clear PKHA A size register
      #define LTC_CW_CPKB        0x00002000                              // clear PKHA B size register
      #define LTC_CW_CPKN        0x00004000                              // clear PKHA N size register
      #define LTC_CW_CPKE        0x00008000                              // clear PKHA E size register
      #define LTC_CW_COF         0x40000000                              // clear output FIFO
      #define LTC_CW_CIF         0x80000000                              // clear input FIFO
    #define LTC0_STA            *(volatile unsigned long *)(LTC_BLOCK + 0x048) // LTC status (read-only/write '1' to clear)
      #define LTC_STA_AB         0x00000002                              // AESA busy
      #define LTC_STA_DB         0x00000004                              // DESA busy
      #define LTC_STA_PB         0x00000040                              // PKHA busy
      #define LTC_STA_DI         0x00010000                              // done interrupt asserted (write '1' to clear)
      #define LTC_STA_EI         0x00100000                              // error interrupt
      #define LTC_STA_PKP        0x10000000                              // public key is prime
      #define LTC_STA_PKO        0x20000000                              // public key operation is one
      #define LTC_STA_PKZ        0x40000000                              // public key operation is zero
    #define LTC0_ESTA           *(volatile unsigned long *)(LTC_BLOCK + 0x04c) // LTC error status (read-only)
    #define LTC0_AADSZ          *(unsigned long *)(LTC_BLOCK + 0x058)    // LTC AAD size
    #define LTC0_IVS            *(unsigned long *)(LTC_BLOCK + 0x060)    // LTC IV size
    #define LTC0_DPAMS          *(volatile unsigned long *)(LTC_BLOCK + 0x068) // LTC DPA mask seed (write-only)
    #define LTC0_PKASZ          *(unsigned long *)(LTC_BLOCK + 0x080)    // LTC PKHA A size
    #define LTC0_PKBSZ          *(unsigned long *)(LTC_BLOCK + 0x088)    // LTC PKHA B size
    #define LTC0_PKNSZ          *(unsigned long *)(LTC_BLOCK + 0x090)    // LTC PKHA N size
    #define LTC0_PKESZ          *(unsigned long *)(LTC_BLOCK + 0x098)    // LTC PKHA E size
    #define LTC0_CTX_0          *(unsigned long *)(LTC_BLOCK + 0x100)    // LTC context 0
    #define LTC0_CTX_1          *(unsigned long *)(LTC_BLOCK + 0x104)    // LTC context 1
    #define LTC0_CTX_2          *(unsigned long *)(LTC_BLOCK + 0x108)    // LTC context 2
    #define LTC0_CTX_3          *(unsigned long *)(LTC_BLOCK + 0x10c)    // LTC context 3
    #define LTC0_CTX_4          *(unsigned long *)(LTC_BLOCK + 0x110)    // LTC context 4
    #define LTC0_CTX_5          *(unsigned long *)(LTC_BLOCK + 0x114)    // LTC context 5
    #define LTC0_CTX_6          *(unsigned long *)(LTC_BLOCK + 0x118)    // LTC context 6
    #define LTC0_CTX_7          *(unsigned long *)(LTC_BLOCK + 0x11c)    // LTC context 7
    #define LTC0_CTX_8          *(unsigned long *)(LTC_BLOCK + 0x120)    // LTC context 8
    #define LTC0_CTX_9          *(unsigned long *)(LTC_BLOCK + 0x124)    // LTC context 9
    #define LTC0_CTX_10         *(unsigned long *)(LTC_BLOCK + 0x128)    // LTC context 10
    #define LTC0_CTX_11         *(unsigned long *)(LTC_BLOCK + 0x12c)    // LTC context 11
    #define LTC0_CTX_12         *(unsigned long *)(LTC_BLOCK + 0x130)    // LTC context 12
    #define LTC0_CTX_13         *(unsigned long *)(LTC_BLOCK + 0x134)    // LTC context 13
    #define LTC0_CTX_14         *(unsigned long *)(LTC_BLOCK + 0x138)    // LTC context 14
    #define LTC0_CTX_15         *(unsigned long *)(LTC_BLOCK + 0x13c)    // LTC context 15
    #define LTC0_KEY_0          *(unsigned long *)(LTC_BLOCK + 0x200)    // LTC key 0
    #define LTC0_KEY_1          *(unsigned long *)(LTC_BLOCK + 0x204)    // LTC key 1
    #define LTC0_KEY_2          *(unsigned long *)(LTC_BLOCK + 0x208)    // LTC key 2
    #define LTC0_KEY_3          *(unsigned long *)(LTC_BLOCK + 0x20c)    // LTC key 3
    #define LTC0_KEY_4          *(unsigned long *)(LTC_BLOCK + 0x210)    // LTC key 4
    #define LTC0_KEY_5          *(unsigned long *)(LTC_BLOCK + 0x214)    // LTC key 5
    #define LTC0_KEY_6          *(unsigned long *)(LTC_BLOCK + 0x218)    // LTC key 6
    #define LTC0_KEY_7          *(unsigned long *)(LTC_BLOCK + 0x21c)    // LTC key 7
    #define LTC0_FIFOSTA        *(volatile unsigned long *)(LTC_BLOCK + 0x7c0) // LTC FIFO status (read-only)
      #define LTC_FIFOSTA_IFL_MASK 0x0000007f                            // input FIFO level mask
      #define LTC_FIFOSTA_IFF      0x00008000                            // input FIFO full
      #define LTC_FIFOSTA_OFL_MASK 0x007f0000                            // output FIFO level mask
      #define LTC_FIFOSTA_OFF      0x80000000                            // output FIFO full
    #define LTC0_IFIFO          *(volatile unsigned long *)(LTC_BLOCK + 0x7e0) // LTC input data FIFO (read-only)
    #define LTC0_OFIFO          *(volatile unsigned long *)(LTC_BLOCK + 0x7f0) // LTC output data FIFO (write-only)
#endif
#if defined KINETIS_K80
    // QuadSPI                                                           // {76}
    //
    #define QuadSPI0_MCR        *(unsigned long *)(QSPI_BLOCK + 0x000)   // QSPI0 module configuration register
    #define QuadSPI0_IPCR       *(unsigned long *)(QSPI_BLOCK + 0x008)   // QSPI0 IP configuration register
    #define QuadSPI0_FLSHCR     *(unsigned long *)(QSPI_BLOCK + 0x00c)   // QSPI0 Flash configuration register
    #define QuadSPI0_BUF0CR     *(unsigned long *)(QSPI_BLOCK + 0x010)   // QSPI0 buffer 0 configuration register
    #define QuadSPI0_BUF1CR     *(unsigned long *)(QSPI_BLOCK + 0x014)   // QSPI0 buffer 1 configuration register
    #define QuadSPI0_BUF2CR     *(unsigned long *)(QSPI_BLOCK + 0x018)   // QSPI0 buffer 2 configuration register
    #define QuadSPI0_BUF3CR     *(unsigned long *)(QSPI_BLOCK + 0x01c)   // QSPI0 buffer 3 configuration register
    #define QuadSPI0_BFGENCR    *(unsigned long *)(QSPI_BLOCK + 0x020)   // QSPI0 buffer generic configuration register
    #define QuadSPI0_SOCCR      *(unsigned long *)(QSPI_BLOCK + 0x024)   // QSPI0 SOC configuration register
    #define QuadSPI0_BUF0IND    *(unsigned long *)(QSPI_BLOCK + 0x030)   // QSPI0 buffer 0 top index register
    #define QuadSPI0_BUF1IND    *(unsigned long *)(QSPI_BLOCK + 0x034)   // QSPI0 buffer 1 top index register
    #define QuadSPI0_BUF2IND    *(unsigned long *)(QSPI_BLOCK + 0x038)   // QSPI0 buffer 2 top index register
    #define QuadSPI0_SFAR       *(unsigned long *)(QSPI_BLOCK + 0x100)   // QSPI0 serial Flash address register
    #define QuadSPI0_SFACR      *(unsigned long *)(QSPI_BLOCK + 0x104)   // QSPI0 serial Flash address configuration register
    #define QuadSPI0_SMPR       *(unsigned long *)(QSPI_BLOCK + 0x108)   // QSPI0 sampling register
    #define QuadSPI0_RBSR       *(volatile unsigned long *)(QSPI_BLOCK + 0x10c) // QSPI0 Rx buffer status register
    #define QuadSPI0_RBCT       *(unsigned long *)(QSPI_BLOCK + 0x110)   // QSPI0 Rx buffer control register
    #define QuadSPI0_TBSR       *(volatile unsigned long *)(QSPI_BLOCK + 0x150) // QSPI0 Tx buffer status register
    #define QuadSPI0_TBDR       *(volatile unsigned long *)(QSPI_BLOCK + 0x154) // QSPI0 Tx buffer data register
    #define QuadSPI0_TBCT       *(unsigned long *)(QSPI_BLOCK + 0x158)   // QSPI0 Tx buffer control register
    #define QuadSPI0_SR         *(volatile unsigned long *)(QSPI_BLOCK + 0x15c) // QSPI0 status register
    #define QuadSPI0_FR         *(volatile unsigned long *)(QSPI_BLOCK + 0x160) // QSPI0 flag register (write '1' to clear)
    #define QuadSPI0_RSER       *(unsigned long *)(QSPI_BLOCK + 0x164)   // QSPI0 interrupt and DMA request select and enable register
    #define QuadSPI0_SPNDST     *(volatile unsigned long *)(QSPI_BLOCK + 0x168) // QSPI0 sequence suspend status register
    #define QuadSPI0_SPTRCLR    *(unsigned long *)(QSPI_BLOCK + 0x16c)   // QSPI0 sequence pointer clear register
    #define QuadSPI0_SFA1AD     *(unsigned long *)(QSPI_BLOCK + 0x180)   // QSPI0 serial Flash A1 top address register
    #define QuadSPI0_SFA2AD     *(unsigned long *)(QSPI_BLOCK + 0x184)   // QSPI0 serial Flash A2 top address register
    #define QuadSPI0_SFB1AD     *(unsigned long *)(QSPI_BLOCK + 0x188)   // QSPI0 serial Flash B1 top address register
    #define QuadSPI0_SFB2AD     *(unsigned long *)(QSPI_BLOCK + 0x18c)   // QSPI0 serial Flash B2 top address register
    #define QuadSPI0_DLPR       *(unsigned long *)(QSPI_BLOCK + 0x190)   // QSPI0 data learn pattern register
    #define QuadSPI0_RBDR0      *(volatile unsigned long *)(QSPI_BLOCK + 0x200) // QSPI0 Rx Buffer 0 data register
    #define QuadSPI0_RBDR1      *(volatile unsigned long *)(QSPI_BLOCK + 0x204) // QSPI0 Rx Buffer 1 data register
    #define QuadSPI0_RBDR2      *(volatile unsigned long *)(QSPI_BLOCK + 0x208) // QSPI0 Rx Buffer 2 data register
    #define QuadSPI0_RBDR3      *(volatile unsigned long *)(QSPI_BLOCK + 0x20c) // QSPI0 Rx Buffer 3 data register
    #define QuadSPI0_RBDR4      *(volatile unsigned long *)(QSPI_BLOCK + 0x210) // QSPI0 Rx Buffer 4 data register
    #define QuadSPI0_RBDR5      *(volatile unsigned long *)(QSPI_BLOCK + 0x214) // QSPI0 Rx Buffer 5 data register
    #define QuadSPI0_RBDR6      *(volatile unsigned long *)(QSPI_BLOCK + 0x218) // QSPI0 Rx Buffer 6 data register
    #define QuadSPI0_RBDR7      *(volatile unsigned long *)(QSPI_BLOCK + 0x21c) // QSPI0 Rx Buffer 7 data register
    #define QuadSPI0_RBDR8      *(volatile unsigned long *)(QSPI_BLOCK + 0x220) // QSPI0 Rx Buffer 8 data register
    #define QuadSPI0_RBDR9      *(volatile unsigned long *)(QSPI_BLOCK + 0x224) // QSPI0 Rx Buffer 9 data register
    #define QuadSPI0_RBDR10     *(volatile unsigned long *)(QSPI_BLOCK + 0x228) // QSPI0 Rx Buffer 10 data register
    #define QuadSPI0_RBDR11     *(volatile unsigned long *)(QSPI_BLOCK + 0x22c) // QSPI0 Rx Buffer 11 data register
    #define QuadSPI0_RBDR12     *(volatile unsigned long *)(QSPI_BLOCK + 0x230) // QSPI0 Rx Buffer 12 data register
    #define QuadSPI0_RBDR13     *(volatile unsigned long *)(QSPI_BLOCK + 0x234) // QSPI0 Rx Buffer 13 data register
    #define QuadSPI0_RBDR14     *(volatile unsigned long *)(QSPI_BLOCK + 0x238) // QSPI0 Rx Buffer 14 data register
    #define QuadSPI0_RBDR15     *(volatile unsigned long *)(QSPI_BLOCK + 0x23c) // QSPI0 Rx Buffer 15 data register
    #define QuadSPI0_LUTKEY     *(unsigned long *)(QSPI_BLOCK + 0x300)   // QSPI0 LUT key register
    #define QuadSPI0_LCKCR      *(unsigned long *)(QSPI_BLOCK + 0x304)   // QSPI0 LUT lock configuration register
    #define QuadSPI0_LUT0       *(unsigned long *)(QSPI_BLOCK + 0x310)   // QSPI0 look-up table 0 register
    #define QuadSPI0_LUT1       *(unsigned long *)(QSPI_BLOCK + 0x314)   // QSPI0 look-up table 1 register
    #define QuadSPI0_LUT2       *(unsigned long *)(QSPI_BLOCK + 0x318)   // QSPI0 look-up table 2 register
    #define QuadSPI0_LUT3       *(unsigned long *)(QSPI_BLOCK + 0x31c)   // QSPI0 look-up table 3 register
    #define QuadSPI0_LUT4       *(unsigned long *)(QSPI_BLOCK + 0x320)   // QSPI0 look-up table 4 register
    #define QuadSPI0_LUT5       *(unsigned long *)(QSPI_BLOCK + 0x324)   // QSPI0 look-up table 5 register
    #define QuadSPI0_LUT6       *(unsigned long *)(QSPI_BLOCK + 0x328)   // QSPI0 look-up table 6 register
    #define QuadSPI0_LUT7       *(unsigned long *)(QSPI_BLOCK + 0x32c)   // QSPI0 look-up table 7 register
    #define QuadSPI0_LUT8       *(unsigned long *)(QSPI_BLOCK + 0x330)   // QSPI0 look-up table 8 register
    #define QuadSPI0_LUT9       *(unsigned long *)(QSPI_BLOCK + 0x334)   // QSPI0 look-up table 9 register
    #define QuadSPI0_LUT10      *(unsigned long *)(QSPI_BLOCK + 0x338)   // QSPI0 look-up table 10 register
    #define QuadSPI0_LUT11      *(unsigned long *)(QSPI_BLOCK + 0x33c)   // QSPI0 look-up table 11 register
    #define QuadSPI0_LUT12      *(unsigned long *)(QSPI_BLOCK + 0x340)   // QSPI0 look-up table 12 register
    #define QuadSPI0_LUT13      *(unsigned long *)(QSPI_BLOCK + 0x344)   // QSPI0 look-up table 13 register
    #define QuadSPI0_LUT14      *(unsigned long *)(QSPI_BLOCK + 0x348)   // QSPI0 look-up table 14 register
    #define QuadSPI0_LUT15      *(unsigned long *)(QSPI_BLOCK + 0x34c)   // QSPI0 look-up table 15 register
    #define QuadSPI0_LUT16      *(unsigned long *)(QSPI_BLOCK + 0x350)   // QSPI0 look-up table 16 register
    #define QuadSPI0_LUT17      *(unsigned long *)(QSPI_BLOCK + 0x354)   // QSPI0 look-up table 17 register
    #define QuadSPI0_LUT18      *(unsigned long *)(QSPI_BLOCK + 0x358)   // QSPI0 look-up table 18 register
    #define QuadSPI0_LUT19      *(unsigned long *)(QSPI_BLOCK + 0x35c)   // QSPI0 look-up table 19 register
    #define QuadSPI0_LUT20      *(unsigned long *)(QSPI_BLOCK + 0x360)   // QSPI0 look-up table 20 register
    #define QuadSPI0_LUT21      *(unsigned long *)(QSPI_BLOCK + 0x364)   // QSPI0 look-up table 21 register
    #define QuadSPI0_LUT22      *(unsigned long *)(QSPI_BLOCK + 0x368)   // QSPI0 look-up table 22 register
    #define QuadSPI0_LUT23      *(unsigned long *)(QSPI_BLOCK + 0x36c)   // QSPI0 look-up table 23 register
    #define QuadSPI0_LUT24      *(unsigned long *)(QSPI_BLOCK + 0x370)   // QSPI0 look-up table 24 register
    #define QuadSPI0_LUT25      *(unsigned long *)(QSPI_BLOCK + 0x374)   // QSPI0 look-up table 25 register
    #define QuadSPI0_LUT26      *(unsigned long *)(QSPI_BLOCK + 0x378)   // QSPI0 look-up table 26 register
    #define QuadSPI0_LUT27      *(unsigned long *)(QSPI_BLOCK + 0x37c)   // QSPI0 look-up table 27 register
    #define QuadSPI0_LUT28      *(unsigned long *)(QSPI_BLOCK + 0x380)   // QSPI0 look-up table 28 register
    #define QuadSPI0_LUT29      *(unsigned long *)(QSPI_BLOCK + 0x384)   // QSPI0 look-up table 29 register
    #define QuadSPI0_LUT30      *(unsigned long *)(QSPI_BLOCK + 0x388)   // QSPI0 look-up table 30 register
    #define QuadSPI0_LUT31      *(unsigned long *)(QSPI_BLOCK + 0x38c)   // QSPI0 look-up table 31 register
    #define QuadSPI0_LUT32      *(unsigned long *)(QSPI_BLOCK + 0x390)   // QSPI0 look-up table 32 register
    #define QuadSPI0_LUT33      *(unsigned long *)(QSPI_BLOCK + 0x394)   // QSPI0 look-up table 33 register
    #define QuadSPI0_LUT34      *(unsigned long *)(QSPI_BLOCK + 0x398)   // QSPI0 look-up table 34 register
    #define QuadSPI0_LUT35      *(unsigned long *)(QSPI_BLOCK + 0x39c)   // QSPI0 look-up table 35 register
    #define QuadSPI0_LUT36      *(unsigned long *)(QSPI_BLOCK + 0x3a0)   // QSPI0 look-up table 36 register
    #define QuadSPI0_LUT37      *(unsigned long *)(QSPI_BLOCK + 0x3a4)   // QSPI0 look-up table 37 register
    #define QuadSPI0_LUT38      *(unsigned long *)(QSPI_BLOCK + 0x3a8)   // QSPI0 look-up table 38 register
    #define QuadSPI0_LUT39      *(unsigned long *)(QSPI_BLOCK + 0x3ac)   // QSPI0 look-up table 39 register
    #define QuadSPI0_LUT40      *(unsigned long *)(QSPI_BLOCK + 0x3b0)   // QSPI0 look-up table 40 register
    #define QuadSPI0_LUT41      *(unsigned long *)(QSPI_BLOCK + 0x3b4)   // QSPI0 look-up table 41 register
    #define QuadSPI0_LUT42      *(unsigned long *)(QSPI_BLOCK + 0x3b8)   // QSPI0 look-up table 42 register
    #define QuadSPI0_LUT43      *(unsigned long *)(QSPI_BLOCK + 0x3bc)   // QSPI0 look-up table 43 register
    #define QuadSPI0_LUT44      *(unsigned long *)(QSPI_BLOCK + 0x3c0)   // QSPI0 look-up table 44 register
    #define QuadSPI0_LUT45      *(unsigned long *)(QSPI_BLOCK + 0x3c4)   // QSPI0 look-up table 45 register
    #define QuadSPI0_LUT46      *(unsigned long *)(QSPI_BLOCK + 0x3c8)   // QSPI0 look-up table 46 register
    #define QuadSPI0_LUT47      *(unsigned long *)(QSPI_BLOCK + 0x3cc)   // QSPI0 look-up table 47 register
    #define QuadSPI0_LUT48      *(unsigned long *)(QSPI_BLOCK + 0x3d0)   // QSPI0 look-up table 48 register
    #define QuadSPI0_LUT49      *(unsigned long *)(QSPI_BLOCK + 0x3d4)   // QSPI0 look-up table 49 register
    #define QuadSPI0_LUT50      *(unsigned long *)(QSPI_BLOCK + 0x3d8)   // QSPI0 look-up table 50 register
    #define QuadSPI0_LUT51      *(unsigned long *)(QSPI_BLOCK + 0x3dc)   // QSPI0 look-up table 51 register
    #define QuadSPI0_LUT52      *(unsigned long *)(QSPI_BLOCK + 0x3e0)   // QSPI0 look-up table 52 register
    #define QuadSPI0_LUT53      *(unsigned long *)(QSPI_BLOCK + 0x3e4)   // QSPI0 look-up table 53 register
    #define QuadSPI0_LUT54      *(unsigned long *)(QSPI_BLOCK + 0x3e8)   // QSPI0 look-up table 54 register
    #define QuadSPI0_LUT55      *(unsigned long *)(QSPI_BLOCK + 0x3ec)   // QSPI0 look-up table 55 register
    #define QuadSPI0_LUT56      *(unsigned long *)(QSPI_BLOCK + 0x3f0)   // QSPI0 look-up table 56 register
    #define QuadSPI0_LUT57      *(unsigned long *)(QSPI_BLOCK + 0x3f4)   // QSPI0 look-up table 57 register
    #define QuadSPI0_LUT58      *(unsigned long *)(QSPI_BLOCK + 0x3f8)   // QSPI0 look-up table 58 register
    #define QuadSPI0_LUT59      *(unsigned long *)(QSPI_BLOCK + 0x3fc)   // QSPI0 look-up table 59 register
    #define QuadSPI0_LUT60      *(unsigned long *)(QSPI_BLOCK + 0x400)   // QSPI0 look-up table 60 register
    #define QuadSPI0_LUT61      *(unsigned long *)(QSPI_BLOCK + 0x404)   // QSPI0 look-up table 61 register
    #define QuadSPI0_LUT62      *(unsigned long *)(QSPI_BLOCK + 0x408)   // QSPI0 look-up table 62 register
    #define QuadSPI0_LUT63      *(unsigned long *)(QSPI_BLOCK + 0x40c)   // QSPI0 look-up table 63 register
#endif

#if defined KINETIS_KE
// Keyboard Interrupt                                                    {56}
//
  #if defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
    #define KBI0_PE             *(unsigned long *)(KBI0_BLOCK + 0x0)     // KBI0 Pin Enable Register (enable pin as KBI interrupt)
    #define KBI0_ES             *(unsigned long *)(KBI0_BLOCK + 0x4)     // KBI0 Edge Select Register ('1' is rising edge / '0' is  falling edge)
    #define KBI0_SC             *(volatile unsigned long *)(KBI0_BLOCK + 0x8) // KBI0 Status and Control Register
      #define KBI_SC_KBMOD      0x00000001                               // KBI detection mode (detects levels as well as edges)
      #define KBI_SC_KBIE       0x00000002                               // KBI interrupt enable
      #define KBI_SC_KBACK      0x00000004                               // KBI acknowledge (write-only)
      #define KBI_SC_KBF        0x00000008                               // KBI interrupt flag (read-only)
      #define KBI_SC_KBSPEN     0x00000010                               // real KBI_SP register enable
      #define KBI_SC_RSTKBSP    0x00000020                               // write '1' to clear KBIx_SP (always reads '0')
    #define KBI0_SP             *(volatile unsigned long *)(KBI0_BLOCK + 0xc) // KBI0 Source Pin Register (read-only) - sources are latched '1' and cleared only by setting KBI_SC_RSTKBSP or reset

    #define KBI1_PE             *(unsigned long *)(KBI1_BLOCK + 0x0)     // KBI1 Pin Enable Register
    #define KBI1_ES             *(unsigned long *)(KBI1_BLOCK + 0x4)     // KBI1 Edge Select Register
    #define KBI1_SC             *(volatile unsigned long *)(KBI1_BLOCK + 0x8) // KBI1 Status and Control Register
    #define KBI1_SP             *(volatile unsigned long *)(KBI1_BLOCK + 0xc) // KBI1 Source Pin Register (read-only)

    typedef struct st_KINETIS_KBI                                        // KBI control struct
    {
        unsigned long KBI_PE;
        unsigned long KBI_ES;
        volatile unsigned long KBI_SC;
        volatile unsigned long KBI_SP;
    } _KINETIS_KBI;
  #else                                                                  // KE02
    #define KBI0_SC             *(volatile unsigned char *)(KBI0_BLOCK + 0x0) // KBI0 Status and Control Register
      #define KBI_SC_KBMOD      0x00000001                               // KBI detection mode (detects levels as well as edges)
      #define KBI_SC_KBIE       0x00000002                               // KBI interrupt enable
      #define KBI_SC_KBACK      0x00000004                               // KBI acknowledge (write-only)
      #define KBI_SC_KBF        0x00000008                               // KBI interrupt flag (read-only)
    #define KBI0_PE             *(unsigned char *)(KBI0_BLOCK + 0x1)     // KBI0 Pin Enable Register (enable pin as KBI interrupt)
    #define KBI0_ES             *(unsigned char *)(KBI0_BLOCK + 0x2)     // KBI0 Edge Select Register ('1' is rising edge / '0' is  falling edge)
    #if KBIS_AVAILABLE > 1
      #define KBI1_SC           *(volatile unsigned char *)(KBI1_BLOCK + 0x0) // KBI1 Status and Control Register
      #define KBI1_PE           *(unsigned char *)(KBI1_BLOCK + 0x1)     // KBI1 Pin Enable Register
      #define KBI1_ES           *(unsigned char *)(KBI1_BLOCK + 0x2)     // KBI1 Edge Select Register
    #endif

    typedef struct st_KINETIS_KBI                                        // KBI control struct
    {
        volatile unsigned char KBI_SC;
        unsigned char KBI_PE;
        unsigned char KBI_ES;
    } _KINETIS_KBI;
  #endif
#endif

// Power management controller
//
#define PMC_LVDSC1          *(volatile unsigned char *)(PMC_BLOCK + 0x0) // low voltage detect status and control 1 register
  #define PMC_LVDSC1_LVDV   0x01                                         // high trip point select
  #define PMC_LVDSC1_LVDRE  0x10                                         // low voltage detect reset enable
  #define PMC_LVDSC1_LVDIE  0x20                                         // low voltage detect interrupt enable
  #define PMC_LVDSC1_LVDACK 0x40                                         // write '1' to clear LVDF
  #define PMC_LVDSC1_LVDF   0x80                                         // low voltage detect flag (read-only)
#define PMC_LVDSC2          *(volatile unsigned char *)(PMC_BLOCK + 0x1) // low voltage detect status and control 2 register
  #define PMC_LVDSC2_LVWV_LOW  0x00                                      // low voltage warning voltage select - low
  #define PMC_LVDSC2_LVWV_MID1 0x01                                      // low voltage warning voltage select - mid 1
  #define PMC_LVDSC2_LVWV_MID2 0x02                                      // low voltage warning voltage select - mid 2
  #define PMC_LVDSC2_LVWV_HIGH 0x03                                      // low voltage warning voltage select - high
  #define PMC_LVDSC2_LVWIE     0x20                                      // low voltage warning interrupt enable
  #define PMC_LVDSC2_LVWACK    0x40                                      // write '1' to clear LVWF
  #define PMC_LVDSC1_LVWF      0x80                                      // low voltage warning flag (read-only)
#define PMC_REGSC           *(volatile unsigned char *)(PMC_BLOCK + 0x2) // regulator status and control 1 register
  #define PMC_REGSC_BGBE    0x01                                         // bandgap buffer enable
  #define PMC_REGSC_REGONS  0x04                                         // regulator in run regulation status
  #define PMC_REGSC_ACKISO  0x08                                         // acknowledge isolation
  #define PMC_REGSC_BGEN    0x10                                         // bandgap enable in VLPx operation

#if defined LLWU_AVAILABLE
// Low-Leakage Wakeup Unit
//
#define LLWU_PE1            *(unsigned char *)(LLWU_BLOCK + 0x0)         // LLWU Pin Enable 1 Register
  #define LLWU_PE_WUPE_MASK    0x03                                      // 4 pin settings per register
  #define LLWU_PE_WUPE_SHIFT   2
  #define LLWU_PE_WUPE_OFF     0x00                                      // external input pin disabled as wakeup pin
  #define LLWU_PE_WUPE_RISING  0x01                                      // external input pin enabled with rising edge detection
  #define LLWU_PE_WUPE_FALLING 0x02                                      // external input pin enabled with falling edge detection
  #define LLWU_PE_WUPE_CHANGE  0x03                                      // external input pin enabled with change detection
#define LLWU_PE2            *(unsigned char *)(LLWU_BLOCK + 0x1)         // LLWU Pin Enable 2 Register
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_ME         *(unsigned char *)(LLWU_BLOCK + 0x2)         // LLWU Module Enable Register
#else
    #define LLWU_PE3        *(unsigned char *)(LLWU_BLOCK + 0x2)         // LLWU Pin Enable 3 Register
    #define LLWU_PE4        *(unsigned char *)(LLWU_BLOCK + 0x3)         // LLWU Pin Enable 4 Register
    #define LLWU_ME         *(unsigned char *)(LLWU_BLOCK + 0x4)         // LLWU Module Enable Register
#endif
  #define LLWU_ME_WUME0     0x01                                         // internal module 0 flag used as wakeup source
  #define LLWU_ME_WUME1     0x02                                         // internal module 1 flag used as wakeup source
  #define LLWU_ME_WUME2     0x04                                         // internal module 2 flag used as wakeup source
  #define LLWU_ME_WUME3     0x08                                         // internal module 3 flag used as wakeup source
  #define LLWU_ME_WUME4     0x10                                         // internal module 4 flag used as wakeup source
  #define LLWU_ME_WUME5     0x20                                         // internal module 5 flag used as wakeup source
  #define LLWU_ME_WUME6     0x40                                         // internal module 6 flag used as wakeup source
  #define LLWU_ME_WUME7     0x80                                         // internal module 7 flag used as wakeup source
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_FLAG_ADDRESS (volatile unsigned char *)(LLWU_BLOCK + 0x3)
    #define LLWU_F1         *(volatile unsigned char *)(LLWU_BLOCK + 0x3)// LLWU Flag 1 Register
#else
    #define LLWU_FLAG_ADDRESS (volatile unsigned char *)(LLWU_BLOCK + 0x5)
    #define LLWU_F1         *(volatile unsigned char *)(LLWU_BLOCK + 0x5)// LLWU Flag 1 Register
#endif
  #define LLWU_F_WUF0       0x01                                         // wakeup flag indicating that this pin was a source of exiting a low-leakage power mode
  #define LLWU_F_WUF1       0x02                                         // write '1' to clear bits
  #define LLWU_F_WUF2       0x04
  #define LLWU_F_WUF3       0x08
  #define LLWU_F_WUF4       0x10
  #define LLWU_F_WUF5       0x20
  #define LLWU_F_WUF6       0x40
  #define LLWU_F_WUF7       0x80
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_F3         *(volatile unsigned char *)(LLWU_BLOCK + 0x4)// LLWU Flag 3 Register
    #define LLWU_FILT1      *(volatile unsigned char *)(LLWU_BLOCK + 0x5)// LLWU Pin Filter 1 Register
#else
    #define LLWU_F2         *(volatile unsigned char *)(LLWU_BLOCK + 0x6)// LLWU Flag 2 Register
    #define LLWU_F3         *(volatile unsigned char *)(LLWU_BLOCK + 0x7)// LLWU Flag 3 Register
    #define LLWU_FILT1      *(volatile unsigned char *)(LLWU_BLOCK + 0x8)// LLWU Pin Filter 1 Register
#endif
  #define LLWU_FILT_FILTSEL_0     0x00                                   // select filter on LLWU_P0
  #define LLWU_FILT_FILTSEL_1     0x01                                   // select filter on LLWU_P1
  #define LLWU_FILT_FILTSEL_2     0x02                                   // select filter on LLWU_P2
  #define LLWU_FILT_FILTSEL_3     0x03                                   // select filter on LLWU_P3
  #define LLWU_FILT_FILTSEL_4     0x04                                   // select filter on LLWU_P4
  #define LLWU_FILT_FILTSEL_5     0x05                                   // select filter on LLWU_P5
  #define LLWU_FILT_FILTSEL_6     0x06                                   // select filter on LLWU_P6
  #define LLWU_FILT_FILTSEL_7     0x07                                   // select filter on LLWU_P7
  #define LLWU_FILT_FILTSEL_8     0x08                                   // select filter on LLWU_P8
  #define LLWU_FILT_FILTSEL_9     0x09                                   // select filter on LLWU_P9
  #define LLWU_FILT_FILTSEL_10    0x0a                                   // select filter on LLWU_P10
  #define LLWU_FILT_FILTSEL_11    0x0b                                   // select filter on LLWU_P11
  #define LLWU_FILT_FILTSEL_12    0x0c                                   // select filter on LLWU_P12
  #define LLWU_FILT_FILTSEL_13    0x0d                                   // select filter on LLWU_P13
  #define LLWU_FILT_FILTSEL_14    0x0e                                   // select filter on LLWU_P14
  #define LLWU_FILT_FILTSEL_15    0x0f                                   // select filter on LLWU_P15
  #define LLWU_FILT_FILTE_OFF     0x00                                   // filter disabled (3 LPO clock cyle filtering - 3ms - with 2 additional LPO cycle clock delay = 5ms reaction time)
  #define LLWU_FILT_FILTE_RISING  0x20                                   // rising edge      
  #define LLWU_FILT_FILTE_FALLING 0x40                                   // fallin edge      
  #define LLWU_FILT_FILTE_CHANGE  0x60                                   // rising and falling edge     
  #define LLWU_FILT_FILTF         0x80                                   // filter detect flag (this was a source of low-leakage power mode exit (write '1' to clear))
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_FILT2      *(volatile unsigned char *)(LLWU_BLOCK + 0x6)// LLWU Pin Filter 2 Register
#else
    #define LLWU_FILT2      *(volatile unsigned char *)(LLWU_BLOCK + 0x9)// LLWU Pin Filter 2 Register
    #define LLWU_RST        *(unsigned char *)(LLWU_BLOCK + 0xa)         // LLWUReset Enable Register
      #define LLWU_RST_RSTFILT    0x01                                   // digital filtere on reset pin
      #define LLWU_RST_LLRSTE     0x02                                   // low leakage mode reset enable
#endif

#define LLWU_P0    0
#define LLWU_P1    1
#define LLWU_P2    2
#define LLWU_P3    3
#define LLWU_P4    4
#define LLWU_P5    5
#define LLWU_P6    6
#define LLWU_P7    7
#define LLWU_P8    8
#define LLWU_P9    9
#define LLWU_P10   10
#define LLWU_P11   11
#define LLWU_P12   12
#define LLWU_P13   13
#define LLWU_P14   14
#define LLWU_P15   15
#define NO_WAKEUP 0xff
#endif

#if defined KINETIS_KE
// IRQ
//
#define IRQ_SC              *(volatile unsigned char *)(IRQ_BLOCK + 0x0) // Interrupt Pin Request Status and Control Register
  #define IRQ_SC_IRQMOD     0x01                                         // IRQ detection mode ('1' level sensitive as well as edge sensitive)
  #define IRQ_SC_IRQIE      0x02                                         // IRQ interrupt enable
  #define IRQ_SC_IRQACK     0x04                                         // IRQ interrupt acknowledge (write '1' to clear IRQF)
  #define IRQ_SC_IRQF       0x08                                         // IRQ flag (read-only)
  #define IRQ_SC_IRQPE      0x10                                         // IRQ pin function enable
  #define IRQ_SC_IRQEDG     0x20                                         // IRQ edge select ('0' for falling edge/low sensitive, '1' for rising edge/high sensitive)
  #define IRQ_SC_IRQPDD     0x40                                         // IRQ pull-up disable
#endif

// CRC                                                                   {8}
//
#define CRC_CRC             *(volatile unsigned long *)(CRC_BLOCK + 0x0) // CRC Data Register
#define CRC_CRC_LL_SHORT_WORD_ACCESS *(volatile unsigned short *)(CRC_BLOCK + 0x0) // CRC Data Register - short word access
#define CRC_CRC_LL          *(volatile unsigned char *)(CRC_BLOCK + 0x0) // CRC Data Register - byte accesses
#define CRC_CRC_LU          *(volatile unsigned char *)(CRC_BLOCK + 0x1) // CRC Data Register - byte accesses
#define CRC_CRC_HL          *(volatile unsigned char *)(CRC_BLOCK + 0x2) // CRC Data Register - byte accesses
#define CRC_CRC_HU          *(volatile unsigned char *)(CRC_BLOCK + 0x3) // CRC Data Register - byte accesses
#define CRC_GPOLY           *(volatile unsigned long *)(CRC_BLOCK + 0x4) // CRC Polynomial Register
#define CRC_CTRL            *(volatile unsigned long *)(CRC_BLOCK + 0x8) // CRC Control Register
  #define CRC_CTRL_TCRC_16  0x00000000
  #define CRC_CTRL_TCRC_32  0x01000000
  #define CRC_CTRL_WAS      0x02000000                                   // writes to CRC data register are seed values
  #define CRC_CTRL_FXOR     0x04000000                                   // invert of complement the read value of the CRC data register
  #define CRC_CTRL_TOTR_BITS       0x10000000                            // value read from CRC data register is transposed - bits transposed but not bytes
  #define CRC_CTRL_TOTR_BITS_BYTES 0x20000000                            // value read from CRC data register is transposed - bits and bytes transposed
  #define CRC_CTRL_TOTR_BYTES      0x30000000                            // value read from CRC data register is transposed - bytes transposed but not bits
  #define CRC_CTRL_TOT_BITS        0x40000000                            // value written to CRC data register is transposed - bits transposed but not bytes
  #define CRC_CTRL_TOT_BITS_BYTES  0x80000000                            // value written to CRC data register is transposed - bits and bytes transposed
  #define CRC_CTRL_TOT_BYTES       0xc0000000                            // value written to CRC data register is transposed - bytes transposed but not bits


#if defined PWT_AVAILABLE
// PWT (Pulse Width Timer)                                               {88}
//
#define PWT_R1             *(volatile unsigned long *)(PWT_BLOCK + 0x0)  // pulse width register 1
  #define PWT_R1_PWTOV     0x00000001                                    // PWT counter overflow (write '0' to clear)
  #define PWT_R1_PWTRDY    0x00000002                                    // PWT pulse width valid
  #define PWT_R1_PWTSR     0x00000008                                    // PWT soft reset (write-only to command)
  #define PWT_R1_POVIE     0x00000010                                    // PWT conter overflow interrupt enable
  #define PWT_R1_PRDYIE    0x00000020                                    // PWT pulse width data ready interrupt enable
  #define PWT_R1_PWTIE     0x00000040                                    // PWT module interrupt enable
  #define PWT_R1_PWTEN     0x00000080                                    // PWT module enable
  #define PWT_R1_PRE_1     0x00000000                                    // PWT clock preselect (CLKPRE) setting - divide by 1
  #define PWT_R1_PRE_2     0x00000100                                    // PWT clock preselect (CLKPRE) setting - divide by 2
  #define PWT_R1_PRE_4     0x00000200                                    // PWT clock preselect (CLKPRE) setting - divide by 4
  #define PWT_R1_PRE_8     0x00000300                                    // PWT clock preselect (CLKPRE) setting - divide by 8
  #define PWT_R1_PRE_16    0x00000400                                    // PWT clock preselect (CLKPRE) setting - divide by 16
  #define PWT_R1_PRE_32    0x00000500                                    // PWT clock preselect (CLKPRE) setting - divide by 32
  #define PWT_R1_PRE_64    0x00000600                                    // PWT clock preselect (CLKPRE) setting - divide by 64
  #define PWT_R1_PRE_128   0x00000700                                    // PWT clock preselect (CLKPRE) setting - divide by 128
  #define PWT_R1_EDGE_FALLING      0x00000000                            // PWT input edge sensitivity - first falling edge starts the pulse width measurement and on all subsequent falling edges the pulse width is captured
  #define PWT_R1_EDGE_RISING_BOTH  0x00000800                            // PWT input edge sensitivity - first rising edge starts the pulse width measurement and on all subsequent rising and falling edges the pulse width is captured
  #define PWT_R1_EDGE_FALLING_BOTH 0x00000800                            // PWT input edge sensitivity - first falling edge starts the pulse width measurement and on all subsequent rising and falling edges the pulse width is captured
  #define PWT_R1_EDGE_RISING       0x00001800                            // PWT input edge sensitivity - first rising edge starts the pulse width measurement and on all subsequent rising edges the pulse width is captured
  #define PWT_R1_PINSEL_0  0x00000000                                    // PWT pulse input selection - enable PWTIN0
  #define PWT_R1_PINSEL_1  0x00002000                                    // PWT pulse input selection - enable PWTIN1
  #define PWT_R1_PINSEL_2  0x00004000                                    // PWT pulse input selection - enable PWTIN2
  #define PWT_R1_PINSEL_3  0x00006000                                    // PWT pulse input selection - enable PWTIN3
  #define PWT_R1_PCLKS     0x00008000                                    // PWT clock source selection - select alternative clock source
  #define PWT_R1_PPW_MASK  0xffff0000                                    // positive pulse width (read-only)
#define PWT_R2             *(volatile unsigned long *)(PWT_BLOCK + 0x4)  // pulse width register 2 (read-only)
  #define PWT_R2_NPW_MASK  0x0000ffff                                    // PWT counter
  #define PWT_R2_PWTC_MASK 0xffff0000                                    // negative pulse width
#endif

#if !defined KINETIS_KL && !defined KINETIS_KE                           // {42}
// PDB (Programmable Delay Block)                                        {31}
//
#define PDB0_SC             *(volatile unsigned long *)(PDB_BLOCK + 0x000) // status and control register
  #define PDB_SC_LDOK       0x00000001                                   // load OK (write 1)
  #define PDB_SC_ONE_SHOT   0x00000000                                   // one-shot mode
  #define PDB_SC_CONT       0x00000002                                   // continuous mode
  #define PDB_SC_MULT_1     0x00000000                                   // prescaler multiplication is 1
  #define PDB_SC_MULT_10    0x00000004                                   // prescaler multiplication is 10
  #define PDB_SC_MULT_20    0x00000008                                   // prescaler multiplication is 20
  #define PDB_SC_MULT_40    0x0000000c                                   // prescaler multiplication is 40
  #define PDB_SC_PDBIE      0x00000020                                   // PDB interrupt enable
  #define PDB_SC_PDBIF      0x00000040                                   // PDB interrupt flag (write 0 to clear)
  #define PDB_SC_PDBEN      0x00000080                                   // PDB enabed
  #define PDB_SC_TRGSEL_0   0x00000000                                   // trigger source input select - trigger 0  [external trigger]
  #define PDB_SC_TRGSEL_1   0x00000100                                   // trigger source input select - trigger 1  [CMP0]
  #define PDB_SC_TRGSEL_2   0x00000200                                   // trigger source input select - trigger 2  [CMP1]
  #define PDB_SC_TRGSEL_3   0x00000300                                   // trigger source input select - trigger 3  [CMP2]
  #define PDB_SC_TRGSEL_4   0x00000400                                   // trigger source input select - trigger 4  [PIT 0]
  #define PDB_SC_TRGSEL_5   0x00000500                                   // trigger source input select - trigger 5  [PIT 1]
  #define PDB_SC_TRGSEL_6   0x00000600                                   // trigger source input select - trigger 6  [PIT 2]
  #define PDB_SC_TRGSEL_7   0x00000700                                   // trigger source input select - trigger 7  [PIT 3]
  #define PDB_SC_TRGSEL_8   0x00000800                                   // trigger source input select - trigger 8  [FTM0]
  #define PDB_SC_TRGSEL_9   0x00000900                                   // trigger source input select - trigger 9  [FTM1]
  #define PDB_SC_TRGSEL_10  0x00000a00                                   // trigger source input select - trigger 10 [FTM2]
  #define PDB_SC_TRGSEL_11  0x00000b00                                   // trigger source input select - trigger 11 [reserved]
  #define PDB_SC_TRGSEL_12  0x00000c00                                   // trigger source input select - trigger 12 [RTC alarm]
  #define PDB_SC_TRGSEL_13  0x00000d00                                   // trigger source input select - trigger 13 [RTC seconds]
  #define PDB_SC_TRGSEL_14  0x00000e00                                   // trigger source input select - trigger 14 [LPTMR]
  #define PDB_SC_TRGSEL_SW  0x00000f00                                   // trigger source input select - software trigger
  #define PDB_SC_PRESCALER_1   0x00000000                                // counting uses the peripheral clock divided by the multiplication factor MULT
  #define PDB_SC_PRESCALER_2   0x00001000                                // counting uses the peripheral clock divided by 2 times of the multiplicaion factor MULT
  #define PDB_SC_PRESCALER_4   0x00002000                                // counting uses the peripheral clock divided by 4 times of the multiplicaion factor MULT
  #define PDB_SC_PRESCALER_8   0x00003000                                // counting uses the peripheral clock divided by 8 times of the multiplicaion factor MULT
  #define PDB_SC_PRESCALER_16  0x00004000                                // counting uses the peripheral clock divided by 16 times of the multiplicaion factor MULT
  #define PDB_SC_PRESCALER_32  0x00005000                                // counting uses the peripheral clock divided by 32 times of the multiplicaion factor MULT
  #define PDB_SC_PRESCALER_64  0x00006000                                // counting uses the peripheral clock divided by 64 times of the multiplicaion factor MULT
  #define PDB_SC_PRESCALER_128 0x00007000                                // counting uses the peripheral clock divided by 128 times of the multiplicaion factor MULT
  #define PDB_SC_DMAEN      0x00008000                                   // DMA enable
  #define PDB_SC_SWTRIG     0x00010000                                   // reset and restart the counter in software trigger mode (write 1)
  #define PDB_SC_PDBEIE     0x00020000                                   // PDB sequence error interrupt enabled
  #define PDB_SC_LDMOD_IMM      0x00000000                               // load mode (after LDOK) - load immediately
  #define PDB_SC_LDMOD_MOD      0x00040000                               // load mode (after LDOK) - load when either PDB counter reaches the MOD value
  #define PDB_SC_LDMOD_TRIG     0x00080000                               // load mode (after LDOK) - load when a trigger input event is detected
  #define PDB_SC_LDMOD_MOD_TRIG 0x000c0000                               // load mode (after LDOK) - load when either PDB counter reaches the MOD value or a trigger input event is detected
#define PDB0_MOD            *(volatile unsigned long *)(PDB_BLOCK + 0x004) // modulus register (16 LSBs only) - only loaded after PDB_SC_LDOK has been set
#define PDB0_CNT            *(volatile unsigned long *)(PDB_BLOCK + 0x008) // counter register (16 LSBs only) (read-only)
#define PDB0_IDLY           *(volatile unsigned long *)(PDB_BLOCK + 0x00c) // interrupt delay register (16 LSBs only) - only loaded after PDB_SC_LDOK has been set
#define PDB0_CH0C1          *(unsigned long *)(PDB_BLOCK + 0x010)        // channel 0 control register 1
  #define PDB_C1_EN_0       0x00000001                                   // PDB channel 0 pre-trigger enable
  #define PDB_C1_EN_1       0x00000002                                   // PDB channel 1 pre-trigger enable
  #define PDB_C1_EN_2       0x00000004                                   // PDB channel 2 pre-trigger enable
  #define PDB_C1_EN_3       0x00000008                                   // PDB channel 3 pre-trigger enable
  #define PDB_C1_TOS_0      0x00000100                                   // PDB channel 0 pre-trigger output select
  #define PDB_C1_TOS_1      0x00000200                                   // PDB channel 1 pre-trigger output select
  #define PDB_C1_TOS_2      0x00000400                                   // PDB channel 2 pre-trigger output select
  #define PDB_C1_TOS_3      0x00000800                                   // PDB channel 3 pre-trigger output select
  #define PDB_C1_BB_0       0x00010000                                   // PDB channel 0 pre-trigger back-to-back operation enable
  #define PDB_C1_BB_1       0x00020000                                   // PDB channel 1 pre-trigger back-to-back operation enable
  #define PDB_C1_BB_2       0x00040000                                   // PDB channel 2 pre-trigger back-to-back operation enable
  #define PDB_C1_BB_3       0x00080000                                   // PDB channel 3 pre-trigger back-to-back operation enable
#define PDB0_CH0S           *(volatile unsigned long *)(PDB_BLOCK + 0x014) // channel 0 status register
  #define PDB_S_ERR_0       0x00000001                                   // channel sequence error flag - channel 0 (write 0 to clear)
  #define PDB_S_ERR_1       0x00000002                                   // channel sequence error flag - channel 1 (write 0 to clear)
  #define PDB_S_ERR_2       0x00000004                                   // channel sequence error flag - channel 2 (write 0 to clear)
  #define PDB_S_ERR_3       0x00000008                                   // channel sequence error flag - channel 3 (write 0 to clear)
  #define PDB_S_CF_0        0x00010000                                   // channel counter match flag - channel 0 (write 0 to clear)
  #define PDB_S_CF_1        0x00020000                                   // channel counter match flag - channel 1 (write 0 to clear)
  #define PDB_S_CF_2        0x00040000                                   // channel counter match flag - channel 2 (write 0 to clear)
  #define PDB_S_CF_3        0x00080000                                   // channel counter match flag - channel 3 (write 0 to clear)
#define PDB0_CH0DLY0        *(unsigned long *)(PDB_BLOCK + 0x018)        // channel 0 delay 0 register (16 LSBs only)
#define PDB0_CH0DLY1        *(unsigned long *)(PDB_BLOCK + 0x01c)        // channel 0 delay 1 register (16 LSBs only)
  #if ADC_CONTROLLERS > 1
    #define PDB0_CH1C1      *(unsigned long *)(PDB_BLOCK + 0x038)        // channel 1 control register 1
    #define PDB0_CH1S       *(volatile unsigned long *)(PDB_BLOCK + 0x03c) // channel 1 status register
    #define PDB0_CH1DLY0    *(unsigned long *)(PDB_BLOCK + 0x040)        // channel 1 delay 0 register (16 LSBs only)
    #define PDB0_CH1DLY1    *(unsigned long *)(PDB_BLOCK + 0x044)        // channel 1 delay 1 register (16 LSBs only)
  #endif
#endif

#if ADC_CONTROLLERS > 2
    #define PDB0_CH2C1      *(unsigned long *)(PDB_BLOCK + 0x060)        // channel 2 control register 1
    #define PDB0_CH2S       *(volatile unsigned long *)(PDB_BLOCK + 0x064) // channel 2 status register
    #define PDB0_CH2DLY0    *(unsigned long *)(PDB_BLOCK + 0x068)        // channel 2 delay 0 register (16 LSBs only)
    #define PDB0_CH2DLY1    *(unsigned long *)(PDB_BLOCK + 0x06c)        // channel 2 delay 1 register (16 LSBs only)

    #define PDB0_CH3C1      *(unsigned long *)(PDB_BLOCK + 0x088)        // channel 3 control register 1
    #define PDB0_CH3S       *(volatile unsigned long *)(PDB_BLOCK + 0x08c) // channel 3 status register
    #define PDB0_CH3DLY0    *(unsigned long *)(PDB_BLOCK + 0x090)        // channel 3 delay 0 register (16 LSBs only)
    #define PDB0_CH3DLY1    *(unsigned long *)(PDB_BLOCK + 0x094)        // channel 3 delay 1 register (16 LSBs only)
#endif
#define PDB0_DACINTC0       *(unsigned long *)(PDB_BLOCK + 0x150)        // DAC interval trigger 0 control register
  #define PDB_DACINTC0_TOE  0x00000001                                   // DAC interval trigger enable
  #define PDB_DACINTC0_EXT  0x00000002                                   // DAC external trigger input enable
#define PDB0_DACINT0        *(unsigned long *)(PDB_BLOCK + 0x154)        // DAC interval 0 register (16 LSBs only)
#define PDB0_DACINTC1       *(unsigned long *)(PDB_BLOCK + 0x158)        // DAC interval trigger 1 control register
#define PDB0_DACINT1        *(unsigned long *)(PDB_BLOCK + 0x15c)        // DAC interval 1 register (16 LSBs only)

#define PDB0_POEN           *(unsigned long *)(PDB_BLOCK + 0x190)        // pulse-out enable register
  #define PDB_POEN_0        0x00000001                                   // pulse-out enabled on channel 0
  #define PDB_POEN_1        0x00000002                                   // pulse-out enabled on channel 1
  #define PDB_POEN_2        0x00000004                                   // pulse-out enabled on channel 2
  #define PDB_POEN_3        0x00000008                                   // pulse-out enabled on channel 3
  #define PDB_POEN_4        0x00000010                                   // pulse-out enabled on channel 4
  #define PDB_POEN_5        0x00000020                                   // pulse-out enabled on channel 5
  #define PDB_POEN_6        0x00000040                                   // pulse-out enabled on channel 6
  #define PDB_POEN_7        0x00000080                                   // pulse-out enabled on channel 7
#define PDB0_PO0DLY         *(unsigned long *)(PDB_BLOCK + 0x194)        // pulse-out 0 delay register
#define PDB0_PO1DLY         *(unsigned long *)(PDB_BLOCK + 0x198)        // pulse-out 1 delay register
#define PDB0_PO2DLY         *(unsigned long *)(PDB_BLOCK + 0x19c)        // pulse-out 2 delay register

// PIT Timers
//
#define PIT_MCR             *(volatile unsigned long *)(PIT_BLOCK + 0x000) // PIT Module Control Register
  #define PIT_MCR_FRZ       0x00000001                                   // timers are stopped in debug mode
  #define PIT_MCR_MDIS      0x00000002                                   // clock for PIT timers is disabled
#if defined KINETIS_KL                                                   // {47}
    #define PIT_LTMR64H     *(volatile unsigned long *)(PIT_BLOCK + 0x0e0) // PIT Upper Lifetime Timer Register (read-only)
    #define PIT_LTMR64L     *(volatile unsigned long *)(PIT_BLOCK + 0x0e4) // PIT Lower Lifetime Timer Register (read-only)
#endif
#define PIT_CTL_ADD         (unsigned long *)(PIT_BLOCK + 0x100)
#define PIT_LDVAL0          *(unsigned long *)(PIT_BLOCK + 0x100)        // PIT 0 Timer Load Value Register
#define PIT_CVAL0           *(volatile unsigned long *)(PIT_BLOCK + 0x104) // PIT 0 Current Timer Value Register
#define PIT_TCTRL0          *(volatile unsigned long *)(PIT_BLOCK + 0x108) // {5} PIT 0 Timer Control Register
  #define PIT_TCTRL_TEN     0x00000001                                   // timer enable
  #define PIT_TCTRL_TIE     0x00000002                                   // timer interrupt enable
#if defined KINETIS_KL                                                   // {47}
    #define PIT_TCTRL_CHN   0x00000004                                   // chain mode
#endif
#define PIT_TFLG0           *(volatile unsigned long *)(PIT_BLOCK + 0x10c) // PIT 0 Timer Flag Register
  #define PIT_TFLG_TIF      0x00000001                                   // time out has occurred (write 1 to clear)
#define PIT_LDVAL1          *(unsigned long *)(PIT_BLOCK + 0x110)        // PIT 1 Timer Load Value Register
#define PIT_CVAL1           *(volatile unsigned long *)(PIT_BLOCK + 0x114) // PIT 1 Current Timer Value Register
#define PIT_TCTRL1          *(volatile unsigned long *)(PIT_BLOCK + 0x118) // {5} PIT 1 Timer Control Register
#define PIT_TFLG1           *(volatile unsigned long *)(PIT_BLOCK + 0x11c) // PIT 1 Timer Flag Register
#if PITS_AVAILABLE == 4
    #define PIT_LDVAL2      *(unsigned long *)(PIT_BLOCK + 0x120)        // PIT 2 Timer Load Value Register
    #define PIT_CVAL2       *(volatile unsigned long *)(PIT_BLOCK + 0x124) // PIT 2 Current Timer Value Register
    #define PIT_TCTRL2      *(volatile unsigned long *)(PIT_BLOCK + 0x128) // {5} PIT 2 Timer Control Register
    #define PIT_TFLG2       *(volatile unsigned long *)(PIT_BLOCK + 0x12c) // PIT 2 Timer Flag Register
    #define PIT_LDVAL3      *(unsigned long *)(PIT_BLOCK + 0x130)        // PIT 3 Timer Load Value Register
    #define PIT_CVAL3       *(volatile unsigned long *)(PIT_BLOCK + 0x134) // PIT 3 Current Timer Value Register
    #define PIT_TCTRL3      *(volatile unsigned long *)(PIT_BLOCK + 0x138) // {5} PIT 3 Timer Control Register
    #define PIT_TFLG3       *(volatile unsigned long *)(PIT_BLOCK + 0x13c) // PIT 3 Timer Flag Register
#endif

typedef struct stKINETIS_PIT_CTL                                         // PIT channel control struct
{
    unsigned long PIT_LDVAL;
    volatile unsigned long PIT_CVAL;
    volatile unsigned long PIT_TCTRL;                                    // {5}
    volatile unsigned long PIT_TFLG;
} KINETIS_PIT_CTL;



#if defined _WINDOWS
    #define LOAD_PIT(x, load_val)    PIT_LDVAL##x = (load_val); PIT_CVAL##x = (load_val)
#else
    #define LOAD_PIT(x, load_val)    PIT_TCTRL##x = 0; PIT_LDVAL##x = (load_val)
#endif


// FlexTimer (or TPM in KL/KE parts)
//
#define FTM0_SC             *(volatile unsigned long *)(FTM_BLOCK_0 + 0x000) // FTM0 Status and Control
  #define FTM_SC_PS_1       0x00000000                                   // clock prescaler / 1
  #define FTM_SC_PS_2       0x00000001                                   // clock prescaler / 2
  #define FTM_SC_PS_4       0x00000002                                   // clock prescaler / 4
  #define FTM_SC_PS_8       0x00000003                                   // clock prescaler / 8
  #define FTM_SC_PS_16      0x00000004                                   // clock prescaler / 16
  #define FTM_SC_PS_32      0x00000005                                   // clock prescaler / 32
  #define FTM_SC_PS_64      0x00000006                                   // clock prescaler / 64
  #define FTM_SC_PS_128     0x00000007                                   // clock prescaler / 128
  #define FTM_SC_CLKS_OFF   0x00000000                                   // clock source - no clock
  #define FTM_SC_CLKS_SYS   0x00000008                                   // clock source - system clock
 #if defined KINETIS_KL
  #define FTM_SC_CLKS_EXT   0x00000010                                   // clock source - TPM_EXTCLK (rising edge)
  #define FTM_SC_DMA        0x00000100                                   // DMA enable
 #else
  #define FTM_SC_CLKS_FIX   0x00000010                                   // clock source - fixed clock is MCGFFCLK
  #define FTM_SC_CLKS_EXT   0x00000018                                   // clock source - external clock
  #define FTM_SC_DMA        0x00000100                                   // for compatibility (not available in flex timer but is avaialble in TPM)
 #endif
  #define FTM_SC_CPWMS      0x00000020                                   // centre-aligned PWM select (FTM operates in up/down counting mode rather than up counting mode)
  #define FTM_SC_TOIE       0x00000040                                   // timer overflow interrupt enable
  #define FTM_SC_TOF        0x00000080                                   // timer overflow flag (write '1' to clear)
  #define FTM_SC_USED_MASK  0x00000fff                                   // mask of non-reserved bits in the register
  #define FLEX_TIMER_SINGLE_SHOT 0x0000                                  // pseudo bits for mode control
  #define FLEX_TIMER_PERIODIC    0x1000
#define FTM0_CNT            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x004) // FTM0 Counter (16 bit)
#define FTM0_MOD            *(unsigned long *)(FTM_BLOCK_0 + 0x008)      // FTM0 Modulo (16 bit)
#define FTM0_C0SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x00c) // FTM0 Channel 0 and Control
  #define FTM_CSC_DMA       0x00000001                                   // enable DMA transfers
  #define FTM_CSC_ELSA      0x00000004                                   // edge or level select select A (only writable when MODE[WPDIS] is set)
  #define FTM_CSC_ELSB      0x00000008                                   // edge or level select select B (only writable when MODE[WPDIS] is set)
  #define FTM_CSC_MSA       0x00000010                                   // channel mode select A (only writable when MODE[WPDIS] is set)
  #define FTM_CSC_MSB       0x00000020                                   // channel mode select B (only writable when MODE[WPDIS] is set)
  #define FTM_CSC_CHIE      0x00000040                                   // channel interrupt enable
  #define FTM_CSC_CHF       0x00000080                                   // channel event flag (read-only)

  #define FTM_CSC_MS_ELS_PWM_HIGH_TRUE_PULSES (FTM_CSC_MSB | FTM_CSC_ELSB) // PWM - high-true pulses (clear output on match)
  #define FTM_CSC_MS_ELS_PWM_LOW_TRUE_PULSES  (FTM_CSC_MSB | FTM_CSC_ELSA) // PWM - low-true pulses (set output on match)

#define FTM0_C0V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x010) // FTM0 Channel 0 Value (16 bit)
#define FTM0_C1SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x014) // FTM0 Channel 1 and Control
#define FTM0_C1V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x018) // FTM0 Channel 1 Value (16 bit)
#define FTM0_C2SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x01c) // FTM0 Channel 2 and Control
#define FTM0_C2V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x020) // FTM0 Channel 2 Value (16 bit)
#define FTM0_C3SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x024) // FTM0 Channel 3 and Control
#define FTM0_C3V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x028) // FTM0 Channel 3 Value (16 bit)
#define FTM0_C4SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x02c) // FTM0 Channel 4 and Control
#define FTM0_C4V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x030) // FTM0 Channel 4 Value (16 bit)
#define FTM0_C5SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x034) // FTM0 Channel 5 and Control
#define FTM0_C5V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x038) // FTM0 Channel 5 Value (16 bit)
#if defined KINETIS_KL || defined KINETIS_KE
    #define FTM0_STATUS         *(volatile unsigned long *)(FTM_BLOCK_0 + 0x050) // FTM0 Capture and Compare Status
    #define FTM0_CONF           *(unsigned long *)(FTM_BLOCK_0 + 0x084)      // FTM0 Configuration
      #define FTM_CONF_DOZEEN   0x00000020                                   // FTM doze enable
      #define FTM_CONF_BDMMODE_0  0x00000000                                 // FTM counter stops in bdm mode
      #define FTM_CONF_BDMMODE_3  0x000000c0                                 // FTM counter continues in bdm mode
      #define FTM_CONF_GTBEEN   0x00000200                                   // use of an external global time base is enabled
      #define FTM_CONF_GTBEOUT  0x00000400                                   // global time base signal generation enabled
      #define FTM_CONF_CSOT     0x00010000                                   // counter start on trigger
      #define FTM_CONF_CSOO     0x00020000                                   // counter stop on overflow
      #define FTM_CONF_CROT     0x00040000                                   // counter reload on trigger
      #define FTM_CONF_TRGSEL   0x00000000                                   // (change only when TPM is disabled)
#else
    #define FTM0_C6SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x03c) // FTM0 Channel 6 and Control
    #define FTM0_C6V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x040) // FTM0 Channel 6 Value (16 bit)
    #define FTM0_C7SC           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x044) // FTM0 Channel 7 and Control
    #define FTM0_C7V            *(volatile unsigned long *)(FTM_BLOCK_0 + 0x048) // FTM0 Channel 7 Value (16 bit)
    #define FTM0_CNTIN          *(volatile unsigned long *)(FTM_BLOCK_0 + 0x04c) // FTM0 Counter Initial Value (16 bit)
    #define FTM0_STATUS         *(volatile unsigned long *)(FTM_BLOCK_0 + 0x050) // FTM0 Capture and Compare Status
    #define FTM0_MODE           *(volatile unsigned long *)(FTM_BLOCK_0 + 0x054) // FTM0 Features Mode Selection
      #define FTM_MODE_FTMEN    0x00000001                                   // FTM enable (can only be written when WPDIS is '1')
      #define FTM_MODE_INIT     0x00000002                                   // initialise the channels output (always read as '0')
      #define FTM_MODE_WPDIS    0x00000004                                   // write protection disable (read-only - opposite polarity to WPEN)
      #define FTM_MODE_PWMSYNC  0x00000008                                   // PWM synchronisation mode
      #define FTM_MODE_CAPTEST  0x00000010                                   // capture test mode enable
      #define FTM_MODE_FAULT_DIS  0x00000000                                 // fault control disabled
      #define FTM_MODE_FAULT_EVEN 0x00000020                                 // fault control enabled for even channels (manual fault clearing)
      #define FTM_MODE_FAULT_MAN  0x00000040                                 // fault control enabled for all channels (manual fault clearing)
      #define FTM_MODE_FAULT_AUTO 0x00000060                                 // fault control enabled for all channels (automatic fault clearing)
      #define FTM_MODE_FAULTIE  0x00000080                                   // fault interrupt enable
    #define FTM0_SYNC           *(unsigned long *)(FTM_BLOCK_0 + 0x058)      // FTM0 Synchronisation
    #define FTM0_OUTINIT        *(unsigned long *)(FTM_BLOCK_0 + 0x05c)      // FTM0 Initial State for Channels Output
    #define FTM0_OUTMASK        *(unsigned long *)(FTM_BLOCK_0 + 0x060)      // FTM0 Output Mask
    #define FTM0_COMBINE        *(unsigned long *)(FTM_BLOCK_0 + 0x064)      // FTM0 Function for Linked Channels
    #define FTM0_DEADTIME       *(unsigned long *)(FTM_BLOCK_0 + 0x068)      // FTM0 Deadtime Insertion Control
    #define FTM0_EXTTRIG        *(unsigned long *)(FTM_BLOCK_0 + 0x06c)      // FTM0 External Trigger
    #define FTM0_POL            *(unsigned long *)(FTM_BLOCK_0 + 0x070)      // FTM0 Channels Polarity
      #define FTM_POL_POL0_LOW 0x00000001                                    // active low
      #define FTM_POL_POL1_LOW 0x00000002                                    // active low
      #define FTM_POL_POL2_LOW 0x00000004                                    // active low
      #define FTM_POL_POL3_LOW 0x00000008                                    // active low
      #define FTM_POL_POL4_LOW 0x00000010                                    // active low
      #define FTM_POL_POL5_LOW 0x00000020                                    // active low
      #define FTM_POL_POL6_LOW 0x00000040                                    // active low
      #define FTM_POL_POL7_LOW 0x00000080                                    // active low
    #define FTM0_FMS            *(unsigned long *)(FTM_BLOCK_0 + 0x074)      // FTM0 Fault Mode Status
    #define FTM0_FILTER         *(unsigned long *)(FTM_BLOCK_0 + 0x078)      // FTM0 Input Capture Filter Control
    #define FTM0_FLTCTRL        *(unsigned long *)(FTM_BLOCK_0 + 0x07c)      // FTM0 Fault Control
    #define FTM0_QDCTRL         *(unsigned long *)(FTM_BLOCK_0 + 0x080)      // FTM0 Quadrature Decoder Control and Status
    #define FTM0_CONF           *(unsigned long *)(FTM_BLOCK_0 + 0x084)      // FTM0 Configuration
      #define FTM_CONF_NUMTOF   0x0000001f                                   // FOT frequency mask
      #define FTM_CONF_BDMMODE_0  0x00000000                                 // FTM counter stops in bdm mode
      #define FTM_CONF_BDMMODE_1  0x00000040                                 // FTM counter stops and outputs set to safe state value in bdm mode (not KL parts)
      #define FTM_CONF_BDMMODE_2  0x00000080                                 // FTM counter stops and outputs are frozen in bdm mode
      #define FTM_CONF_BDMMODE_3  0x000000c0                                 // FTM counter continues in bdm mode
      #define FTM_CONF_GTBEEN   0x00000200                                   // use of an external global time base is enabled
      #define FTM_CONF_GTBEOUT  0x00000400                                   // global time base signal generation enabled
    #define FTM0_FLTPOL         *(unsigned long *)(FTM_BLOCK_0 + 0x088)      // FTM0 Fault Input Polarity
    #define FTM0_SYNCONF        *(unsigned long *)(FTM_BLOCK_0 + 0x08c)      // FTM0 Synchronisation Configuration
    #define FTM0_INVCTRL        *(unsigned long *)(FTM_BLOCK_0 + 0x090)      // FTM0 Inverting Control
    #define FTM0_SWOCTRL        *(unsigned long *)(FTM_BLOCK_0 + 0x094)      // FTM0 Software Output Control
    #define FTM0_PWMLOAD        *(unsigned long *)(FTM_BLOCK_0 + 0x098)      // FTM0 PWM Load
#endif
#define FTM1_SC             *(volatile unsigned long *)(FTM_BLOCK_1 + 0x000) // FTM1 Status and Control
#define FTM1_CNT            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x004) // FTM1 Counter
#define FTM1_MOD            *(unsigned long *)(FTM_BLOCK_1 + 0x008)      // FTM1 Modulo
#define FTM1_C0SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x00c) // FTM1 Channel 0 and Control
#define FTM1_C0V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x010) // FTM1 Channel 0 Value
#define FTM1_C1SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x014) // FTM1 Channel 1 and Control
#define FTM1_C1V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x018) // FTM1 Channel 1 Value
#define FTM1_C2SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x01c) // FTM1 Channel 2 and Control
#define FTM1_C2V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x020) // FTM1 Channel 2 Value
#define FTM1_C3SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x024) // FTM1 Channel 3 and Control
#define FTM1_C3V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x028) // FTM1 Channel 3 Value
#define FTM1_C4SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x02c) // FTM1 Channel 4 and Control
#define FTM1_C4V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x030) // FTM1 Channel 4 Value
#define FTM1_C5SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x034) // FTM1 Channel 5 and Control
#define FTM1_C5V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x038) // FTM1 Channel 5 Value
#if defined KINETIS_KL || defined KINETIS_KE
    #define FTM1_STATUS         *(volatile unsigned long *)(FTM_BLOCK_1 + 0x050) // FTM1 Capture and Compare Status
    #define FTM1_CONF           *(unsigned long *)(FTM_BLOCK_1 + 0x084)      // FTM1 Configuration
#else
    #define FTM1_C6SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x03c) // FTM1 Channel 6 and Control
    #define FTM1_C6V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x040) // FTM1 Channel 6 Value
    #define FTM1_C7SC           *(volatile unsigned long *)(FTM_BLOCK_1 + 0x044) // FTM1 Channel 7 and Control
    #define FTM1_C7V            *(volatile unsigned long *)(FTM_BLOCK_1 + 0x048) // FTM1 Channel 7 Value
    #define FTM1_CNTIN          *(volatile unsigned long *)(FTM_BLOCK_1 + 0x04c) // FTM1 Counter Initial Value
    #define FTM1_STATUS         *(volatile unsigned long *)(FTM_BLOCK_1 + 0x050) // FTM1 Capture and Compare Status
    #define FTM1_MODE           *(unsigned long *)(FTM_BLOCK_1 + 0x054)      // FTM1 Features Mode Selection
    #define FTM1_SYNC           *(unsigned long *)(FTM_BLOCK_1 + 0x058)      // FTM1 Synchronisation
    #define FTM1_OUTINIT        *(unsigned long *)(FTM_BLOCK_1 + 0x05c)      // FTM1 Initial State for Channels Output
    #define FTM1_OUTMASK        *(unsigned long *)(FTM_BLOCK_1 + 0x060)      // FTM1 Output Mask
    #define FTM1_COMBINE        *(unsigned long *)(FTM_BLOCK_1 + 0x064)      // FTM1 Function for Linked Channels
    #define FTM1_DEADTIME       *(unsigned long *)(FTM_BLOCK_1 + 0x068)      // FTM1 Deadtime Insertion Control
    #define FTM1_EXTTRIG        *(unsigned long *)(FTM_BLOCK_1 + 0x06c)      // FTM1 External Trigger
    #define FTM1_POL            *(unsigned long *)(FTM_BLOCK_1 + 0x070)      // FTM1 Channels Polarity
    #define FTM1_FMS            *(unsigned long *)(FTM_BLOCK_1 + 0x074)      // FTM1 Fault Mode Status
    #define FTM1_FILTER         *(unsigned long *)(FTM_BLOCK_1 + 0x078)      // FTM1 Input Capture Filter Control
    #define FTM1_FLTCTRL        *(unsigned long *)(FTM_BLOCK_1 + 0x07c)      // FTM1 Fault Control
    #define FTM1_QDCTRL         *(unsigned long *)(FTM_BLOCK_1 + 0x080)      // FTM1 Quadrature Decoder Control and Status
    #define FTM1_CONF           *(unsigned long *)(FTM_BLOCK_1 + 0x084)      // FTM1 Configuration
    #define FTM1_FLTPOL         *(unsigned long *)(FTM_BLOCK_1 + 0x088)      // FTM1 Fault Input Polarity
    #define FTM1_SYNCONF        *(unsigned long *)(FTM_BLOCK_1 + 0x08c)      // FTM1 Synchronisation Configuration
    #define FTM1_INVCTRL        *(unsigned long *)(FTM_BLOCK_1 + 0x090)      // FTM1 Inverting Control
    #define FTM1_SWOCTRL        *(unsigned long *)(FTM_BLOCK_1 + 0x094)      // FTM1 Software Output Control
    #define FTM1_PWMLOAD        *(unsigned long *)(FTM_BLOCK_1 + 0x098)      // FTM1 PWM Load
#endif

#define FTM2_SC             *(volatile unsigned long *)(FTM_BLOCK_2 + 0x000) // FTM2 Status and Control
#define FTM2_CNT            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x004) // FTM2 Counter
#define FTM2_MOD            *(unsigned long *)(FTM_BLOCK_2 + 0x008)      // FTM2 Modulo
#define FTM2_C0SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x00c) // FTM2 Channel 0 and Control
#define FTM2_C0V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x010) // FTM2 Channel 0 Value
#define FTM2_C1SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x014) // FTM2 Channel 1 and Control
#define FTM2_C1V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x018) // FTM2 Channel 1 Value
#define FTM2_C2SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x01c) // FTM2 Channel 2 and Control
#define FTM2_C2V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x020) // FTM2 Channel 2 Value
#define FTM2_C3SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x024) // FTM2 Channel 3 and Control
#define FTM2_C3V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x028) // FTM2 Channel 3 Value
#define FTM2_C4SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x02c) // FTM2 Channel 4 and Control
#define FTM2_C4V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x030) // FTM2 Channel 4 Value
#define FTM2_C5SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x034) // FTM2 Channel 5 and Control
#define FTM2_C5V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x038) // FTM2 Channel 5 Value
#if defined KINETIS_KL || defined KINETIS_KE
    #define FTM2_STATUS         *(volatile unsigned long *)(FTM_BLOCK_2 + 0x050) // FTM2 Capture and Compare Status
    #define FTM2_CONF           *(unsigned long *)(FTM_BLOCK_2 + 0x084)      // FTM2 Configuration
#else
    #define FTM2_C6SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x03c) // FTM2 Channel 6 and Control
    #define FTM2_C6V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x040) // FTM2 Channel 6 Value
    #define FTM2_C7SC           *(volatile unsigned long *)(FTM_BLOCK_2 + 0x044) // FTM2 Channel 7 and Control
    #define FTM2_C7V            *(volatile unsigned long *)(FTM_BLOCK_2 + 0x048) // FTM2 Channel 7 Value
    #define FTM2_CNTIN          *(volatile unsigned long *)(FTM_BLOCK_2 + 0x04c) // FTM2 Counter Initial Value
    #define FTM2_STATUS         *(volatile unsigned long *)(FTM_BLOCK_2 + 0x050) // FTM2 Capture and Compare Status
    #define FTM2_MODE           *(unsigned long *)(FTM_BLOCK_2 + 0x054)      // FTM2 Features Mode Selection
    #define FTM2_SYNC           *(unsigned long *)(FTM_BLOCK_2 + 0x058)      // FTM2 Synchronisation
    #define FTM2_OUTINIT        *(unsigned long *)(FTM_BLOCK_2 + 0x05c)      // FTM2 Initial State for Channels Output
    #define FTM2_OUTMASK        *(unsigned long *)(FTM_BLOCK_2 + 0x060)      // FTM2 Output Mask
    #define FTM2_COMBINE        *(unsigned long *)(FTM_BLOCK_2 + 0x064)      // FTM2 Function for Linked Channels
    #define FTM2_DEADTIME       *(unsigned long *)(FTM_BLOCK_2 + 0x068)      // FTM2 Deadtime Insertion Control
    #define FTM2_EXTTRIG        *(unsigned long *)(FTM_BLOCK_2 + 0x06c)      // FTM2 External Trigger
    #define FTM2_POL            *(unsigned long *)(FTM_BLOCK_2 + 0x070)      // FTM2 Channels Polarity
    #define FTM2_FMS            *(unsigned long *)(FTM_BLOCK_2 + 0x074)      // FTM2 Fault Mode Status
    #define FTM2_FILTER         *(unsigned long *)(FTM_BLOCK_2 + 0x078)      // FTM2 Input Capture Filter Control
    #define FTM2_FLTCTRL        *(unsigned long *)(FTM_BLOCK_2 + 0x07c)      // FTM2 Fault Control
    #define FTM2_QDCTRL         *(unsigned long *)(FTM_BLOCK_2 + 0x080)      // FTM2 Quadrature Decoder Control and Status
    #define FTM2_CONF           *(unsigned long *)(FTM_BLOCK_2 + 0x084)      // FTM2 Configuration
    #define FTM2_FLTPOL         *(unsigned long *)(FTM_BLOCK_2 + 0x088)      // FTM2 Fault Input Polarity
    #define FTM2_SYNCONF        *(unsigned long *)(FTM_BLOCK_2 + 0x08c)      // FTM2 Synchronisation Configuration
    #define FTM2_INVCTRL        *(unsigned long *)(FTM_BLOCK_2 + 0x090)      // FTM2 Inverting Control
    #define FTM2_SWOCTRL        *(unsigned long *)(FTM_BLOCK_2 + 0x094)      // FTM2 Software Output Control
    #define FTM2_PWMLOAD        *(unsigned long *)(FTM_BLOCK_2 + 0x098)      // FTM2 PWM Load
#endif

#define FTM3_SC             *(volatile unsigned long *)(FTM_BLOCK_3 + 0x000) // FTM3 Status and Control
#define FTM3_CNT            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x004) // FTM3 Counter
#define FTM3_MOD            *(unsigned long *)(FTM_BLOCK_3 + 0x008)      // FTM3 Modulo
#define FTM3_C0SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x00c) // FTM3 Channel 0 and Control
#define FTM3_C0V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x010) // FTM3 Channel 0 Value
#define FTM3_C1SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x014) // FTM3 Channel 1 and Control
#define FTM3_C1V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x018) // FTM3 Channel 1 Value
#define FTM3_C2SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x01c) // FTM3 Channel 2 and Control
#define FTM3_C2V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x020) // FTM3 Channel 2 Value
#define FTM3_C3SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x024) // FTM3 Channel 3 and Control
#define FTM3_C3V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x028) // FTM3 Channel 3 Value
#define FTM3_C4SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x02c) // FTM3 Channel 4 and Control
#define FTM3_C4V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x030) // FTM3 Channel 4 Value
#define FTM3_C5SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x034) // FTM3 Channel 5 and Control
#define FTM3_C5V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x038) // FTM3 Channel 5 Value
#if defined KINETIS_KL || defined KINETIS_KE
    #define FTM3_STATUS         *(volatile unsigned long *)(FTM_BLOCK_3 + 0x050) // FTM1 Capture and Compare Status
    #define FTM3_CONF           *(unsigned long *)(FTM_BLOCK_3 + 0x084)      // FTM1 Configuration
#else
    #define FTM3_C6SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x03c) // FTM3 Channel 6 and Control
    #define FTM3_C6V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x040) // FTM3 Channel 6 Value
    #define FTM3_C7SC           *(volatile unsigned long *)(FTM_BLOCK_3 + 0x044) // FTM3 Channel 7 and Control
    #define FTM3_C7V            *(volatile unsigned long *)(FTM_BLOCK_3 + 0x048) // FTM3 Channel 7 Value
    #define FTM3_CNTIN          *(volatile unsigned long *)(FTM_BLOCK_3 + 0x04c) // FTM3 Counter Initial Value
    #define FTM3_STATUS         *(volatile unsigned long *)(FTM_BLOCK_3 + 0x050) // FTM3 Capture and Compare Status
    #define FTM3_MODE           *(unsigned long *)(FTM_BLOCK_3 + 0x054)      // FTM3 Features Mode Selection
    #define FTM3_SYNC           *(unsigned long *)(FTM_BLOCK_3 + 0x058)      // FTM3 Synchronisation
    #define FTM3_OUTINIT        *(unsigned long *)(FTM_BLOCK_3 + 0x05c)      // FTM3 Initial State for Channels Output
    #define FTM3_OUTMASK        *(unsigned long *)(FTM_BLOCK_3 + 0x060)      // FTM3 Output Mask
    #define FTM3_COMBINE        *(unsigned long *)(FTM_BLOCK_3 + 0x064)      // FTM3 Function for Linked Channels
    #define FTM3_DEADTIME       *(unsigned long *)(FTM_BLOCK_3 + 0x068)      // FTM3 Deadtime Insertion Control
    #define FTM3_EXTTRIG        *(unsigned long *)(FTM_BLOCK_3 + 0x06c)      // FTM3 External Trigger
    #define FTM3_POL            *(unsigned long *)(FTM_BLOCK_3 + 0x070)      // FTM3 Channels Polarity
    #define FTM3_FMS            *(unsigned long *)(FTM_BLOCK_3 + 0x074)      // FTM3 Fault Mode Status
    #define FTM3_FILTER         *(unsigned long *)(FTM_BLOCK_3 + 0x078)      // FTM3 Input Capture Filter Control
    #define FTM3_FLTCTRL        *(unsigned long *)(FTM_BLOCK_3 + 0x07c)      // FTM3 Fault Control
    #define FTM3_QDCTRL         *(unsigned long *)(FTM_BLOCK_3 + 0x080)      // FTM3 Quadrature Decoder Control and Status
    #define FTM3_CONF           *(unsigned long *)(FTM_BLOCK_3 + 0x084)      // FTM3 Configuration
    #define FTM3_FLTPOL         *(unsigned long *)(FTM_BLOCK_3 + 0x088)      // FTM3 Fault Input Polarity
    #define FTM3_SYNCONF        *(unsigned long *)(FTM_BLOCK_3 + 0x08c)      // FTM3 Synchronisation Configuration
    #define FTM3_INVCTRL        *(unsigned long *)(FTM_BLOCK_3 + 0x090)      // FTM3 Inverting Control
    #define FTM3_SWOCTRL        *(unsigned long *)(FTM_BLOCK_3 + 0x094)      // FTM3 Software Output Control
    #define FTM3_PWMLOAD        *(unsigned long *)(FTM_BLOCK_3 + 0x098)      // FTM3 PWM Load
#endif

#if defined TPMS_AVAILABLE                                               // TPM in addition to flex timers
    #define FTM4_SC             *(volatile unsigned long *)(FTM_BLOCK_4 + 0x000) // TPM1 Status and Control (referenced as FTM4)
    #define FTM4_CNT            *(volatile unsigned long *)(FTM_BLOCK_4 + 0x004) // TPM1 Counter
    #define FTM4_MOD            *(unsigned long *)(FTM_BLOCK_4 + 0x008)      // TPM1 Modulo
    #define FTM4_C0SC           *(volatile unsigned long *)(FTM_BLOCK_4 + 0x00c) // TPM1 Channel 0 and Control
    #define FTM4_C0V            *(volatile unsigned long *)(FTM_BLOCK_4 + 0x010) // TPM1 Channel 0 Value
    #define FTM4_C1SC           *(volatile unsigned long *)(FTM_BLOCK_4 + 0x014) // TPM1 Channel 1 and Control
    #define FTM4_C1V            *(volatile unsigned long *)(FTM_BLOCK_4 + 0x018) // TPM1 Channel 1 Value

    #define FTM4_STATUS         *(volatile unsigned long *)(FTM_BLOCK_4 + 0x050) // TPM1 Capture and Compare Status

    #define FTM4_COMBINE        *(unsigned long *)(FTM_BLOCK_4 + 0x064)      // TPM1 Function for Linked Channels

    #define FTM4_POL            *(unsigned long *)(FTM_BLOCK_4 + 0x070)      // TPM1 Channels Polarity

    #define FTM4_FILTER         *(unsigned long *)(FTM_BLOCK_4 + 0x078)      // TPM1 Input Capture Filter Control

    #define FTM4_QDCTRL         *(unsigned long *)(FTM_BLOCK_4 + 0x080)      // TPM1 Quadrature Decoder Control and Status
    #define FTM4_CONF           *(unsigned long *)(FTM_BLOCK_4 + 0x084)      // TPM1 Configuration

    #define FTM5_SC             *(volatile unsigned long *)(FTM_BLOCK_5 + 0x000) // TPM2 Status and Control (referenced as FTM5)
    #define FTM5_CNT            *(volatile unsigned long *)(FTM_BLOCK_5 + 0x004) // TPM2 Counter
    #define FTM5_MOD            *(unsigned long *)(FTM_BLOCK_5 + 0x008)      // TPM2 Modulo
    #define FTM5_C0SC           *(volatile unsigned long *)(FTM_BLOCK_5 + 0x00c) // TPM2 Channel 0 and Control
    #define FTM5_C0V            *(volatile unsigned long *)(FTM_BLOCK_5 + 0x010) // TPM2 Channel 0 Value
    #define FTM5_C1SC           *(volatile unsigned long *)(FTM_BLOCK_5 + 0x014) // TPM2 Channel 1 and Control
    #define FTM5_C1V            *(volatile unsigned long *)(FTM_BLOCK_5 + 0x018) // TPM2 Channel 1 Value

    #define FTM5_STATUS         *(volatile unsigned long *)(FTM_BLOCK_5 + 0x050) // TPM2 Capture and Compare Status

    #define FTM5_COMBINE        *(unsigned long *)(FTM_BLOCK_5 + 0x064)      // TPM2 Function for Linked Channels

    #define FTM5_POL            *(unsigned long *)(FTM_BLOCK_5 + 0x070)      // TPM2 Channels Polarity

    #define FTM5_FILTER         *(unsigned long *)(FTM_BLOCK_5 + 0x078)      // TPM2 Input Capture Filter Control

    #define FTM5_QDCTRL         *(unsigned long *)(FTM_BLOCK_5 + 0x080)      // TPM2 Quadrature Decoder Control and Status
    #define FTM5_CONF           *(unsigned long *)(FTM_BLOCK_5 + 0x084)      // TPM2 Configuration
#endif

typedef struct stFLEX_TIMER_CHANNEL
{
    volatile unsigned long FTM_CSC;
    volatile unsigned long FTM_CV;
} FLEX_TIMER_CHANNEL;

typedef struct stFLEX_TIMER_MODULE
{
    volatile unsigned long FTM_SC;
    volatile unsigned long FTM_CNT;
    unsigned long FTM_MOD;
#if defined KINETIS_KL || defined KINETIS_KE
    FLEX_TIMER_CHANNEL FTM_channel[6];
    unsigned long ulRes0[5];
    volatile unsigned long FTM_STATUS;
    unsigned long ulRes1[12];
    unsigned long FTM_CONF;
#else
    FLEX_TIMER_CHANNEL FTM_channel[8];
    volatile unsigned long FTM_CNTIN;
    volatile unsigned long FTM_STATUS;
    unsigned long FTM_MODE;
    unsigned long FTM_SYNC;
    unsigned long FTM_OUTINIT;
    unsigned long FTM_OUTMASK;
    unsigned long FTM_COMBINE;
    unsigned long FTM_DEADTIME;
    unsigned long FTM_EXTTRIG;
    unsigned long FTM_POL;
    unsigned long FTM_FMS;
    unsigned long FTM_FILTER;
    unsigned long FTM_FLTCTRL;
    unsigned long FTM_QDCTRL;
    unsigned long FTM_CONF;
    unsigned long FTM_FLTPOL;
    unsigned long FTM_SYNCONF;
    unsigned long FTM_INVCTRL;
    unsigned long FTM_SWOCTRL;
    unsigned long FTM_PWMLOAD;
#endif
} FLEX_TIMER_MODULE;


// ADC
//
#if defined KINETIS_KE
    #define ADC0_SC1            *(volatile unsigned long *)(ADC0_BLOCK + 0x00) // ADC0 Status and Control Register 1
      #define ADC_SC1A_ADCH_0          0x00000000                            // input channel select - channel 0 select (only single-ended)
      #define ADC_SC1A_ADCH_1          0x00000001                            // input channel select - channel 1 select (only single-ended)
      #define ADC_SC1A_ADCH_2          0x00000002                            // input channel select - channel 2 select (only single-ended)
      #define ADC_SC1A_ADCH_3          0x00000003                            // input channel select - channel 3 select (only single-ended)
      #define ADC_SC1A_ADCH_4          0x00000004                            // input channel select - channel 4 select (only single-ended)
      #define ADC_SC1A_ADCH_5          0x00000005                            // input channel select - channel 5 select (only single-ended)
      #define ADC_SC1A_ADCH_6          0x00000006                            // input channel select - channel 6 select (only single-ended)
      #define ADC_SC1A_ADCH_7          0x00000007                            // input channel select - channel 7 select (only single-ended)
      #define ADC_SC1A_ADCH_8          0x00000008                            // input channel select - channel 8 select (only single-ended)
      #define ADC_SC1A_ADCH_9          0x00000009                            // input channel select - channel 9 select (only single-ended)
      #define ADC_SC1A_ADCH_10         0x0000000a                            // input channel select - channel 10 select (only single-ended)
      #define ADC_SC1A_ADCH_11         0x0000000b                            // input channel select - channel 11 select (only single-ended)
      #define ADC_SC1A_ADCH_12         0x0000000c                            // input channel select - channel 12 select (only single-ended)
      #define ADC_SC1A_ADCH_13         0x0000000d                            // input channel select - channel 13 select (only single-ended)
      #define ADC_SC1A_ADCH_14         0x0000000e                            // input channel select - channel 14 select (only single-ended)
      #define ADC_SC1A_ADCH_15         0x0000000f                            // input channel select - channel 15 select (only single-ended)
      #define ADC_SC1A_ADCH_VSS        0x00000010                            // input channel select - Vss
      #define ADC_SC1A_ADCH_TEMP_SENS  0x00000016                            // input channel select - temperature sensor select
      #define ADC_SC1A_ADCH_BANDGAP    0x00000017                            // input channel select - bandgap reference select
      #define ADC_SC1A_ADCH_VREFSH     0x0000001d                            // input channel select - VREFSH select
      #define ADC_SC1A_ADCH_VREFSL     0x0000001e                            // input channel select - VREFSL select
      #define ADC_SC1A_ADCH_OFF        0x0000001f                            // input channel select - converter sub-system disabled
      #define ADC_SC1A_ADCO     0x00000020                                   // enable continuous conversions
      #define ADC_SC1A_AIEN     0x00000040                                   // conversion complete interrupt enable
      #define ADC_SC1A_COCO     0x00000080                                   // conversion complete flag (read-only)
    #define ADC0_SC2            *(volatile unsigned long *)(ADC0_BLOCK + 0x04) // ADC0 Status and Control Register 2
      #define ADC_SC2_REFSEL_REF 0x00000000                                  // voltage reference selection - reference pair (VREFH and VREFL)
      #define ADC_SC2_REFSEL_AN  0x00000001                                  // voltage reference selection - analog supply pin pair (VDDA and VSSA)
      #define ADC_SC2_FFULL      0x00000004                                  // result FIFO is full (next conversion will overwrite data if not read)
      #define ADC_SC2_FEMPTY     0x00000008                                  // result FIFO has no valid data
      #define ADC_SC2_ACFGT      0x00000010                                  // compare function greater than enable
      #define ADC_SC2_ACFE       0x00000020                                  // compare function enable
      #define ADC_SC2_ADTRG_SW   0x00000000                                  // conversion trigger select - software
      #define ADC_SC2_ADTRG_HW   0x00000040                                  // conversion trigger select - hardware
      #define ADC_SC2_ADACT      0x00000080                                  // ADC converion in progress (read-only)
    #define ADC0_SC3            *(volatile unsigned long *)(ADC0_BLOCK + 0x08) // ADC0 Status and Control Register 3
      #define ADC_CFG1_ADICLK_BUS  0x00000000                                // input clock select - bus clock
      #define ADC_CFG1_ADICLK_BUS2 0x00000001                                // input clock select - bus clock divided by 2
      #define ADC_CFG1_ADICLK_ALT  0x00000002                                // input clock select - alternative clock (ALTCLK)
      #define ADC_CFG1_ADICLK_ASY  0x00000003                                // input clock select - asynchronous clock (ADACK)
      #define ADC_CFG1_MODE_8   0x00000000                                   // conversion mode - single-ended 8 bit
      #define ADC_CFG1_MODE_10  0x00000004                                   // conversion mode - single-ended 10 bit
      #define ADC_CFG1_MODE_12  0x00000008                                   // conversion mode - single-ended 12 bit
      #define ADC_CFG1_MODE_MASK    (ADC_CFG1_MODE_12 | ADC_CFG1_MODE_10)
      #define ADC_CFG1_ADLSMP_SHORT 0x00000000                               // short sample time
      #define ADC_CFG1_ADLSMP_LONG  0x00000010                               // long sample time
      #define ADC_CFG1_ADIV_1   0x00000000                                   // ADC clock not divided
      #define ADC_CFG1_ADIV_2   0x00000020                                   // ADC clock divided by 2
      #define ADC_CFG1_ADIV_4   0x00000040                                   // ADC clock divided by 4
      #define ADC_CFG1_ADIV_8   0x00000060                                   // ADC clock divided by 8
      #define ADC_CFG1_ADLPC    0x00000080                                   // low power configuration
    #define ADC0_SC4            *(volatile unsigned long *)(ADC0_BLOCK + 0x0c) // ADC0 Status and Control Register 4
      #define ADC_SC4_AFDEP_OFF 0x00000000                                   // FIFO disabled
      #define ADC_SC4_AFDEP2    0x00000001                                   // 2-level FIFO enabled
      #define ADC_SC4_AFDEP3    0x00000002                                   // 3-level FIFO enabled
      #define ADC_SC4_AFDEP4    0x00000003                                   // 4-level FIFO enabled
      #define ADC_SC4_AFDEP5    0x00000004                                   // 5-level FIFO enabled
      #define ADC_SC4_AFDEP6    0x00000005                                   // 6-level FIFO enabled
      #define ADC_SC4_AFDEP7    0x00000006                                   // 7-level FIFO enabled
      #define ADC_SC4_AFDEP8    0x00000007                                   // 8-level FIFO enabled
      #define ADC_SC4_ACFSEL_OR  0x00000000                                  // compare function selection - OR all of compare trigger
      #define ADC_SC4_ACFSEL_AND 0x00000020                                  // compare function selection - AND all of compare trigger
      #define ADC_SC4_ASCANE    0x00000040                                   // FIFO scan mode enable
    #define ADC0_R              *(volatile unsigned long *)(ADC0_BLOCK + 0x10) // ADC0 Result Register (read-only)
    #define ADC0_CV1            *(volatile unsigned long *)(ADC0_BLOCK + 0x14) // ADC0 Compare Value Register
    #define ADC0_APCTL1         *(volatile unsigned long *)(ADC0_BLOCK + 0x18) // ADC0 Pin Control 1 Register
      #define ADC_APCTL1_AD0    0x00000001                                    // AD0 pin I/O control enable
      #define ADC_APCTL1_AD1    0x00000002                                    // AD1 pin I/O control enable
      #define ADC_APCTL1_AD2    0x00000004                                    // AD2 pin I/O control enable
      #define ADC_APCTL1_AD3    0x00000008                                    // AD3 pin I/O control enable
      #define ADC_APCTL1_AD4    0x00000010                                    // AD4 pin I/O control enable
      #define ADC_APCTL1_AD5    0x00000020                                    // AD5 pin I/O control enable
      #define ADC_APCTL1_AD6    0x00000040                                    // AD6 pin I/O control enable
      #define ADC_APCTL1_AD7    0x00000080                                    // AD7 pin I/O control enable
      #define ADC_APCTL1_AD8    0x00000100                                    // AD8 pin I/O control enable
      #define ADC_APCTL1_AD9    0x00000200                                    // AD9 pin I/O control enable
      #define ADC_APCTL1_AD10   0x00000400                                    // AD10 pin I/O control enable
      #define ADC_APCTL1_AD11   0x00000800                                    // AD11 pin I/O control enable
      #define ADC_APCTL1_AD12   0x00001000                                    // AD12 pin I/O control enable
      #define ADC_APCTL1_AD13   0x00002000                                    // AD13 pin I/O control enable
      #define ADC_APCTL1_AD14   0x00004000                                    // AD14 pin I/O control enable
      #define ADC_APCTL1_AD15   0x00008000                                    // AD15 pin I/O control enable

    #define ADC_SE0_SINGLE      0
    #define ADC_SE1_SINGLE      1
    #define ADC_SE2_SINGLE      2
    #define ADC_SE3_SINGLE      3
    #define ADC_SE4_SINGLE      4
    #define ADC_SE5_SINGLE      5
    #define ADC_SE6_SINGLE      6
    #define ADC_SE7_SINGLE      7
    #define ADC_SE8_SINGLE      8
    #define ADC_SE9_SINGLE      9
    #define ADC_SE10_SINGLE     10
    #define ADC_SE11_SINGLE     11
    #define ADC_SE12_SINGLE     12
    #define ADC_SE13_SINGLE     13
    #define ADC_SE14_SINGLE     14
    #define ADC_SE15_SINGLE     15
    #define ADC_VSS_SINGLE      16

    #define ADC_TEMP_SENSOR     22
    #define ADC_BANDGAP         23

    #define ADC_VREFH           29
    #define ADC_VREFL           30
    #define ADC_DISABLED        31

    typedef struct stKINETIS_ADC_REGS
    {
    volatile unsigned long ADC_SC1;
    volatile unsigned long ADC_SC2;
    volatile unsigned long ADC_SC3;
    volatile unsigned long ADC_SC4;
    volatile unsigned long ADC_R;
    volatile unsigned long ADC_CV1;
    volatile unsigned long ADC_APCTL1;
    } KINETIS_ADC_REGS;

    #define ADC0_RA            ADC0_R                                        // for compatibility
    #define ADC_RA             ADC_R
    #define ADC0_SC1A          ADC0_SC1
    #define ADC_SC1A           ADC_SC1
    #define ADC_CFG1           ADC_SC3
    #define ADC_SC2_REFSEL_ALT ADC_SC2_REFSEL_AN
#else
    #define ADC0_SC1A           *(volatile unsigned long *)(ADC0_BLOCK + 0x000) // ADC0 Status and Control Register 1
      #define ADC_SC1A_ADCH_D0         0x00000000                            // input channel select - channel 0 select (DADP0 or DAD0 when differential)
      #define ADC_SC1A_ADCH_D1         0x00000001                            // input channel select - channel 1 select (DADP1 or DAD1 when differential)
      #define ADC_SC1A_ADCH_D2         0x00000002                            // input channel select - channel 2 select (DADP2 or DAD2 when differential)
      #define ADC_SC1A_ADCH_D3         0x00000003                            // input channel select - channel 3 select (DADP3 or DAD3 when differential)
      #define ADC_SC1A_ADCH_4          0x00000004                            // input channel select - channel 4 select (only single-ended)
      #define ADC_SC1A_ADCH_5          0x00000005                            // input channel select - channel 5 select (only single-ended)
      #define ADC_SC1A_ADCH_6          0x00000006                            // input channel select - channel 6 select (only single-ended)
      #define ADC_SC1A_ADCH_7          0x00000007                            // input channel select - channel 7 select (only single-ended)
      #define ADC_SC1A_ADCH_8          0x00000008                            // input channel select - channel 8 select (only single-ended)
      #define ADC_SC1A_ADCH_9          0x00000009                            // input channel select - channel 9 select (only single-ended)
      #define ADC_SC1A_ADCH_10         0x0000000a                            // input channel select - channel 10 select (only single-ended)
      #define ADC_SC1A_ADCH_11         0x0000000b                            // input channel select - channel 11 select (only single-ended)
      #define ADC_SC1A_ADCH_12         0x0000000c                            // input channel select - channel 12 select (only single-ended)
      #define ADC_SC1A_ADCH_13         0x0000000d                            // input channel select - channel 13 select (only single-ended)
      #define ADC_SC1A_ADCH_14         0x0000000e                            // input channel select - channel 14 select (only single-ended)
      #define ADC_SC1A_ADCH_15         0x0000000f                            // input channel select - channel 15 select (only single-ended)
      #define ADC_SC1A_ADCH_16         0x00000010                            // input channel select - channel 16 select (only single-ended)
      #define ADC_SC1A_ADCH_17         0x00000011                            // input channel select - channel 17 select (only single-ended)
      #define ADC_SC1A_ADCH_18         0x00000012                            // input channel select - channel 18 select (only single-ended)
      #define ADC_SC1A_ADCH_19         0x00000013                            // input channel select - channel 19 select (only single-ended)
      #define ADC_SC1A_ADCH_20         0x00000014                            // input channel select - channel 20 select (only single-ended)
      #define ADC_SC1A_ADCH_21         0x00000015                            // input channel select - channel 21 select (only single-ended)
      #define ADC_SC1A_ADCH_22         0x00000016                            // input channel select - channel 22 select (only single-ended)
      #define ADC_SC1A_ADCH_23         0x00000017                            // input channel select - channel 23 select (only single-ended)
      #define ADC_SC1A_ADCH_TEMP_SENS  0x0000001a                            // input channel select - temperature sensor select (differential possible)
      #define ADC_SC1A_ADCH_BANDGAP    0x0000001b                            // input channel select - bandgap reference select (differential possible)
      #define ADC_SC1A_ADCH_VREFSH     0x0000001d                            // input channel select - VREFSH select (differential possible)
      #define ADC_SC1A_ADCH_VREFSL     0x0000001e                            // input channel select - VREFSL select (only single-ended)
      #define ADC_SC1A_ADCH_OFF        0x0000001f                            // input channel select - converter sub-system disabled
      #define ADC_SC1A_DIFF     0x00000020                                   // differential mode enable
      #define ADC_SC1A_AIEN     0x00000040                                   // conversion complete interrupt enable
      #define ADC_SC1A_COCO     0x00000080                                   // conversion complete flag (read-only)
    #define ADC0_SC1B           *(unsigned long *)(ADC0_BLOCK + 0x004)       // ADC0 Status and Control Registers 1
    #define ADC0_CFG1           *(unsigned long *)(ADC0_BLOCK + 0x008)       // ADC0 Configuration Register 1
      #define ADC_CFG1_ADICLK_BUS  0x00000000                                // input clock select - bus clock
      #define ADC_CFG1_ADICLK_BUS2 0x00000001                                // input clock select - bus clock divided by 2
      #define ADC_CFG1_ADICLK_ALT  0x00000002                                // input clock select - alternative clock (ALTCLK)
      #define ADC_CFG1_ADICLK_ASY  0x00000003                                // input clock select - asynchronous clock (ADACK)
      #define ADC_CFG1_MODE_8   0x00000000                                   // conversion mode - single-ended 8 bit or differential 9 bit
      #define ADC_CFG1_MODE_12  0x00000004                                   // conversion mode - single-ended 12 bit or differential 13 bit
      #define ADC_CFG1_MODE_10  0x00000008                                   // conversion mode - single-ended 10 bit or differential 11 bit
      #define ADC_CFG1_MODE_16  0x0000000c                                   // conversion mode - single-ended 16 bit or differential 16 bit
      #define ADC_CFG1_MODE_MASK    ADC_CFG1_MODE_16
      #define ADC_CFG1_ADLSMP_SHORT 0x00000000                               // short sample time
      #define ADC_CFG1_ADLSMP_LONG  0x00000010                               // long sample time
      #define ADC_CFG1_ADIV_1   0x00000000                                   // ADC clock not divided
      #define ADC_CFG1_ADIV_2   0x00000020                                   // ADC clock divided by 2
      #define ADC_CFG1_ADIV_4   0x00000040                                   // ADC clock divided by 4
      #define ADC_CFG1_ADIV_8   0x00000060                                   // ADC clock divided by 8
      #define ADC_CFG1_ADLPC    0x00000080                                   // low power configuration
    #define ADC0_CFG2           *(unsigned long *)(ADC0_BLOCK + 0x00c)       // ADC0 Configuration Register 2
      #define ADC_CFG2_ADLSTS_2  0x00000003                                  // long sample time select - 2 extra (6 clocks total)
      #define ADC_CFG2_ADLSTS_6  0x00000002                                  // long sample time select - 6 extra (10 clocks total)
      #define ADC_CFG2_ADLSTS_12 0x00000001                                  // long sample time select - 12 extra (16 clocks total)
      #define ADC_CFG2_ADLSTS_20 0x00000000                                  // long sample time select - 20 extra (24 clocks total)
      #define ADC_CFG2_ADHSC     0x00000004                                  // high speed configuration
      #define ADC_CFG2_ADACKEN   0x00000008                                  // asynchronous clock and clock output enabled regardless of ADC state
      #define ADC_CFG2_MUXSEL_A  0x00000000                                  // ADC mux select - ADxxa selected
      #define ADC_CFG2_MUXSEL_B  0x00000010                                  // ADC mux select - ADxxb selected
    #define ADC0_RA             *(volatile unsigned long *)(ADC0_BLOCK + 0x010) // ADC0a Data Result Register (read-only)
    #define ADC0_RB             *(volatile unsigned long *)(ADC0_BLOCK + 0x014) // ADC0b Data Result Register (read-only)
    #define ADC0_CV1            *(unsigned long *)(ADC0_BLOCK + 0x018)       // ADC0 Compare Value Registers
    #define ADC0_CV2            *(unsigned long *)(ADC0_BLOCK + 0x01c)       // ADC0 Compare Value Registers
    #define ADC0_SC2            *(volatile unsigned long *)(ADC0_BLOCK + 0x020) // ADC0 Status and Control Register 2
      #define ADC_SC2_REFSEL_REF 0x00000000                                  // voltage reference selection - reference pair (VREFH and VREFL)
      #define ADC_SC2_REFSEL_ALT 0x00000001                                  // voltage reference selection - alternative reference pair (VALTH and VALTL)
      #define ADC_SC2_DMAEN      0x00000004                                  // DMA enabled
      #define ADC_SC2_ACREN      0x00000008                                  // compare function range enable
      #define ADC_SC2_ACFGT      0x00000010                                  // compare function greater than enable
      #define ADC_SC2_ACFE       0x00000020                                  // compare function enable
      #define ADC_SC2_ADTRG_SW   0x00000000                                  // conversion trigger select - software
      #define ADC_SC2_ADTRG_HW   0x00000040                                  // conversion trigger select - hardware
      #define ADC_SC2_ADACT      0x00000080                                  // ADC converion in progress (read-only)
    #define ADC0_SC3            *(volatile unsigned long *)(ADC0_BLOCK + 0x024) // ADC0 Status and Control Register 3
      #define ADC_SC3_AVGS_4    0x00000000                                   // hardware average select - 4 samples averaged
      #define ADC_SC3_AVGS_8    0x00000001                                   // hardware average select - 8 samples averaged
      #define ADC_SC3_AVGS_16   0x00000002                                   // hardware average select - 16 samples averaged
      #define ADC_SC3_AVGS_32   0x00000003                                   // hardware average select - 32 samples averaged
      #define ADC_SC3_AVGE      0x00000004                                   // hardware average enable
      #define ADC_SC3_ADCO      0x00000008                                   // continuous conversion enable
      #define ADC_SC3_CALF      0x00000040                                   // calibration failed flag (read-only)
      #define ADC_SC3_CAL       0x00000080                                   // calibration
    #define ADC0_OFS            *(unsigned long *)(ADC0_BLOCK + 0x028)       // ADC0 Offset Correction Register
    #define ADC0_PG             *(unsigned long *)(ADC0_BLOCK + 0x02c)       // ADC0 Plus Side Gain Register
    #define ADC0_MG             *(unsigned long *)(ADC0_BLOCK + 0x030)       // ADC0 Minus Side Gain Register
    #define ADC0_CLPD           *(unsigned long *)(ADC0_BLOCK + 0x034)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_CLPS           *(unsigned long *)(ADC0_BLOCK + 0x038)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_CLP4           *(unsigned long *)(ADC0_BLOCK + 0x03c)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_CLP3           *(unsigned long *)(ADC0_BLOCK + 0x040)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_CLP2           *(unsigned long *)(ADC0_BLOCK + 0x044)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_CLP1           *(unsigned long *)(ADC0_BLOCK + 0x048)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_CLP0           *(unsigned long *)(ADC0_BLOCK + 0x04c)       // ADC0 Plus Side General Calibration Value Register
    #define ADC0_PGA            *(unsigned long *)(ADC0_BLOCK + 0x050)       // ADC0 PGA Register
      #define ADC_PGA_PGAG_1    0x00000000                                   // PGA gain - 1x
      #define ADC_PGA_PGAG_2    0x00010000                                   // PGA gain - 2x
      #define ADC_PGA_PGAG_4    0x00020000                                   // PGA gain - 4x
      #define ADC_PGA_PGAG_8    0x00030000                                   // PGA gain - 8x
      #define ADC_PGA_PGAG_16   0x00040000                                   // PGA gain - 16x
      #define ADC_PGA_PGAG_32   0x00050000                                   // PGA gain - 32x
      #define ADC_PGA_PGAG_64   0x00060000                                   // PGA gain - 64x
      #define ADC_PGA_PGALPb    0x00100000                                   // PGA runs in normal power mode
      #define ADC_PGA_PGAEN     0x00800000                                   // PGA enable
    #define ADC0_CLMD           *(unsigned long *)(ADC0_BLOCK + 0x054)       // ADC0 Minus Side General Calibration Value Register
    #define ADC0_CLMS           *(unsigned long *)(ADC0_BLOCK + 0x058)       // ADC0 Minus Side General Calibration Value Register
    #define ADC0_CLM4           *(unsigned long *)(ADC0_BLOCK + 0x05c)       // ADC0 Minus Side General Calibration Value Register
    #define ADC0_CLM3           *(unsigned long *)(ADC0_BLOCK + 0x060)       // ADC0 Minus Side General Calibration Value Register
    #define ADC0_CLM2           *(unsigned long *)(ADC0_BLOCK + 0x064)       // ADC0 Minus Side General Calibration Value Register
    #define ADC0_CLM1           *(unsigned long *)(ADC0_BLOCK + 0x068)       // ADC0 Minus Side General Calibration Value Register
    #define ADC0_CLM0           *(unsigned long *)(ADC0_BLOCK + 0x06c)       // ADC0 Minus Side General Calibration Value Register

    #if ADC_CONTROLLERS > 1
        #define ADC1_SC1A       *(volatile unsigned long *)(ADC1_BLOCK + 0x000) // ADC1 Status and Control Registers 1
        #define ADC1_SC1B       *(unsigned long *)(ADC1_BLOCK + 0x004)       // ADC1 Status and Control Registers 1
        #define ADC1_CFG1       *(unsigned long *)(ADC1_BLOCK + 0x008)       // ADC1 Configuration Register 1
        #define ADC1_CFG2       *(unsigned long *)(ADC1_BLOCK + 0x00c)       // ADC1 Configuration Register 2
        #define ADC1_RA         *(volatile unsigned long *)(ADC1_BLOCK + 0x010) // ADC1 Data Result Register (read-only)
        #define ADC1_RB         *(volatile unsigned long *)(ADC1_BLOCK + 0x014) // ADC1 Data Result Register (read-only)
        #define ADC1_CV1        *(unsigned long *)(ADC1_BLOCK + 0x018)       // ADC1 Compare Value Registers
        #define ADC1_CV2        *(unsigned long *)(ADC1_BLOCK + 0x01c)       // ADC1 Compare Value Registers
        #define ADC1_SC2        *(volatile unsigned long *)(ADC1_BLOCK + 0x020) // ADC1 Status and Control Register 2
        #define ADC1_SC3        *(volatile unsigned long *)(ADC1_BLOCK + 0x024) // ADC1 Status and Control Register 3
        #define ADC1_OFS        *(unsigned long *)(ADC1_BLOCK + 0x028)       // ADC1 Offset Correction Register
        #define ADC1_PG         *(unsigned long *)(ADC1_BLOCK + 0x02c)       // ADC1 Plus Side Gain Register
        #define ADC1_MG         *(unsigned long *)(ADC1_BLOCK + 0x030)       // ADC1 Minus Side Gain Register
        #define ADC1_CLPD       *(unsigned long *)(ADC1_BLOCK + 0x034)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_CLPS       *(unsigned long *)(ADC1_BLOCK + 0x038)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_CLP4       *(unsigned long *)(ADC1_BLOCK + 0x03c)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_CLP3       *(unsigned long *)(ADC1_BLOCK + 0x040)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_CLP2       *(unsigned long *)(ADC1_BLOCK + 0x044)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_CLP1       *(unsigned long *)(ADC1_BLOCK + 0x048)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_CLP0       *(unsigned long *)(ADC1_BLOCK + 0x04c)       // ADC1 Plus Side General Calibration Value Register
        #define ADC1_PGA        *(unsigned long *)(ADC1_BLOCK + 0x050)       // ADC1 PGA Register
        #define ADC1_CLMD       *(unsigned long *)(ADC1_BLOCK + 0x054)       // ADC1 Minus Side General Calibration Value Register
        #define ADC1_CLMS       *(unsigned long *)(ADC1_BLOCK + 0x058)       // ADC1 Minus Side General Calibration Value Register
        #define ADC1_CLM4       *(unsigned long *)(ADC1_BLOCK + 0x05c)       // ADC1 Minus Side General Calibration Value Register
        #define ADC1_CLM3       *(unsigned long *)(ADC1_BLOCK + 0x060)       // ADC1 Minus Side General Calibration Value Register
        #define ADC1_CLM2       *(unsigned long *)(ADC1_BLOCK + 0x064)       // ADC1 Minus Side General Calibration Value Register
        #define ADC1_CLM1       *(unsigned long *)(ADC1_BLOCK + 0x068)       // ADC1 Minus Side General Calibration Value Register
        #define ADC1_CLM0       *(unsigned long *)(ADC1_BLOCK + 0x06c)       // ADC1 Minus Side General Calibration Value Register
    #endif
    #if ADC_CONTROLLERS > 2
        #define ADC2_SC1A       *(volatile unsigned long *)(ADC2_BLOCK + 0x000) // ADC2 Status and Control Registers 1
        #define ADC2_SC1B       *(unsigned long *)(ADC2_BLOCK + 0x004)       // ADC2 Status and Control Registers 1
        #define ADC2_CFG1       *(unsigned long *)(ADC2_BLOCK + 0x008)       // ADC2 Configuration Register 1
        #define ADC2_CFG2       *(unsigned long *)(ADC2_BLOCK + 0x00c)       // ADC2 Configuration Register 2
        #define ADC2_RA         *(volatile unsigned long *)(ADC2_BLOCK + 0x010) // ADC2 Data Result Register (read-only)
        #define ADC2_RB         *(volatile unsigned long *)(ADC2_BLOCK + 0x014) // ADC2 Data Result Register (read-only)
        #define ADC2_CV1        *(unsigned long *)(ADC2_BLOCK + 0x018)       // ADC2 Compare Value Registers
        #define ADC2_CV2        *(unsigned long *)(ADC2_BLOCK + 0x01c)       // ADC2 Compare Value Registers
        #define ADC2_SC2        *(volatile unsigned long *)(ADC2_BLOCK + 0x020) // ADC2 Status and Control Register 2
        #define ADC2_SC3        *(volatile unsigned long *)(ADC2_BLOCK + 0x024) // ADC2 Status and Control Register 3
        #define ADC2_OFS        *(unsigned long *)(ADC2_BLOCK + 0x028)       // ADC2 Offset Correction Register
        #define ADC2_PG         *(unsigned long *)(ADC2_BLOCK + 0x02c)       // ADC2 Plus Side Gain Register
        #define ADC2_MG         *(unsigned long *)(ADC2_BLOCK + 0x030)       // ADC2 Minus Side Gain Register
        #define ADC2_CLPD       *(unsigned long *)(ADC2_BLOCK + 0x034)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_CLPS       *(unsigned long *)(ADC2_BLOCK + 0x038)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_CLP4       *(unsigned long *)(ADC2_BLOCK + 0x03c)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_CLP3       *(unsigned long *)(ADC2_BLOCK + 0x040)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_CLP2       *(unsigned long *)(ADC2_BLOCK + 0x044)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_CLP1       *(unsigned long *)(ADC2_BLOCK + 0x048)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_CLP0       *(unsigned long *)(ADC2_BLOCK + 0x04c)       // ADC2 Plus Side General Calibration Value Register
        #define ADC2_PGA        *(unsigned long *)(ADC2_BLOCK + 0x050)       // ADC2 PGA Register
        #define ADC2_CLMD       *(unsigned long *)(ADC2_BLOCK + 0x054)       // ADC2 Minus Side General Calibration Value Register
        #define ADC2_CLMS       *(unsigned long *)(ADC2_BLOCK + 0x058)       // ADC2 Minus Side General Calibration Value Register
        #define ADC2_CLM4       *(unsigned long *)(ADC2_BLOCK + 0x05c)       // ADC2 Minus Side General Calibration Value Register
        #define ADC2_CLM3       *(unsigned long *)(ADC2_BLOCK + 0x060)       // ADC2 Minus Side General Calibration Value Register
        #define ADC2_CLM2       *(unsigned long *)(ADC2_BLOCK + 0x064)       // ADC2 Minus Side General Calibration Value Register
        #define ADC2_CLM1       *(unsigned long *)(ADC2_BLOCK + 0x068)       // ADC2 Minus Side General Calibration Value Register
        #define ADC2_CLM0       *(unsigned long *)(ADC2_BLOCK + 0x06c)       // ADC2 Minus Side General Calibration Value Register
    #endif
    #if ADC_CONTROLLERS > 3
        #define ADC3_SC1A       *(volatile unsigned long *)(ADC3_BLOCK + 0x000) // ADC3 Status and Control Registers 1
        #define ADC3_SC1B       *(unsigned long *)(ADC3_BLOCK + 0x004)       // ADC3 Status and Control Registers 1
        #define ADC3_CFG1       *(unsigned long *)(ADC3_BLOCK + 0x008)       // ADC3 Configuration Register 1
        #define ADC3_CFG2       *(unsigned long *)(ADC3_BLOCK + 0x00c)       // ADC3 Configuration Register 2
        #define ADC3_RA         *(volatile unsigned long *)(ADC3_BLOCK + 0x010) // ADC3 Data Result Register (read-only)
        #define ADC3_RB         *(volatile unsigned long *)(ADC3_BLOCK + 0x014) // ADC3 Data Result Register (read-only)
        #define ADC3_CV1        *(unsigned long *)(ADC3_BLOCK + 0x018)       // ADC3 Compare Value Registers
        #define ADC3_CV2        *(unsigned long *)(ADC3_BLOCK + 0x01c)       // ADC3 Compare Value Registers
        #define ADC3_SC2        *(volatile unsigned long *)(ADC3_BLOCK + 0x020) // ADC3 Status and Control Register 2
        #define ADC3_SC3        *(volatile unsigned long *)(ADC3_BLOCK + 0x024) // ADC3 Status and Control Register 3
        #define ADC3_OFS        *(unsigned long *)(ADC3_BLOCK + 0x028)       // ADC3 Offset Correction Register
        #define ADC3_PG         *(unsigned long *)(ADC3_BLOCK + 0x02c)       // ADC3 Plus Side Gain Register
        #define ADC3_MG         *(unsigned long *)(ADC3_BLOCK + 0x030)       // ADC3 Minus Side Gain Register
        #define ADC3_CLPD       *(unsigned long *)(ADC3_BLOCK + 0x034)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_CLPS       *(unsigned long *)(ADC3_BLOCK + 0x038)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_CLP4       *(unsigned long *)(ADC3_BLOCK + 0x03c)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_CLP3       *(unsigned long *)(ADC3_BLOCK + 0x040)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_CLP2       *(unsigned long *)(ADC3_BLOCK + 0x044)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_CLP1       *(unsigned long *)(ADC3_BLOCK + 0x048)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_CLP0       *(unsigned long *)(ADC3_BLOCK + 0x04c)       // ADC3 Plus Side General Calibration Value Register
        #define ADC3_PGA        *(unsigned long *)(ADC3_BLOCK + 0x050)       // ADC3 PGA Register
        #define ADC3_CLMD       *(unsigned long *)(ADC3_BLOCK + 0x054)       // ADC3 Minus Side General Calibration Value Register
        #define ADC3_CLMS       *(unsigned long *)(ADC3_BLOCK + 0x058)       // ADC3 Minus Side General Calibration Value Register
        #define ADC3_CLM4       *(unsigned long *)(ADC3_BLOCK + 0x05c)       // ADC3 Minus Side General Calibration Value Register
        #define ADC3_CLM3       *(unsigned long *)(ADC3_BLOCK + 0x060)       // ADC3 Minus Side General Calibration Value Register
        #define ADC3_CLM2       *(unsigned long *)(ADC3_BLOCK + 0x064)       // ADC3 Minus Side General Calibration Value Register
        #define ADC3_CLM1       *(unsigned long *)(ADC3_BLOCK + 0x068)       // ADC3 Minus Side General Calibration Value Register
        #define ADC3_CLM0       *(unsigned long *)(ADC3_BLOCK + 0x06c)       // ADC3 Minus Side General Calibration Value Register
    #endif

    #define ADC_DP0_SINGLE      0
    #define ADC_D0_DIFF         0
    #define ADC_DP1_SINGLE      1
    #define ADC_D1_DIFF         1
    #define PGA_DP_SINGLE       2
    #define PGA_D_DIFF          2
    #define ADC_DP3_SINGLE      3
    #define ADC_D3_DIFF         3
    #define ADC_SE4_SINGLE      4
    #define ADC_SE5_SINGLE      5
    #define ADC_SE6_SINGLE      6
    #define ADC_SE7_SINGLE      7
    #define ADC_SE8_SINGLE      8
    #define ADC_SE9_SINGLE      9
    #define ADC_SE10_SINGLE     10
    #define ADC_SE11_SINGLE     11
    #define ADC_SE12_SINGLE     12
    #define ADC_SE13_SINGLE     13
    #define ADC_SE14_SINGLE     14
    #define ADC_SE15_SINGLE     15
    #define ADC_SE16_SINGLE     16
    #define ADC_SE17_SINGLE     17
    #define ADC_SE18_SINGLE     18
    #define ADC_VREF_OUT_1      18                                           // ADC 1
    #define ADC_SE19_SINGLE     19
    #define ADC_DM0_SINGLE      19
    #define ADC_SE20_SINGLE     20
    #define ADC_DM1_SINGLE      20
    #define ADC_SE21_SINGLE     21
    #define ADC_DM3_SINGLE      21
    #define ADC_SE22_SINGLE     22
    #define ADC_VREF_OUT_0      22                                           // ADC 0
    #define ADC_SE23_SINGLE     23
    #define DAC_OUT             23

    #define ADC_TEMP_SENSOR     26
    #define ADC_BANDGAP         27

    #define ADC_VREFH           29
    #define ADC_VREFL           30
    #define ADC_DISABLED        31

    typedef struct stKINETIS_ADC_REGS
    {
    volatile unsigned long ADC_SC1A;
    unsigned long ADC_SC1B;
    unsigned long ADC_CFG1;
    unsigned long ADC_CFG2;
    volatile unsigned long ADC_RA;
    volatile unsigned long ADC_RB;
    unsigned long ADC_CV1;
    unsigned long ADC_CV2;
    volatile unsigned long ADC_SC2;
    volatile unsigned long ADC_SC3;
    unsigned long ADC_OFS;
    unsigned long ADC_PG;
    unsigned long ADC_MG;
    unsigned long ADC_CLPD;
    unsigned long ADC_CLPS;
    unsigned long ADC_CLP4;
    unsigned long ADC_CLP3;
    unsigned long ADC_CLP2;
    unsigned long ADC_CLP1;
    unsigned long ADC_CLP0;
    unsigned long ADC_PGA;
    unsigned long ADC_CLMD;
    unsigned long ADC_CLMS;
    unsigned long ADC_CLM4;
    unsigned long ADC_CLM3;
    unsigned long ADC_CLM2;
    unsigned long ADC_CLM1;
    unsigned long ADC_CLM0;
    } KINETIS_ADC_REGS;
#endif

// NAND Flash Controller (NFC)                                           {4}
//
#define NFC_CMD1            *(volatile unsigned long *)(NFC_BLOCK + 0x00)// Flash command 1
  #define NFC_CMD1_BYTES3   0x00ff0000                                   // third command byte that may be sent to the flash device
  #define NFC_CMD1_BYTES2   0xff000000                                   // second command byte that may be sent to the flash device
#define NFC_CMD2            *(volatile unsigned long *)(NFC_BLOCK + 0x04)// Flash command 2
  #define NFC_CMD2_BUSY_START 0x00000001                                 // busy indicator and start command
  #define NFC_CMD2_BUFNO    0x00000006                                   // internal buffer number used for command
  #define NFC_CMD2_CODE_START_DMA_WRITE_SRAM          0x00800200
  #define NFC_CMD2_CODE_SEND_COMMAND_BYTE1_TO_FLASH   0x00400200
  #define NFC_CMD2_CODE_SEND_COL_ADD1_TO_FLASH        0x00200200
  #define NFC_CMD2_CODE_SEND_COL_ADD2_TO_FLASH        0x00100200
  #define NFC_CMD2_CODE_SEND_ROW_ADD1_TO_FLASH        0x00080200
  #define NFC_CMD2_CODE_SEND_ROW_ADD2_TO_FLASH        0x00040200
  #define NFC_CMD2_CODE_SEND_ROW_ADD3_TO_FLASH        0x00020200
  #define NFC_CMD2_CODE_WRITE_DATA_TO_FLASH           0x00010200
  #define NFC_CMD2_CODE_SEND_COMMAND_BYTE2_TO_FLASH   0x00008200
  #define NFC_CMD2_CODE_WAIT_FOR_FLASH_R_B_HANDSHAKE  0x00004200
  #define NFC_CMD2_CODE_READ_DATA_FROM_FLASH          0x00002200
  #define NFC_CMD2_CODE_SEND_COMMAND_BYTE3_TO_FLASH   0x00001200
  #define NFC_CMD2_CODE_READ_FLASH_STATUS             0x00000a00
  #define NFC_CMD2_CODE_READ_ID                       0x00000600
  #define NFC_CMD2_BYTES1   0xff000000                                   // first command byte that may be sent to the flash device
#define NFC_CAR             *(unsigned long *)(NFC_BLOCK + 0x08)         // Column address
#define NFC_RAR             *(unsigned long *)(NFC_BLOCK + 0x0c)         // Row address
  #define NFC_RAR_RB0       0x01000000                                   // ready/busy 0 enabled
  #define NFC_RAR_RB1       0x02000000                                   // ready/busy 1 enabled
  #define NFC_RAR_CS0       0x10000000                                   // chip select 0 enabled
  #define NFC_RAR_CS1       0x20000000                                   // chip select 1 enabled
#define NFC_RPT             *(unsigned long *)(NFC_BLOCK + 0x10)         // Flash command repeat
#define NFC_RAI             *(unsigned long *)(NFC_BLOCK + 0x14)         // Row address increment
#define NFC_SR1             *(volatile unsigned long *)(NFC_BLOCK + 0x18)// Flash status 1 (read-only)
#define NFC_SR2             *(volatile unsigned long *)(NFC_BLOCK + 0x1c)// Flash status 2 (read-only)
#define NFC_DMA1            *(unsigned long *)(NFC_BLOCK + 0x20)         // DMA channel 1 address
#define NFC_DMACFG          *(unsigned long *)(NFC_BLOCK + 0x24)         // DMA channel 1 configuration
#define NFC_SWAP            *(unsigned long *)(NFC_BLOCK + 0x28)         // Cache swap
#define NFC_SECSZ           *(unsigned long *)(NFC_BLOCK + 0x2c)         // Sector size
#define NFC_CFG             *(unsigned long *)(NFC_BLOCK + 0x30)         // Flash configuration
  #define NFC_CFG_PAGECNT   0x0000000f                                   // number of virtual pages to be read or written
  #define NFC_CFG_AIBN      0x00000010                                   // auto-increment the buffer number
  #define NFC_CFG_AIAD      0x00000020                                   // auto-increment the flash row address
  #define NFC_CFG_BITWIDTH_8  0x00000000                                 // 8-bit wide flash mode
  #define NFC_CFG_BITWIDTH_16 0x00000080                                 // 16-bit wide flash mode
  #define NFC_CFG_TIMEOUT   0x00001f00                                   // timeout value in flash clock sycles
  #define NFC_CFG_IDCNT     0x0000e000                                   // number of bytes that are read for the read ID command
  #define NFC_CFG_IDCNT_5   0x0000a000                                   // {27}
  #define NFC_CFG_FAST      0x00010000                                   // fast flash timing
  #define NFC_CFG_ECCMODE_NONE 0x00000000                                // ECC bypass
  #define NFC_CFG_ECCMODE_8  0x00020000                                  // ECC using 8 bytes for 4-error correction
  #define NFC_CFG_ECCMODE_12 0x00040000                                  // ECC using 12 bytes for 6-error correction
  #define NFC_CFG_ECCMODE_15 0x00060000                                  // ECC using 15 bytes for 8-error correction
  #define NFC_CFG_ECCMODE_23 0x00080000                                  // ECC using 23 bytes for 12-error correction
  #define NFC_CFG_ECCMODE_30 0x000a0000                                  // ECC using 30 bytes for 16-error correction
  #define NFC_CFG_ECCMODE_45 0x000c0000                                  // ECC using 45 bytes for 24-error correction
  #define NFC_CFG_ECCMODE_60 0x000e0000                                  // ECC using 60 bytes for 32-error correction
  #define NFC_CFG_DMAREQ     0x00100000                                  // after ECC done, transfer sector using DMA
  #define NFC_CFG_ECCSRAM    0x00200000                                  // write ECC status to SRAM
  #define NFC_CFG_ECCAD      0x7fc00000                                  // byte address in SRAM where ECC status is written
  #define NFC_CFG_STOPWERR   0x80000000                                  // auto-sequencer stops on a write error
#define NFC_DMA2            *(unsigned long *)(NFC_BLOCK + 0x34)         // DMA channel 2 address
#define NFC_ISR             *(volatile unsigned long *)(NFC_BLOCK + 0x38)// Interrupt status
  #define NFC_ISR_DMABN     0x00000003                                   // DMA buffer number
  #define NFC_ISR_ECCBN     0x0000000c                                   // ECC buffer number
  #define NFC_ISR_RESBN     0x00000030                                   // residue buffer number
  #define NFC_ISR_IDLECLR   0x00020000                                   // IDLE clear (write '1' to clear)
  #define NFC_ISR_DONECLR   0x00040000                                   // DONE clear (write '1' to clear)
  #define NFC_ISR_WERRCLR   0x00080000                                   // WERR clear (write '1' to clear)
  #define NFC_ISR_IDLEEN    0x00100000                                   // IDLE enable
  #define NFC_ISR_DONEEN    0x00200000                                   // DONE enable
  #define NFC_ISR_WERREN    0x00400000                                   // WERR enable
  #define NFC_ISR_DMABUSY   0x00800000                                   // DMA engine busy (read-only)
  #define NFC_ISR_ECCBUSY   0x01000000                                   // EEC engine busy (read-only)
  #define NFC_ISR_RESBUSY   0x02000000                                   // residue engine busy (read-only)
  #define NFC_ISR_CMDBUSY   0x04000000                                   // command busy (read-only)
  #define NFC_ISR_WERRNS    0x08000000                                   // write error status (read-only) - non-sticky
  #define NFC_ISR_IDLE      0x20000000                                   // command done and all engines are idle (read-only)
  #define NFC_ISR_DONE      0x40000000                                   // command processing done (read-only)
  #define NFC_ISR_WERR      0x80000000                                   // write error status (read-only) - non-sticky


// DDR1/2/LP SDRAM controller                                            {28}
//
#define DDR_CR00            *(volatile unsigned long *)(DDR_BLOCK + 0x000) // DDR control register 0
  #define DDR_CR00_START        0x00000001
  #define DDR_CR00_DDRCLS_DDR   0x00000000
  #define DDR_CR00_DDRCLS_LPDDR 0x00000100
  #define DDR_CR00_DDRCLS_DDR2  0x00000400
#define DDR_CR01            *(volatile unsigned long *)(DDR_BLOCK + 0x004) // DDR control register 1 (read-only)
#define DDR_CR02            *(unsigned long *)(DDR_BLOCK + 0x008)        // DDR control register 2
  #define DDR_CR02_TINIT_MASK     0x00ffffff
  #define DDR_CR02_TINIT_SHIFT    0
  #define DDR_CR02_INITAREF_MASK  0x0f000000
  #define DDR_CR02_INITAREF_SHIFT 24
#define DDR_CR03            *(unsigned long *)(DDR_BLOCK + 0x00c)        // DDR control register 3
  #define DDR_CR03_LATLIN_MASK    0x0000000f
  #define DDR_CR03_LATLIN_SHIFT   0
  #define DDR_CR03_LATGATE_MASK   0x00000f00
  #define DDR_CR03_LATGATE_SHIFT  8
  #define DDR_CR03_WRLAT_MASK     0x000f0000
  #define DDR_CR03_WRLAT_SHIFT    16
  #define DDR_CR03_TCCD_MASK      0x1f000000
  #define DDR_CR03_TCCD_SHIFT     24
#define DDR_CR04            *(unsigned long *)(DDR_BLOCK + 0x010)        // DDR control register 4
  #define DDR_CR04_TBINT_MASK     0x00000007
  #define DDR_CR04_TBINT_SHIFT    0
  #define DDR_CR04_TRRD_MASK      0x00000700
  #define DDR_CR04_TRRD_SHIFT     8
  #define DDR_CR04_TRC_MASK       0x003f0000
  #define DDR_CR04_TRC_SHIFT      16
  #define DDR_CR04_TRASMIN_MASK   0xff000000
  #define DDR_CR04_TRASMIN_SHIFT  24
#define DDR_CR05            *(unsigned long *)(DDR_BLOCK + 0x014)        // DDR control register 5
  #define DDR_CR05_TWTR_MASK      0x0000000f
  #define DDR_CR05_TWTR_SHIFT     0
  #define DDR_CR05_TRP_MASK       0x00000f00
  #define DDR_CR05_TRP_SHIFT      8
  #define DDR_CR05_TRTP_MASK      0x00070000
  #define DDR_CR05_TRTP_SHIFT     16
  #define DDR_CR05_TMRD_MASK      0x1f000000
  #define DDR_CR05_TMRD_SHIFT     24
#define DDR_CR06            *(unsigned long *)(DDR_BLOCK + 0x018)        // DDR control register 6
  #define DDR_CR06_TMOD_MASK      0x000000ff
  #define DDR_CR06_TMOD_SHIFT     0
  #define DDR_CR06_TRASMAX_MASK   0x00ffff00
  #define DDR_CR06_TRASMAX_SHIFT  8
  #define DDR_CR06_INTWBR         0x01000000
#define DDR_CR07            *(unsigned long *)(DDR_BLOCK + 0x01c)        // DDR control register 7
  #define DDR_CR07_CLKPW_MASK     0x00000007
  #define DDR_CR07_CLKPW_SHIFT    0
  #define DDR_CR07_TCKESR_MASK    0x00001f00
  #define DDR_CR07_TCKESR_SHIFT   8
  #define DDR_CR07_AP             0x00010000
  #define DDR_CR07_CCAPEN         0x01000000
#define DDR_CR08            *(unsigned long *)(DDR_BLOCK + 0x020)        // DDR control register 8
  #define DDR_CR08_TRAS           0x00000001
  #define DDR_CR08_TRASDI_MASK    0x0000ff00
  #define DDR_CR08_TRASDI_SHIFT   8
  #define DDR_CR08_TWR_MASK       0x000f0000
  #define DDR_CR08_TWR_SHIFT      16
  #define DDR_CR08_TDAL_MASK      0x1f000000
  #define DDR_CR08_TDAL_SHIFT     24
#define DDR_CR09            *(unsigned long *)(DDR_BLOCK + 0x024)        // DDR control register 9
  #define DDR_CR09_TDLL_MASK      0x0000ffff
  #define DDR_CR09_TDLL_SHIFT     0
  #define DDR_CR09_NOCMD          0x00010000
  #define DDR_CR09_BSTLEN_MASK    0x07000000
  #define DDR_CR09_BSTLEN_SHIFT   24
#define DDR_CR10            *(unsigned long *)(DDR_BLOCK + 0x028)        // DDR control register 10
  #define DDR_CR10_TFAW_MASK      0x0000003f
  #define DDR_CR10_TFAW_SHIFT     0
  #define DDR_CR10_TCPD_MASK      0x00ffff00
  #define DDR_CR10_TCPD_SHIFT     8
  #define DDR_CR10_TRPAB_MASK     0x0f000000
  #define DDR_CR10_TRPAB_SHIFT    24
#define DDR_CR11            *(volatile unsigned long *)(DDR_BLOCK + 0x02c) // DDR control register 11
  #define DDR_CR11_REGDIMM        0x00000001
  #define DDR_CR11_AREF           0x00000100
  #define DDR_CR11_AREFMODE       0x00010000
  #define DDR_CR11_TREFEN         0x01000000
#define DDR_CR12            *(unsigned long *)(DDR_BLOCK + 0x030)        // DDR control register 12
  #define DDR_CR12_TRFC_MASK      0x000001ff
  #define DDR_CR12_TRFC_SHIFT     0
  #define DDR_CR12_TREF_MASK      0x3fff0000
  #define DDR_CR12_TREF_SHIFT     16
#define DDR_CR13            *(unsigned long *)(DDR_BLOCK + 0x034)        // DDR control register 13
  #define DDR_CR13_TREFINT_MASK   0x00003fff
  #define DDR_CR13_TREFINT_SHIFT  0
  #define DDR_CR13_PD             0x00010000
#define DDR_CR14            *(unsigned long *)(DDR_BLOCK + 0x038)        // DDR control register 14
  #define DDR_CR14_TPDEX_MASK     0x0000ffff
  #define DDR_CR14_TPDEX_SHIFT    0
  #define DDR_CR14_TXSR_MASK      0xffff0000
  #define DDR_CR14_TXSR_SHIFT     16
#define DDR_CR15            *(unsigned long *)(DDR_BLOCK + 0x03c)        // DDR control register 15
  #define DDR_CR15_TXSNR_MASK     0x0000ffff
  #define DDR_CR15_TXSNR_SHIFT    0
  #define DDR_CR15_SREF           0x00010000
  #define DDR_CR15_PUREF          0x01000000
#define DDR_CR16            *(unsigned long *)(DDR_BLOCK + 0x040)        // DDR control register 16
  #define DDR_CR16_QKREF          0x00000001
  #define DDR_CR16_CLKDLY_MASK    0x00000700
  #define DDR_CR16_CLKDLY_SHIFT   8
  #define DDR_CR16_LPCTRL_MASK    0x001f0000
  #define DDR_CR16_LPCTRL_SHIFT   16
#define DDR_CR17            *(unsigned long *)(DDR_BLOCK + 0x044)        // DDR control register 17
#define DDR_CR18            *(unsigned long *)(DDR_BLOCK + 0x048)        // DDR control register 18
#define DDR_CR19            *(unsigned long *)(DDR_BLOCK + 0x04c)        // DDR control register 19
#define DDR_CR20            *(unsigned long *)(DDR_BLOCK + 0x050)        // DDR control register 20
  #define DDR_CR20_LPRE_REFRESH    0x00000000
  #define DDR_CR20_LPRE_NO_REFRESH 0x00000001
  #define DDR_CR20_CKSRE_MASK      0x00000f00
  #define DDR_CR20_CKSRE_SHIFT     8
  #define DDR_CR20_CKSRX_MASK      0x000f0000
  #define DDR_CR20_CKSRX_SHIFT     16
  #define DDR_CR20_WRMD            0x01000000
#define DDR_CR21            *(unsigned long *)(DDR_BLOCK + 0x054)        // DDR control register 21
  #define DDR_CR21_MR0DATA0_MASK      0x0000ffff
  #define DDR_CR21_MR0DATA0_SHIFT     0
  #define DDR_CR21_MR1DATA0_MASK      0xffff0000
  #define DDR_CR21_MR1DATA0_SHIFT     16
#define DDR_CR22            *(unsigned long *)(DDR_BLOCK + 0x058)        // DDR control register 22
  #define DDR_CR22_MR2DATA0_MASK      0x0000ffff
  #define DDR_CR22_MR2DATA0_SHIFT     0
  #define DDR_CR22_MR3DATA0_MASK      0xffff0000
  #define DDR_CR22_MR3DATA0_SHIFT     16
#define DDR_CR23            *(volatile unsigned long *)(DDR_BLOCK + 0x05c) // DDR control register 23 (reads zero)
#define DDR_CR24            *(volatile unsigned long *)(DDR_BLOCK + 0x060) // DDR control register 24 (reads zero)
#define DDR_CR25            *(unsigned long *)(DDR_BLOCK + 0x064)        // DDR control register 25
  #define DDR_CR25_BNK8           0x00000001
  #define DDR_CR25_ADDPINS_MASK   0x00000700
  #define DDR_CR25_ADDPINS_SHIFT  8
  #define DDR_CR25_COLSIZ_MASK    0x00070000
  #define DDR_CR25_COLSIZ_SHIFT   16
  #define DDR_CR25_APREBIT_MASK   0x0f000000
  #define DDR_CR25_APREBIT_SHIFT  24
#define DDR_CR26            *(unsigned long *)(DDR_BLOCK + 0x068)        // DDR control register 26
  #define DDR_CR26_AGECNT_MASK    0x000000ff
  #define DDR_CR26_AGECNT_SHIFT   0
  #define DDR_CR26_CMDAGE_MASK    0x0000ff00
  #define DDR_CR26_CMDAGE_SHIFT   8
  #define DDR_CR26_ADDCOL         0x00010000
  #define DDR_CR26_BNKSPT         0x01000000
#define DDR_CR27            *(unsigned long *)(DDR_BLOCK + 0x06c)        // DDR control register 27
  #define DDR_CR27_PLEN           0x00000001
  #define DDR_CR27_PRIEN          0x00000100
  #define DDR_CR27_RWEN           0x00010000
  #define DDR_CR27_SWPEN          0x01000000
#define DDR_CR28            *(unsigned long *)(DDR_BLOCK + 0x070)        // DDR control register 28
  #define DDR_CR28_CSMAP          0x00000001
  #define DDR_CR28_REDUC          0x00000100
  #define DDR_CR28_BIGEND         0x00010000
  #define DDR_CR28_CMDLATR        0x01000000
#define DDR_CR29            *(unsigned long *)(DDR_BLOCK + 0x074)        // DDR control register 29
#define DDR_CR30            *(volatile unsigned long *)(DDR_BLOCK + 0x078) // DDR control register 30
  #define DDR_CR30_RSYNCRF           0x00000001
  #define DDR_CR30_INT_SINGLE_ACCESS 0x00000100                          // read-only interrupt flags
  #define DDR_CR30_INT_MULT_ACCESS   0x00000200
  #define DDR_CR30_INT_DRAM_INIT     0x00000400
  #define DDR_CR30_INT_BOTH_INIT     0x00000800
  #define DDR_CR30_INT_CAS3          0x00001000
  #define DDR_CR30_INT_REG_WR_COMP   0x00002000
  #define DDR_CR30_INT_DFI_COMPLETE  0x00004000
  #define DDR_CR30_INT_DLL_RESYNC    0x00008000
  #define DDR_CR30_INT_OR            0x00010000                          // OR or all other interrupt flags
  #define DDR_CR30_CLR_SINGLE_ACCESS 0x01000000                          // write-one to clear corresponding interrupt flags
  #define DDR_CR30_CLR_MULT_ACCESS   0x02000000
  #define DDR_CR30_CLR_DRAM_INIT     0x04000000
  #define DDR_CR30_CLR_BOTH_INIT     0x08000000
  #define DDR_CR30_CLR_CAS3          0x10000000
  #define DDR_CR30_CLR_REG_WR_COMP   0x20000000
  #define DDR_CR30_CLR_DFI_COMPLETE  0x40000000
  #define DDR_CR30_CLR_DLL_RESYNC    0x80000000
#define DDR_CR31            *(unsigned long *)(DDR_BLOCK + 0x07c)        // DDR control register 31
#define DDR_CR32            *(volatile unsigned long *)(DDR_BLOCK + 0x080) // DDR control register 32 (read-only)
#define DDR_CR33            *(volatile unsigned long *)(DDR_BLOCK + 0x084) // DDR control register 33 (read-only)
#define DDR_CR34            *(unsigned long *)(DDR_BLOCK + 0x088)        // DDR control register 34
#define DDR_CR35            *(volatile unsigned long *)(DDR_BLOCK + 0x08c) // DDR control register 35 (read-only)
#define DDR_CR36            *(volatile unsigned long *)(DDR_BLOCK + 0x090) // DDR control register 36 (reads zero)
#define DDR_CR37            *(unsigned long *)(DDR_BLOCK + 0x094)        // DDR control register 37
  #define DDR_CR37_R2RSAME_MASK   0x00000007
  #define DDR_CR37_R2RSAME_SHIFT  0
  #define DDR_CR37_R2WSAME_MASK   0x00000700
  #define DDR_CR37_R2WSAME_SHIFT  8
  #define DDR_CR37_W2RSAME_MASK   0x00070000
  #define DDR_CR37_W2RSAME_SHIFT  16
  #define DDR_CR37_W2WSAME_MASK   0x07000000
  #define DDR_CR37_W2WSAME_SHIFT  24
#define DDR_CR38            *(unsigned long *)(DDR_BLOCK + 0x098)        // DDR control register 38
  #define DDR_CR38_PDNCS_MASK   0x0000001f
  #define DDR_CR38_PDNCS_SHIFT  0
  #define DDR_CR38_PUPCS_MASK   0x00001f00
  #define DDR_CR38_PUPCS_SHIFT  8
  #define DDR_CR38_PWRCNT_MASK  0x07ff0000
  #define DDR_CR38_PWRCNT_SHIFT 16
#define DDR_CR39            *(unsigned long *)(DDR_BLOCK + 0x09c)        // DDR control register 39
  #define DDR_CR39_P0RDCNT_MASK  0x000007ff
  #define DDR_CR39_P0RDCNT_SHIFT 0
  #define DDR_CR39_RP0_MASK      0x00030000
  #define DDR_CR39_RP0_SHIFT     16
  #define DDR_CR39_WP0_MASK      0x03000000
  #define DDR_CR39_WP0_SHIFT     24
#define DDR_CR40            *(unsigned long *)(DDR_BLOCK + 0x0a0)        // DDR control register 40
  #define DDR_CR40_P0TYP_ASYNC   0x00000000
  #define DDR_CR40_P0TYP_SYNC    0x00000003
  #define DDR_CR40_P1WRCNT_MASK  0x0007ff00
  #define DDR_CR40_P1WRCNT_SHIFT 8
#define DDR_CR41            *(unsigned long *)(DDR_BLOCK + 0x0a4)        // DDR control register 41
  #define DDR_CR41_P1RDCNT_MASK  0x000007ff
  #define DDR_CR41_P1RDCNT_SHIFT 0
  #define DDR_CR41_RP1_MASK      0x00030000
  #define DDR_CR41_RP1_SHIFT     16
  #define DDR_CR41_WP1_MASK      0x03000000
  #define DDR_CR41_WP1_SHIFT     24
#define DDR_CR42            *(unsigned long *)(DDR_BLOCK + 0x0a8)        // DDR control register 42
  #define DDR_CR42_P1TYP_ASYNC   0x00000000
  #define DDR_CR42_P1TYP_SYNC    0x00000003
  #define DDR_CR42_P2WRCNT_MASK  0x0007ff00
  #define DDR_CR42_P2WRCNT_SHIFT 8
#define DDR_CR43            *(unsigned long *)(DDR_BLOCK + 0x0ac)        // DDR control register 43
  #define DDR_CR43_P2RDCNT_MASK  0x000007ff
  #define DDR_CR43_P2RDCNT_SHIFT 0
  #define DDR_CR43_RP2_MASK      0x00030000
  #define DDR_CR43_RP2_SHIFT     16
  #define DDR_CR43_WP2_MASK      0x03000000
  #define DDR_CR43_WP2_SHIFT     24
#define DDR_CR44            *(unsigned long *)(DDR_BLOCK + 0x0b0)        // DDR control register 44
  #define DDR_CR44_P2TYP_ASYNC   0x00000000
  #define DDR_CR44_P2TYP_SYNC    0x00000003
#define DDR_CR45            *(unsigned long *)(DDR_BLOCK + 0x0b4)        // DDR control register 45
  #define DDR_CR45_P0PRI0_MASK   0x0000000f
  #define DDR_CR45_P0PRI0_SHIFT  0
  #define DDR_CR45_P0PRI1_MASK   0x00000f00
  #define DDR_CR45_P0PRI1_SHIFT  8
  #define DDR_CR45_P0PRI2_MASK   0x000f0000
  #define DDR_CR45_P0PRI2_SHIFT  16
  #define DDR_CR45_P0PRI3_MASK   0x0f000000
  #define DDR_CR45_P0PRI3_SHIFT  24
#define DDR_CR46            *(unsigned long *)(DDR_BLOCK + 0x0b8)        // DDR control register 46
  #define DDR_CR46_P0ORD_MASK     0x00000003
  #define DDR_CR46_P0ORD_SHIFT    0
  #define DDR_CR46_P0PRIRLX_MASK  0x0003ff00
  #define DDR_CR46_P0PRIRLX_SHIFT 8
  #define DDR_CR46_P1PRI0_MASK    0x0f000000
  #define DDR_CR46_P1PRI0_SHIFT   24
#define DDR_CR47            *(unsigned long *)(DDR_BLOCK + 0x0bc)        // DDR control register 47
  #define DDR_CR47_P1PRI1_MASK   0x0000000f
  #define DDR_CR47_P1PRI1_SHIFT  0
  #define DDR_CR47_P1PRI2_MASK   0x00000f00
  #define DDR_CR47_P1PRI2_SHIFT  8
  #define DDR_CR47_P1PRI3_MASK   0x000f0000
  #define DDR_CR47_P1PRI3_SHIFT  16
  #define DDR_CR47_P1ORD_MASK    0x03000000
  #define DDR_CR47_P1ORD_SHIFT   24
#define DDR_CR48            *(unsigned long *)(DDR_BLOCK + 0x0c0)        // DDR control register 48
  #define DDR_CR48_P1PRIRLX_MASK  0x000003ff
  #define DDR_CR48_P1PRIRLX_SHIFT 0
  #define DDR_CR48_P2PRI0_MASK    0x000f0000
  #define DDR_CR48_P2PRI0_SHIFT   16
  #define DDR_CR48_P2PRI1_MASK    0x0f000000
  #define DDR_CR48_P2PRI1_SHIFT   24
#define DDR_CR49            *(unsigned long *)(DDR_BLOCK + 0x0c4)        // DDR control register 49
  #define DDR_CR49_P2PRI2_MASK    0x0000000f
  #define DDR_CR49_P2PRI2_SHIFT   0
  #define DDR_CR49_P2PRI3_MASK    0x00000f00
  #define DDR_CR49_P2PRI3_SHIFT   8
  #define DDR_CR49_P2ORD_MASK     0x00030000
  #define DDR_CR49_P2ORD_SHIFT    16
#define DDR_CR50            *(volatile unsigned long *)(DDR_BLOCK + 0x0c8) // DDR control register 50
  #define DDR_CR50_P2PRIRLX_MASK  0x000003ff
  #define DDR_CR50_P2PRIRLX_SHIFT 0
  #define DDR_CR50_CLKSTATUS      0x00010000                             // read-only
#define DDR_CR51            *(unsigned long *)(DDR_BLOCK + 0x0cc)        // DDR control register 51
#define DDR_CR52            *(volatile unsigned long *)(DDR_BLOCK + 0x0d0) // DDR control register 52
  #define DDR_CR52_PYWRLTBS_MASK   0x0000000f
  #define DDR_CR52_PYWRLTBS_SHIFT  0
  #define DDR_CR52_PHYRDLAT_MASK   0x00000f00
  #define DDR_CR52_PHYRDLAT_SHIFT  8
  #define DDR_CR52_RDDATEN_MASK    0x000f0000                            // read-only
  #define DDR_CR52_RDDATEN_SHIFT   16
  #define DDR_CR52_RDDTENBAS_MASK  0x0f000000
  #define DDR_CR52_RDDTENBAS_SHIFT 24
#define DDR_CR53            *(volatile unsigned long *)(DDR_BLOCK + 0x0d4) // DDR control register 53
  #define DDR_CR53_CLKDISCS        0x00000001
  #define DDR_CR53_CRTLUPMN_MASK   0x00000f00                            // read-only
  #define DDR_CR53_CRTLUPMN_SHIFT  8
  #define DDR_CR53_CRTLUDMX_MASK   0x3fff0000
  #define DDR_CR53_CRTLUDMX_SHIFT  16
#define DDR_CR54            *(unsigned long *)(DDR_BLOCK + 0x0d8)        // DDR control register 54
  #define DDR_CR54_PHYUPDTY0_MASK  0x00003fff
  #define DDR_CR54_PHYUPDTY0_SHIFT 0
  #define DDR_CR54_PHYUPDTY1_MASK  0x3fff0000
  #define DDR_CR54_PHYUPDTY1_SHIFT 16
#define DDR_CR55            *(unsigned long *)(DDR_BLOCK + 0x0dc)        // DDR control register 55
  #define DDR_CR55_PHYUPDTY2_MASK  0x00003fff
  #define DDR_CR55_PHYUPDTY2_SHIFT 0
  #define DDR_CR55_PHYUPDTY3_MASK  0x3fff0000
  #define DDR_CR55_PHYUPDTY3_SHIFT 16
#define DDR_CR56            *(unsigned long *)(DDR_BLOCK + 0x0e0)        // DDR control register 56
  #define DDR_CR56_PHYUPDRESP_MASK  0x00003fff
  #define DDR_CR56_PHYUPDRESP_SHIFT 0
  #define DDR_CR56_RDLATADJ_MASK    0x000f0000
  #define DDR_CR56_RDLATADJ_SHIFT   16
  #define DDR_CR56_WRLATADJ_MASK    0x0f000000
  #define DDR_CR56_WRLATADJ_SHIFT   24
#define DDR_CR57            *(unsigned long *)(DDR_BLOCK + 0x0e4)        // DDR control register 57
  #define DDR_CR57_CMDDLY_MASK     0x0000000f
  #define DDR_CR57_CMDDLY_SHIFT    0
  #define DDR_CR57_CLKDISDLY_MASK  0x00000700
  #define DDR_CR57_CLKDISDLY_SHIFT 8
  #define DDR_CR57_CLKENDLY_MASK   0x000f0000
  #define DDR_CR57_CLKENDLY_SHIFT  16
  #define DDR_CR57_ODTALTEN        0x01000000
#define DDR_CR58            *(volatile unsigned long *)(DDR_BLOCK + 0x0e8) // DDR control register 58 (reads zero)
#define DDR_CR59            *(volatile unsigned long *)(DDR_BLOCK + 0x0ec) // DDR control register 59 (reads zero)
#define DDR_CR60            *(volatile unsigned long *)(DDR_BLOCK + 0x0f0) // DDR control register 60 (reads zero)
#define DDR_CR61            *(volatile unsigned long *)(DDR_BLOCK + 0x0f4) // DDR control register 61 (reads zero)
#define DDR_CR62            *(volatile unsigned long *)(DDR_BLOCK + 0x0f8) // DDR control register 62 (reads zero)
#define DDR_CR63            *(volatile unsigned long *)(DDR_BLOCK + 0x0fc) // DDR control register 63 (reads zero)

#define DDR_RCR             *(volatile unsigned long *)(DDR_BLOCK + 0x180) // DDR RCR [read clock recovery] control register (reads as zero)
  #define DDR_RCR_RST       0x40000000
#define DDR_PAD_CTRL        *(unsigned long *)(DDR_BLOCK + 0x1ac)        // DDR I/O pad control register
  #define DDR_PAD_CTRL_SPARE_DLY_CTRL_NO_BUF_ONLY_MUX_DELAY 0x00000000
  #define DDR_PAD_CTRL_SPARE_DLY_CTRL_4_BUFFERS             0x00000001
  #define DDR_PAD_CTRL_SPARE_DLY_CTRL_7_BUFFERS             0x00000002
  #define DDR_PAD_CTRL_SPARE_DLY_CTRL_10_BUFFERS            0x00000003
  #define DDR_PAD_CTRL_FIXED                                0x00000200   // this bit must always be written (not documented)
  #define DDR_PAD_CTRL_PAD_ODT_CS0_ODT_DISABLED             0x00000000
  #define DDR_PAD_CTRL_PAD_ODT_CS0_75_OHMS                  0x01000000
  #define DDR_PAD_CTRL_PAD_ODT_CS0_150_OHMS                 0x02000000
  #define DDR_PAD_CTRL_PAD_ODT_CS0_50_OHMS                  0x03000000


// LCD controller                                                        // {60}
//
#define LCDC_LSSAR         *(unsigned long *)(LCDC_BLOCK + 0x00)         // LCDC screen start address register
#define LCDC_LSR           *(unsigned long *)(LCDC_BLOCK + 0x04)         // LCDC size register
#define LCDC_LVPWR         *(unsigned long *)(LCDC_BLOCK + 0x08)         // LCDC virtual page width register
#define LCDC_LCPR          *(unsigned long *)(LCDC_BLOCK + 0x0c)         // LCDC cursor position register
#define LCDC_LCWHB         *(unsigned long *)(LCDC_BLOCK + 0x10)         // LCDC cursor width, height and blink register
#define LCDC_LCCMR         *(unsigned long *)(LCDC_BLOCK + 0x14)         // LCDC color cursor mapping register
#define LCDC_LPCR          *(unsigned long *)(LCDC_BLOCK + 0x18)         // LCDC panel configuration register
  #define LCDC_LPCR_PCD       0x0000003f                                 // pixel clock divider mask
  #define LCDC_LPCR_SCLKSEL   0x00000080                                 // LSCLK select
  #define LCDC_LPCR_ACD       0x00007f00                                 // alternate crystal direction
  #define LCDC_LPCR_ADCSEL    0x00008000                                 // ACD clock select (use LP/HSYNC as clock source rather than FLM)
  #define LCDC_LPCR_REV_VS    0x00010000                                 // reversal vertical scan
  #define LCDC_LPCR_SWAP_SEL  0x00020000                                 // swap select
  #define LCDC_LPCR_END_SEL_L 0x00000000                                 // image download in memory is little endian
  #define LCDC_LPCR_END_SEL_B 0x00040000                                 // image download in memory is big endian
  #define LCDC_LPCR_SCLKIDLE  0x00080000                                 // enable LSCLK when VSYNC is idle in TFT mode
  #define LCDC_LPCR_OEPOL_H   0x00000000                                 // output enable polarity active high
  #define LCDC_LPCR_OEPOL_L   0x00100000                                 // output enable polarity active low
  #define LCDC_LPCR_CLKPOL    0x00200000                                 // LCD shift clock polarity (active on positive edge of LSCLK (TFT mode active on negative edge of LSCLK)
  #define LCDC_LPCR_LPPOL_H   0x00000000                                 // line pulse polarity high (LP/HSYNC)
  #define LCDC_LPCR_LPPOL_L   0x00400000                                 // line pulse polarity low
  #define LCDC_LPCR_FLMPOL_H  0x00000000                                 // first line marker polarity high (FLM/VSYNC)
  #define LCDC_LPCR_FLMPOL_L  0x00800000                                 // first line marker polarity low
  #define LCDC_LPCR_PIXPOL_H  0x00000000                                 // active high pixel polarity
  #define LCDC_LPCR_PIXPOL_L  0x01000000                                 // active low pixel polarity
  #define LCDC_LPCR_BPIX_1    0x00000000                                 // bits per pixel
  #define LCDC_LPCR_BPIX_2    0x02000000                                 // (one byte per pixel required)
  #define LCDC_LPCR_BPIX_4    0x04000000                                 // (one byte per pixel required) 
  #define LCDC_LPCR_BPIX_8    0x06000000                                 // (one byte per pixel required)
  #define LCDC_LPCR_BPIX_12   0x08000000                                 // (half-word per pixel required)
  #define LCDC_LPCR_BPIX_16   0x0a000000                                 // (half-word per pixel required)
  #define LCDC_LPCR_BPIX_18   0x0d000000                                 // (long-word per pixel required)
  #define LCDC_LPCR_BPIX_24   0x0e000000                                 // (long-word per pixel required)
  #define LCDC_LPCR_PBSIZ_1   0x00000000                                 // panel bus width (only applicable for monochrome monitors)
  #define LCDC_LPCR_PBSIZ_2   0x10000000
  #define LCDC_LPCR_PBSIZ_4   0x20000000
  #define LCDC_LPCR_PBSIZ_8   0x30000000
  #define LCDC_LPCR_COLOR     0x40000000                                 // color display
  #define LCDC_LPCR_TFT       0x80000000                                 // active display
  #define LCDC_LPCR_MONOCHROME 0x00000000 
  #define LCDC_LPCR_CSTN      (LCDC_LPCR_COLOR) 
  #define LCDC_LPCR_TFT_MODE  (LCDC_LPCR_TFT | LCDC_LPCR_COLOR) 
#define LCDC_LHCR          *(unsigned long *)(LCDC_BLOCK + 0x1c)         // LCDC horizontal configuration register
#define LCDC_LVCR          *(unsigned long *)(LCDC_BLOCK + 0x20)         // LCDC vertical configuration register
#define LCDC_LPOR          *(unsigned long *)(LCDC_BLOCK + 0x24)         // LCDC panning offset register
#define LCDC_LPCCR         *(unsigned long *)(LCDC_BLOCK + 0x2c)         // LCDC PWM contrast control register
  #define LCDC_LPCCR_PW    0x000000ff                                    // pulse-width mask
  #define LCDC_LPCCR_CC_EN 0x00000100                                    // contrast control enable
  #define LCDC_LPCCR_SCR_LINE_CLK  0x00000000                            // source select line clock/256 (system clock/8000)
  #define LCDC_LPCCR_SCR_PIXEL_CLK 0x00000200                            // source select pixel clock/256 (system clock/15)
  #define LCDC_LPCCR_SCR_LCD_CLK   0x00000400                            // source select LCD clock/256 (system clock)
  #define LCDC_LPCCR_LDMSK 0x00008000                                    // LD mask
#define LCDC_LDCR          *(unsigned long *)(LCDC_BLOCK + 0x30)         // LCDC DMA control register
  #define LCDC_LDCR_BURST  0x80000000
#define LCDC_LRMCR         *(unsigned long *)(LCDC_BLOCK + 0x34)         // LCDC refresh mode control register
#define LCDC_LICR          *(unsigned long *)(LCDC_BLOCK + 0x38)         // LCDC interrupt configuration register
#define LCDC_LIER          *(unsigned long *)(LCDC_BLOCK + 0x3c)         // LCDC interrupt enable register
#define LCDC_LISR          *(unsigned long *)(LCDC_BLOCK + 0x40)         // LCDC interrupt status register
#define LCDC_LGWSAR        *(unsigned long *)(LCDC_BLOCK + 0x50)         // LCDC graphic window start address register
#define LCDC_LGWSR         *(unsigned long *)(LCDC_BLOCK + 0x54)         // LCDC graphic window size register
#define LCDC_LGWVPWR       *(unsigned long *)(LCDC_BLOCK + 0x58)         // LCDC graphic window virtual page width register
#define LCDC_LGWPOR        *(unsigned long *)(LCDC_BLOCK + 0x5c)         // LCDC graphic window panning offset register
#define LCDC_LGWPR         *(unsigned long *)(LCDC_BLOCK + 0x60)         // LCDC graphic window position register
#define LCDC_LGWCR         *(unsigned long *)(LCDC_BLOCK + 0x64)         // LCDC graphic window control register
    #define LCDC_LGWDCR_GWBT 0x80000000
#define LCDC_LGWDCR        *(unsigned long *)(LCDC_BLOCK + 0x68)         // LCDC graphic window DMA control register
#define LCDC_LAUSCR        *(unsigned long *)(LCDC_BLOCK + 0x80)         // LCDC AUS mode control register
#define LCDC_LAUSCCR       *(unsigned long *)(LCDC_BLOCK + 0x84)         // LCDC AUS mode cursor control register



// SDHC
//
#define SDHC_DSADDR         *(unsigned long *)(SDHC_BLOCK + 0x000)       // SDHC DMA System Address Register
#define SDHC_BLKATTR        *(unsigned long *)(SDHC_BLOCK + 0x004)       // SDHC Block Attributes Register
  #define SDHC_BLKATTR_BLKCNT_SHIFT 16
  #define SDHC_BLKATTR_BLKSIZE_MASK 0x00001fff
#define SDHC_CMDARG         *(unsigned long *)(SDHC_BLOCK + 0x008)       // SDHC Command Argument Register
#define SDHC_XFERTYP        *(unsigned long *)(SDHC_BLOCK + 0x00c)       // SDHC Transfer Type Register
  #define SDHC_XFERTYP_DMAEN        0x00000001                           // DMA Enable
  #define SDHC_XFERTYP_BCEN         0x00000002                           // Block Count Enable
  #define SDHC_XFERTYP_AC12EN       0x00000004                           // Auto CMD12 Enable
  #define SDHC_XFERTYP_DTDSEL_WRITE 0x00000000                           // Data Transfer Direction Select - write
  #define SDHC_XFERTYP_DTDSEL_READ  0x00000010                           // Data Transfer Direction Select - read
  #define SDHC_XFERTYP_MSBSEL       0x00000020                           // Multi/Single Block Select
  #define SDHC_XFERTYP_RSPTYP_NONE  0x00000000                           // Response Type Select - no response
  #define SDHC_XFERTYP_RSPTYP_126   0x00010000                           // Response Type Select - response length 136
  #define SDHC_XFERTYP_RSPTYP_48    0x00020000                           // Response Type Select - response length 48
  #define SDHC_XFERTYP_RSPTYP_48BSY 0x00030000                           // Response Type Select - response length 48 - check busy after response
  #define SDHC_XFERTYP_CCCEN        0x00080000                           // Command CRC Check Enable
  #define SDHC_XFERTYP_CICEN        0x00100000                           // Command Index Check Enable
  #define SDHC_XFERTYP_DPSEL        0x00200000                           // Data Present Select
  #define SDHC_XFERTYP_CMDTYP_NORM  0x00000000                           // Command Type
  #define SDHC_XFERTYP_CMDTYP_SUSP  0x00400000            
  #define SDHC_XFERTYP_CMDTYP_RESUM 0x00800000            
  #define SDHC_XFERTYP_CMDTYP_ABORT 0x00c00000            
  #define SDHC_XFERTYP_CMDINX_MASK  0x3f000000                           // Command Index value
  #define SDHC_XFERTYP_CMDINX_SHIFT 24
#define SDHC_CMDRSP0        *(volatile unsigned long *)(SDHC_BLOCK + 0x010) // SDHC Command Response Register 0 (read-only)
#define SDHC_CMDRSP1        *(volatile unsigned long *)(SDHC_BLOCK + 0x014) // SDHC Command Response Register 1 (read-only)
#define SDHC_CMDRSP2        *(volatile unsigned long *)(SDHC_BLOCK + 0x018) // SDHC Command Response Register 2 (read-only)
#define SDHC_CMDRSP3        *(volatile unsigned long *)(SDHC_BLOCK + 0x01c) // SDHC Command Response Register 3 (read-only)
#define SDHC_DATPORT        *(volatile unsigned long *)(SDHC_BLOCK + 0x020) // {3} SDHC Buffer Data Port Register
#define SDHC_PRSSTAT        *(volatile unsigned long *)(SDHC_BLOCK + 0x024) // SDHC Present Status Register (read-only)
  #define SDHC_PRSSTAT_CIHB      0x00000001                              // Command Inhibit (CMD)
  #define SDHC_PRSSTAT_CCIHB     0x00000002                              // Command Inhibit (DAT)
  #define SDHC_PRSSTAT_DLA       0x00000004                              // Data Line Active
  #define SDHC_PRSSTAT_SDSTB     0x00000008                              // SD Clock Stable
  #define SDHC_PRSSTAT_IPGOFF    0x00000010                              // Bus Clock Gated Off Internally
  #define SDHC_PRSSTAT_HCKOFF    0x00000020                              // System Clock Gated Off Internally
  #define SDHC_PRSSTAT_PEROFF    0x00000040                              // SDHC Clock Gated Off Internally
  #define SDHC_PRSSTAT_SDOFF     0x00000080                              // SD Clock Gated Off Internally
  #define SDHC_PRSSTAT_WTA       0x00000100                              // Write Transfer Active
  #define SDHC_PRSSTAT_RTA       0x00000200                              // Read Transfer Active
  #define SDHC_PRSSTAT_BWEN      0x00000400                              // Buffer Write Enable (non-DMA write transfers)
  #define SDHC_PRSSTAT_BREN      0x00000800                              // Buffer Read Enable (non-DMA read transfers)
  #define SDHC_PRSSTAT_CINS      0x00010000                              // Card Inserted
  #define SDHC_PRSSTAT_CLSL      0x00800000                              // CMD Line Signal Level
  #define SDHC_PRSSTAT_DLSL_MASK 0xff000000                              // DAT Line Signal level
#define SDHC_PROCTL         *(unsigned long *)(SDHC_BLOCK + 0x028)       // SDHC Protocol Control Register
  #define SDHC_PROCTL_LCTL         0x00000001                            // LED Control
  #define SDHC_PROCTL_DTW_1BIT     0x00000000                            // Data Transmit Width 1 Bit
  #define SDHC_PROCTL_DTW_4BIT     0x00000002                            // Data Transmit Width 4 Bits
  #define SDHC_PROCTL_DTW_8BIT     0x00000004                            // Data Transmit Width 8 Bits
  #define SDHC_PROCTL_D3CD         0x00000008                            // DAT3 as Card Detection Pin
  #define SDHC_PROCTL_EMODE_BIG    0x00000000                            // Big Endian Mode
  #define SDHC_PROCTL_EMODE_HBIG   0x00000010                            // Half-Word Big Endian Mode
  #define SDHC_PROCTL_EMODE_LITTLE 0x00000020                            // Little Endian Mode
  #define SDHC_PROCTL_CDTL         0x00000040                            // Card Detect Test Level
  #define SDHC_PROCTL_CDSS         0x00000080                            // Card Detect Signal Selection
  #define SDHC_PROCTL_DMAS_SIMPLE  0x00000000                            // No DMA or Simple DMA
  #define SDHC_PROCTL_DMAS_ADMA1   0x00000100                            // ADMA1
  #define SDHC_PROCTL_DMAS_ADMA2   0x00000200                            // ADMA2
  #define SDHC_PROCTL_SABGREQ      0x00010000                            // Stop At Block Gap Request
  #define SDHC_PROCTL_CREQ         0x00020000                            // Continue Request
  #define SDHC_PROCTL_RWCTL        0x00040000                            // Read Wait Control
  #define SDHC_PROCTL_IABG         0x00080000                            // Interrupt At Block Gap
  #define SDHC_PROCTL_WECINT       0x01000000                            // Wakeup Event On Card Interrupt
  #define SDHC_PROCTL_WECINS       0x02000000                            // Wakeup Event Enable On SD Card Insert
  #define SDHC_PROCTL_WECRM        0x04000000                            // Wakeup Event Enable On SD Card Removal
#define SDHC_SYSCTL         *(volatile unsigned long *)(SDHC_BLOCK + 0x02c) // SDHC System Control Register
  #define SDHC_SYSCTL_IPGEN     0x00000001                               // IPG Clock Enable
  #define SDHC_SYSCTL_HCKEN     0x00000002                               // System Clock Enable
  #define SDHC_SYSCTL_PEREN     0x00000004                               // Peripheral Clock Enable
  #define SDHC_SYSCTL_SDCLKEN   0x00000008                               // SD Clock Enable
  #define SDHC_SYSCTL_DVS_1     0x00000000                               // SDCLK Frequency Divisor 1
  #define SDHC_SYSCTL_DVS_2     0x00000010                               // SDCLK Frequency Divisor 2
  #define SDHC_SYSCTL_DVS_3     0x00000020                               // SDCLK Frequency Divisor 3
  #define SDHC_SYSCTL_DVS_4     0x00000030                               // SDCLK Frequency Divisor 4
  #define SDHC_SYSCTL_DVS_5     0x00000040                               // SDCLK Frequency Divisor 5
  #define SDHC_SYSCTL_DVS_6     0x00000050                               // SDCLK Frequency Divisor 6
  #define SDHC_SYSCTL_DVS_7     0x00000060                               // SDCLK Frequency Divisor 7
  #define SDHC_SYSCTL_DVS_8     0x00000070                               // SDCLK Frequency Divisor 8
  #define SDHC_SYSCTL_DVS_9     0x00000080                               // SDCLK Frequency Divisor 9
  #define SDHC_SYSCTL_DVS_10    0x00000090                               // SDCLK Frequency Divisor 10
  #define SDHC_SYSCTL_DVS_11    0x000000a0                               // SDCLK Frequency Divisor 11
  #define SDHC_SYSCTL_DVS_12    0x000000b0                               // SDCLK Frequency Divisor 12
  #define SDHC_SYSCTL_DVS_13    0x000000c0                               // SDCLK Frequency Divisor 13
  #define SDHC_SYSCTL_DVS_14    0x000000d0                               // SDCLK Frequency Divisor 14
  #define SDHC_SYSCTL_DVS_15    0x000000e0                               // SDCLK Frequency Divisor 15
  #define SDHC_SYSCTL_DVS_16    0x000000f0                               // SDCLK Frequency Divisor 16
  #define SDHC_SYSCTL_SDCLKFS_2 0x00000100                               // SDCLK Frequency Select - base clock divided by 2
  #define SDHC_SYSCTL_SDCLKFS_4 0x00000200                               // SDCLK Frequency Select - base clock divided by 4
  #define SDHC_SYSCTL_SDCLKFS_8 0x00000400                               // SDCLK Frequency Select - base clock divided by 8
  #define SDHC_SYSCTL_SDCLKFS_16 0x00000800                              // SDCLK Frequency Select - base clock divided by 16
  #define SDHC_SYSCTL_SDCLKFS_32 0x00001000                              // SDCLK Frequency Select - base clock divided by 32
  #define SDHC_SYSCTL_SDCLKFS_64 0x00002000                              // SDCLK Frequency Select - base clock divided by 64
  #define SDHC_SYSCTL_SDCLKFS_128 0x00004000                             // SDCLK Frequency Select - base clock divided by 128
  #define SDHC_SYSCTL_SDCLKFS_256 0x00008000                             // SDCLK Frequency Select - base clock divided by 256
  #define SDHC_SYSCTL_DTOCV_213 0x00000000                               // Data Timeout Counter Value - 213 SD clocks
  #define SDHC_SYSCTL_DTOCV_214 0x00010000                               // Data Timeout Counter Value - 214 SD clocks
  #define SDHC_SYSCTL_DTOCV_215 0x00020000                               // Data Timeout Counter Value - 215 SD clocks
  #define SDHC_SYSCTL_DTOCV_216 0x00030000                               // Data Timeout Counter Value - 216 SD clocks
  #define SDHC_SYSCTL_DTOCV_217 0x00040000                               // Data Timeout Counter Value - 217 SD clocks
  #define SDHC_SYSCTL_DTOCV_218 0x00050000                               // Data Timeout Counter Value - 218 SD clocks
  #define SDHC_SYSCTL_DTOCV_219 0x00060000                               // Data Timeout Counter Value - 219 SD clocks
  #define SDHC_SYSCTL_DTOCV_220 0x00070000                               // Data Timeout Counter Value - 220 SD clocks
  #define SDHC_SYSCTL_DTOCV_221 0x00080000                               // Data Timeout Counter Value - 221 SD clocks
  #define SDHC_SYSCTL_DTOCV_222 0x00090000                               // Data Timeout Counter Value - 222 SD clocks
  #define SDHC_SYSCTL_DTOCV_223 0x000a0000                               // Data Timeout Counter Value - 223 SD clocks
  #define SDHC_SYSCTL_DTOCV_224 0x000b0000                               // Data Timeout Counter Value - 224 SD clocks
  #define SDHC_SYSCTL_DTOCV_225 0x000c0000                               // Data Timeout Counter Value - 225 SD clocks
  #define SDHC_SYSCTL_DTOCV_226 0x000d0000                               // Data Timeout Counter Value - 226 SD clocks
  #define SDHC_SYSCTL_DTOCV_227 0x000e0000                               // Data Timeout Counter Value - 227 SD clocks
  #define SDHC_SYSCTL_RSTA    0x01000000                                 // Software Reset for ALL
  #define SDHC_SYSCTL_RSTC    0x02000000                                 // Software Reset for CMD Line
  #define SDHC_SYSCTL_RSTD    0x04000000                                 // Software Reset for DAT Line
  #define SDHC_SYSCTL_INITA   0x08000000                                 // Initialisation Active (80 SD-clocks sent to card - self clearing)
#define SDHC_IRQSTAT        *(volatile unsigned long *)(SDHC_BLOCK + 0x030) // SDHC Interrupt Status Register (write 1 to clear) 
  #define SDHC_IRQSTAT_CC    0x00000001                                  // Command Complete
  #define SDHC_IRQSTAT_TC    0x00000002                                  // Transfer Complete
  #define SDHC_IRQSTAT_BGE   0x00000004                                  // Block Gap Event
  #define SDHC_IRQSTAT_DINT  0x00000008                                  // DMA Interrupt
  #define SDHC_IRQSTAT_BWR   0x00000010                                  // Buffer Write Ready
  #define SDHC_IRQSTAT_BRR   0x00000020                                  // Buffer Read Ready
  #define SDHC_IRQSTAT_CINS  0x00000040                                  // Card Insertion
  #define SDHC_IRQSTAT_CRM   0x00000080                                  // Card Removal
  #define SDHC_IRQSTAT_CINT  0x00000100                                  // Card Interrupt
  #define SDHC_IRQSTAT_CTOE  0x00010000                                  // Command Timeout Error
  #define SDHC_IRQSTAT_CCE   0x00020000                                  // Command CRC Error
  #define SDHC_IRQSTAT_CEBE  0x00040000                                  // Command End Bit Error
  #define SDHC_IRQSTAT_CIE   0x00080000                                  // Command Index Error
  #define SDHC_IRQSTAT_DTOE  0x00100000                                  // Data Timeout Error
  #define SDHC_IRQSTAT_DCE   0x00200000                                  // Data CRC Error
  #define SDHC_IRQSTAT_DEBE  0x00400000                                  // Data End Bit Error
  #define SDHC_IRQSTAT_AC12E 0x01000000                                  // Auto CMD12 Error
  #define SDHC_IRQSTAT_DMAE  0x10000000                                  // DMA Error
#define SDHC_IRQSTATEN      *(unsigned long *)(SDHC_BLOCK + 0x034)       // SDHC Interrupt Status Enable Register
#define SDHC_IRQSIGEN       *(unsigned long *)(SDHC_BLOCK + 0x038)       // SDHC Interrupt Signal Enable Register
#define SDHC_AC12ERR        *(volatile unsigned long *)(SDHC_BLOCK + 0x03c) // SDHC Auto CMD12 Error Status Register (read-only)
#define SDHC_HTCAPBLT       *(volatile unsigned long *)(SDHC_BLOCK + 0x040) // SDHC Host Controller Capabilities Register (read-only)
#define SDHC_WML            *(unsigned long *)(SDHC_BLOCK + 0x044)       // SDHC Watermark Level Register

#define SDHC_FEVT           *(volatile unsigned long *)(SDHC_BLOCK + 0x050) // SDHC Force Event Register (write only)
#define SDHC_ADMAES         *(volatile unsigned long *)(SDHC_BLOCK + 0x054) // SDHC ADMA Error Status Register (read-only)
  #define SDHC_ADMAES_STSTOP  0x00000000                                 // error state was Stop DMA
  #define SDHC_ADMAES_ST_FDS  0x00000001                                 // error state was Fetch Descriptor
  #define SDHC_ADMAES_ST_CADR 0x00000002                                 // error state was Change Address
  #define SDHC_ADMAES_ST_TFR  0x00000003                                 // error state was Transfer Data
  #define SDHC_ADMAES_ADMALME 0x00000004                                 // ADMA Length Mismatch Error
  #define SDHC_ADMAES_ADMADCE 0x00000008                                 // ADMA Descriptor Error
#define SDHC_ADSADDR        *(unsigned long *)(SDHC_BLOCK + 0x058)       // SDHC ADMA System Address Register

#define SDHC_VENDOR         *(volatile unsigned long *)(SDHC_BLOCK + 0x0c0) // SDHC Vendor Specific Register
  #define SDHC_VENDOR_EXTDMAEN 0x00000001                                // External DMA Request Enable
  #define SDHC_VENDOR_VOLTSEL  0x00000002                                // Voltage Select
#define SDHC_MMCBOOT        *(unsigned long *)(SDHC_BLOCK + 0x0c4)       // SDHC MMC Boot Register

#define SDHC_HOSTVER        *(volatile unsigned long *)(SDHC_BLOCK + 0x0fc) // SDHC Host Controller Version Register (read-only)

extern void fnSetSD_clock(unsigned long ulSpeed);

typedef struct stKINETIS_ADMA2_BD
{
    unsigned long *adma_address_ptr;
    unsigned long len_attribute;
} KINETIS_ADMA2_BD;

#define ADMA2_BD_VALID      0x00000001
#define ADMA2_BD_END        0x00000002
#define ADMA2_BD_INT        0x00000004
#define ADMA2_BD_ACT1       0x00000010
#define ADMA2_BD_ACT2       0x00000020
#define ADMA2_NOP           0
#define ADMA2_TRAN          (ADMA2_BD_ACT2)
#define ADMA2_LINK          (ADMA2_BD_ACT1 | ADMA2_BD_ACT2)
#define ADMA2_BD_LEN_SHIFT  16

// RTC
//
#if defined KINETIS_KE
    #define RTC_SC              *(volatile unsigned long *)(RTC_BLOCK + 0x0) // RTC Status and Copntrol Register
      #define RTC_SC_RTCO       0x00000010                               // RTC counter output enable
      #define RTC_SC_RTIE       0x00000040                               // RTC interrupt enable
      #define RTC_SC_RTIF       0x00000080                               // RTC interrupt flag (write '1' to clear)
      #define RTC_SC_RTCPS_OFF  0x00000000                               // RTC prescaler off
      #define RTC_SC_RTCPS_1    0x00000100                               // RTC prescaler select - 1 (valid for RTC_SC_RTCLKS_EXT and RTC_SC_RTCLKS_INT)
      #define RTC_SC_RTCPS_2    0x00000200                               // RTC prescaler select - 2
      #define RTC_SC_RTCPS_4    0x00000300                               // RTC prescaler select - 4
      #define RTC_SC_RTCPS_8    0x00000400                               // RTC prescaler select - 8
      #define RTC_SC_RTCPS_16   0x00000500                               // RTC prescaler select - 16
      #define RTC_SC_RTCPS_32   0x00000600                               // RTC prescaler select - 32
      #define RTC_SC_RTCPS_64   0x00000700                               // RTC prescaler select - 64
      #define RTC_SC_RTCPS_128  0x00000100                               // RTC prescaler select - 128 (valid for RTC_SC_RTCLKS_1K and RTC_SC_RTCLKS_BUS)
      #define RTC_SC_RTCPS_256  0x00000200                               // RTC prescaler select - 256
      #define RTC_SC_RTCPS_512  0x00000300                               // RTC prescaler select - 512
      #define RTC_SC_RTCPS_1024 0x00000400                               // RTC prescaler select - 1024
      #define RTC_SC_RTCPS_2048 0x00000500                               // RTC prescaler select - 2048
      #define RTC_SC_RTCPS_100  0x00000600                               // RTC prescaler select - 100
      #define RTC_SC_RTCPS_1000 0x00000700                               // RTC prescaler select - 1000

      #define RTC_SC_RTCLKS_EXT 0x00000000                               // RTC source select - external clock source
      #define RTC_SC_RTCLKS_1K  0x00004000                               // RTC source select - 1kHz (LPOCLK)
      #define RTC_SC_RTCLKS_INT 0x00008000                               // RTC source select - internal reference clock (ICSIRCLK)
      #define RTC_SC_RTCLKS_BUS 0x0000c000                               // RTC source select - bus clock
    #define RTC_MOD             *(unsigned long *)(RTC_BLOCK + 0x4)      // RTC Modulo Register (16 bits)
    #define RTC_CNT             *(volatile unsigned long *)(RTC_BLOCK + 0x8) // RTC Counter Register (16 bits) (read-only)
#else
    #define RTC_TSR             *(volatile unsigned long *)(RTC_BLOCK + 0x000) // RTC Time Seconds Register
    #define RTC_TPR             *(unsigned long *)(RTC_BLOCK + 0x004)    // RTC Time Prescaler Register
      #define RTC_TPR_MASK      0x0000ffff
    #define RTC_TAR             *(unsigned long *)(RTC_BLOCK + 0x008)    // RTC Time Alarm Register
    #define RTC_TCR             *(unsigned long *)(RTC_BLOCK + 0x00c)    // RTC Time Compensation Register
    #define RTC_CR              *(unsigned long *)(RTC_BLOCK + 0x010)    // RTC Control Register
      #define RTC_CR_SWR        0x00000001                               // software reset
      #define RTC_CR_WPE        0x00000002                               // wakeup pin enable
      #define RTC_CR_SUP        0x00000004                               // allow non-supervisor mode write accesses to RTC
      #define RTC_CR_UM         0x00000008                               // update mode - registers can be written when locked under limited conditions
      #if defined KINETIS_KL
        #define RTC_CR_WPS      0x00000010                               // wakeup pin select
      #endif
      #define RTC_CR_OSCE       0x00000100                               // 32.768 kHz oscillator is enabled (wait oscillator startup time before enabling time counting)
      #define RTC_CR_CLKO       0x00000200                               // don't output 32.768 kHz clock to other peripherals
      #define RTC_CR_SC16P      0x00000400                               // enable 16pF load
      #define RTC_CR_SC8P       0x00000800                               // enable 8pF load
      #define RTC_CR_SC4P       0x00001000                               // enable 4pF load
      #define RTC_CR_SC2P       0x00002000                               // enable 2pF load
    #define RTC_SR              *(volatile unsigned long *)(RTC_BLOCK + 0x014) // RTC Status Register
      #define RTC_SR_TIF        0x00000001                               // time invalid flag (set on VBAT power up or software reset)
      #define RTC_SR_TOF        0x00000002                               // time overflow flag
      #define RTC_SR_TAF        0x00000004                               // time alarm flag
      #define RTC_SR_TCE        0x00000010                               // time counter is enabled
    #define RTC_LR              *(unsigned long *)(RTC_BLOCK + 0x018)    // RTC Lock Register
      #define RTC_LR_TCL        0x0000008f                               // time compensation lock (not locked)
      #define RTC_LR_CRL        0x00000097                               // control register lock (not locked)
      #define RTC_LR_SRL        0x000000a7                               // status register lock (not locked)
      #define RTC_LR_LRL        0x000000c7                               // lock register lock (not locked)
    #define RTC_IER             *(unsigned long *)(RTC_BLOCK + 0x01c)    // RTC Interrupt Enable Register
      #define RTC_IER_TIIE      0x00000001                               // time invalid interrupt enable
      #define RTC_IER_TOIE      0x00000002                               // time overflow interrupt enable
      #define RTC_IER_TAIE      0x00000004                               // time alarm interrupt enable
      #define RTC_IER_TSIE      0x00000010                               // seconds interrupt enable (when supported by the device)
    #if !defined KINETIS_KL
        #define RTC_WAR             *(unsigned long *)(RTC_BLOCK + 0x800)// RTC Write Access Register
          #define RTC_WAR_TSRW      0x00000001                           // time seconds register write (enable)
          #define RTC_WAR_TPRW      0x00000002                           // time prescaler register write (enable)
          #define RTC_WAR_TARW      0x00000004                           // time alarm register write (enable)
          #define RTC_WAR_TCRW      0x00000008                           // time compensation register write (enable)
          #define RTC_WAR_CRW       0x00000010                           // control register write (enable)
          #define RTC_WAR_SRW       0x00000020                           // status register write (enable)
          #define RTC_WAR_LRW       0x00000040                           // lock register write (enable)
          #define RTC_WAR_IERW      0x00000080                           // interrupt enable register write (enable)
        #define RTC_RAR             *(unsigned long *)(RTC_BLOCK + 0x804)// RTC Read Access Register
          #define RTC_RAR_TSRW      0x00000001                           // time seconds register read (enable)
          #define RTC_RAR_TPRW      0x00000002                           // time prescaler register read (enable)
          #define RTC_RAR_TARW      0x00000004                           // time alarm register read (enable)
          #define RTC_RAR_TCRW      0x00000008                           // time compensation register read (enable)
          #define RTC_RAR_CRW       0x00000010                           // control register read (enable)
          #define RTC_RAR_SRW       0x00000020                           // status register read (enable)
          #define RTC_RAR_LRW       0x00000040                           // lock register read (enable)
          #define RTC_RAR_IERW      0x00000080                           // interrupt enable register read (enable)
    #endif
#endif

// Low Power Timer [this module continues running through warm resets]   {51}
//
#define LPTMR0_CSR                       *(volatile unsigned long *)(LPTMR_BLOCK + 0x0) // Low Power Timer 0 Control Status Register
  #define LPTMR_CSR_TEN                  0x00000001                      // timer enable (set only after configuring other bits in this register)
  #define LPTMR_CSR_TMS_TIME_COUNTER     0x00000000                      // time counter mode
  #define LPTMR_CSR_TMS_PULSE_COUNTER    0x00000002                      // pulse counter mode
  #define LPTMR_CSR_TFC_RESET_ON_MATCH   0x00000000                      // counter is reset to 0 on match
  #define LPTMR_CSR_TFC_FREERUN          0x00000004                      // counter runs after match and overflows at 0xffff
  #define LPTMR_CSR_TPP_RISING_EDGE      0x00000000                      // timer pin polarity - rising edge
  #define LPTMR_CSR_TPP_FALLING_EDGE     0x00000008                      // timer pin polarity - falling edge
  #define LPTMR_CSR_TPS_0                0x00000000                      // timer pin select - input 0
  #define LPTMR_CSR_TPS_1                0x00000010                      // timer pin select - input 1
  #define LPTMR_CSR_TPS_2                0x00000020                      // timer pin select - input 2
  #define LPTMR_CSR_TPS_3                0x00000030                      // timer pin select - input 3
  #define LPTMR_CSR_TIE                  0x00000040                      // timer interrupt enable
  #define LPTMR_CSR_TCF                  0x00000080                      // timer compare flag - (write '1' to clear) set when the compare register matches and then one more increment has taken place
#define LPTMR0_PSR                       *(unsigned long *)(LPTMR_BLOCK + 0x4) // Low Power Timer 0 Prescaler Register
  #define LPTMR_PSR_PCS_MCGIRCLK         0x00000000                      // prescale clock select 0 (internal reference 30..40kHz or 4MHz)
  #define LPTMR_PSR_PCS_LPO              0x00000001                      // prescale clock select 1 (1kHz)
  #define LPTMR_PSR_PCS_ERCLK32K         0x00000002                      // prescale clock select 2 (30..40kHz external reference 32kHz)
  #define LPTMR_PSR_PCS_OSC0ERCLK        0x00000003                      // prescale clock select 3 (external oscillator reference)
  #define LPTMR_PSR_PBYP                 0x00000004                      // prescaler bypass
  #define LPTMR_PSR_PRESCALE_MASK        0x00000078                      // prescale/glitch filter divide 2..32768) - change only when LPTMR is disabled
  #define LPTMR_PSR_PRESCALE_SHIFT       3 
    #if defined LPTMR_PRESCALE
      #if LPTMR_PRESCALE == 2
        #define LPTMR_PRESCALE_VALUE     0                               // divide by 2
      #elif LPTMR_PRESCALE == 4
        #define LPTMR_PRESCALE_VALUE     1                               // divide by 4
      #elif LPTMR_PRESCALE == 8
        #define LPTMR_PRESCALE_VALUE     2                               // divide by 8
      #elif LPTMR_PRESCALE == 16
        #define LPTMR_PRESCALE_VALUE     3                               // divide by 16
      #elif LPTMR_PRESCALE == 32
        #define LPTMR_PRESCALE_VALUE     4                               // divide by 32
      #elif LPTMR_PRESCALE == 64
        #define LPTMR_PRESCALE_VALUE     5                               // divide by 64
      #elif LPTMR_PRESCALE == 128
        #define LPTMR_PRESCALE_VALUE     6                               // divide by 128
      #elif LPTMR_PRESCALE == 256
        #define LPTMR_PRESCALE_VALUE     7                               // divide by 256
      #elif LPTMR_PRESCALE == 512
        #define LPTMR_PRESCALE_VALUE     8                               // divide by 512
      #elif LPTMR_PRESCALE == 1024
        #define LPTMR_PRESCALE_VALUE     9                               // divide by 1024
      #elif LPTMR_PRESCALE == 2048
        #define LPTMR_PRESCALE_VALUE     10                              // divide by 2048
      #elif LPTMR_PRESCALE == 4096
        #define LPTMR_PRESCALE_VALUE     11                              // divide by 4096
      #elif LPTMR_PRESCALE == 8192
        #define LPTMR_PRESCALE_VALUE     12                              // divide by 8192
      #elif LPTMR_PRESCALE == 16384
        #define LPTMR_PRESCALE_VALUE     13                              // divide by 16384
      #elif LPTMR_PRESCALE == 32768
        #define LPTMR_PRESCALE_VALUE     14                              // divide by 32768
      #elif LPTMR_PRESCALE == 65536
        #define LPTMR_PRESCALE_VALUE     15                              // divide by 65536
      #else
        #error Illegal low power timer prescale value (2, 4, 8, .. 65536 possible)!!
      #endif
    #endif
#define LPTMR0_CMR                       *(volatile unsigned long *)(LPTMR_BLOCK + 0x8) // Low Power Timer 0 Compare Register (16 bits) - this register can only be altered once the timer is set active  when the timer compare flag is set
#define LPTMR0_CNR                       *(volatile unsigned long *)(LPTMR_BLOCK + 0xc) // Low Power Timer 0 Counter Register (16 bits read-only) - to read the counter value write any value to this register and immediately read back

#if !defined KINETIS_KL && !defined KINETIS_KE && !defined CROSSBAR_SWITCH_LITE
// Crossbar Switch                                                       {50}
//
#define AXBS_PRS0                        *(volatile unsigned long *)(AXBS_BLOCK + 0x000) // Priority Registers Slave 0
  #define AXBS_PRS_MASTER_PRIORITY_1     0x0                             // highest priority master - level 1
  #define AXBS_PRS_MASTER_PRIORITY_2     0x1                             // master priority level 2
  #define AXBS_PRS_MASTER_PRIORITY_3     0x2                             // master priority level 3
  #define AXBS_PRS_MASTER_PRIORITY_4     0x3                             // master priority level 4
  #define AXBS_PRS_MASTER_PRIORITY_5     0x4                             // master priority level 5
  #define AXBS_PRS_MASTER_PRIORITY_6     0x5                             // master priority level 6
  #define AXBS_PRS_MASTER_PRIORITY_7     0x6                             // master priority level 7
  #define AXBS_PRS_MASTER_PRIORITY_8     0x7                             // lowest master priority level 8
  #define AXBS_PRS_MASTER_M0_SHIFT       0
  #define AXBS_PRS_MASTER_M1_SHIFT       4
  #define AXBS_PRS_MASTER_M2_SHIFT       8
  #define AXBS_PRS_MASTER_M3_SHIFT       12
  #define AXBS_PRS_MASTER_M4_SHIFT       16
  #define AXBS_PRS_MASTER_M5_SHIFT       20
  #define AXBS_PRS_MASTER_M6_SHIFT       24
  #define AXBS_PRS_MASTER_M7_SHIFT       28
  #define AXBS_PRS_MASTER_M0_MASK        0x0000000f
  #define AXBS_PRS_MASTER_M1_MASK        0x000000f0
  #define AXBS_PRS_MASTER_M2_MASK        0x00000f00
  #define AXBS_PRS_MASTER_M3_MASK        0x0000f000
  #define AXBS_PRS_MASTER_M4_MASK        0x000f0000
  #define AXBS_PRS_MASTER_M5_MASK        0x00f00000
  #define AXBS_PRS_MASTER_M6_MASK        0x0f000000
  #define AXBS_PRS_MASTER_M7_MASK        0xf0000000
#define AXBS_CRS0                        *(volatile unsigned long *)(AXBS_BLOCK + 0x010) // Control Registers 0
  #define AXBS_CRS_PARK_ON_MASTER_M0     0x00000000                      // park slave port on master port M0
  #define AXBS_CRS_PARK_ON_MASTER_M1     0x00000001                      // park slave port on master port M1
  #define AXBS_CRS_PARK_ON_MASTER_M2     0x00000002                      // park slave port on master port M2
  #define AXBS_CRS_PARK_ON_MASTER_M3     0x00000003                      // park slave port on master port M3
  #define AXBS_CRS_PARK_ON_MASTER_M4     0x00000004                      // park slave port on master port M4
  #define AXBS_CRS_PARK_ON_MASTER_M5     0x00000005                      // park slave port on master port M5
  #define AXBS_CRS_PARK_ON_MASTER_M6     0x00000006                      // park slave port on master port M6
  #define AXBS_CRS_PARK_ON_MASTER_M7     0x00000007                      // park slave port on master port M7
  #define AXBS_CRS_PCTL_PARK_ON_DEFINED  0x00000000                      // when no master makes a request, the arbiter parks the slave port on the master port defined by the PARK field
  #define AXBS_CRS_PCTL_PARK_ON_LAST     0x00000010                      // when no master makes a request, the arbiter parks the slave port on the last master to be in control of the slave port
  #define AXBS_CRS_PCTL_NO_PARK          0x00000020                      // when no master makes a request, the slave port is not parked on a master and the arbiter drives all outputs to a constant safe state
  #define AXBS_CRS_ARB_FIXED_PRIORITY    0x00000000                      // arbiter policy - fixed priority
  #define AXBS_CRS_ARB_ROUND_ROBIN       0x00000100                      // arbiter policy - round robin, or rotating, priority
  #define AXBS_CRS_HLP                   0x40000000                      // halt low priority
  #define AXBS_CRS_RO                    0x80000000                      // force AXBS_CSRn and AXBS_PRSn registers to be read-only until next reset
#define AXBS_PRS1                        *(volatile unsigned long *)(AXBS_BLOCK + 0x100) // Priority Registers Slave 1
#define AXBS_CRS1                        *(volatile unsigned long *)(AXBS_BLOCK + 0x110) // Control Registers 1
#define AXBS_PRS2                        *(volatile unsigned long *)(AXBS_BLOCK + 0x200) // Priority Registers Slave 2
#define AXBS_CRS2                        *(volatile unsigned long *)(AXBS_BLOCK + 0x210) // Control Registers 2
#define AXBS_PRS3                        *(volatile unsigned long *)(AXBS_BLOCK + 0x300) // Priority Registers Slave 3
#define AXBS_CRS3                        *(volatile unsigned long *)(AXBS_BLOCK + 0x310) // Control Registers 3
#define AXBS_PRS4                        *(volatile unsigned long *)(AXBS_BLOCK + 0x400) // Priority Registers Slave 4
#define AXBS_CRS4                        *(volatile unsigned long *)(AXBS_BLOCK + 0x410) // Control Registers 4
#define AXBS_PRS5                        *(volatile unsigned long *)(AXBS_BLOCK + 0x500) // Priority Registers Slave 5
#define AXBS_CRS5                        *(volatile unsigned long *)(AXBS_BLOCK + 0x510) // Control Registers 5
#define AXBS_PRS6                        *(volatile unsigned long *)(AXBS_BLOCK + 0x600) // Priority Registers Slave 6
#define AXBS_CRS6                        *(volatile unsigned long *)(AXBS_BLOCK + 0x610) // Control Registers 6
#define AXBS_PRS7                        *(volatile unsigned long *)(AXBS_BLOCK + 0x700) // Priority Registers Slave 7
#define AXBS_CRS7                        *(volatile unsigned long *)(AXBS_BLOCK + 0x710) // Control Registers 7
#define AXBS_MGPCR0                      *(volatile unsigned long *)(AXBS_BLOCK + 0x800) // Master General Purpose Control Registers 0
  #define AXBS_MGPCR_AULB_NO_ARB         0x00000000                      // no arbitration is allowed during an undefined length burst
  #define AXBS_MGPCR_AULB_ANY_TIME_ARB   0x00000001                      // arbitration is allowed at any time during an undefined length burst
  #define AXBS_MGPCR_AULB_4_BEATS        0x00000002                      // arbitration is allowed after four beats of an undefined length burst
  #define AXBS_MGPCR_AULB_8_BEATS        0x00000003                      // arbitration is allowed after eight beats of an undefined length burst
  #define AXBS_MGPCR_AULB_16_BEATS       0x00000004                      // arbitration is allowed after sixteen beats of an undefined length burst
#define AXBS_MGPCR1                      *(volatile unsigned long *)(AXBS_BLOCK + 0x900) // Master General Purpose Control Registers 1
#define AXBS_MGPCR2                      *(volatile unsigned long *)(AXBS_BLOCK + 0xa00) // Master General Purpose Control Registers 2
#define AXBS_MGPCR3                      *(volatile unsigned long *)(AXBS_BLOCK + 0xb00) // Master General Purpose Control Registers 3
#define AXBS_MGPCR4                      *(volatile unsigned long *)(AXBS_BLOCK + 0xc00) // Master General Purpose Control Registers 4
#define AXBS_MGPCR5                      *(volatile unsigned long *)(AXBS_BLOCK + 0xd00) // Master General Purpose Control Registers 5
#define AXBS_MGPCR6                      *(volatile unsigned long *)(AXBS_BLOCK + 0xe00) // Master General Purpose Control Registers 6
#define AXBS_MGPCR7                      *(volatile unsigned long *)(AXBS_BLOCK + 0xf00) // Master General Purpose Control Registers 7
#endif

// Touch Sense Input Module
//
#if defined KINETIS_KL
    #define TSI0_GENCS                   *(volatile unsigned long *)(TSI_BLOCK + 0x000) // General Control and Status Register
      #define TSI_GENCS_CURSW            0x00000002                      // swap current sources of electrode and reference oscillator
      #define TSI_GENCS_EOSF             0x00000004                      // End of Scan Flag (write '1' to clear)
      #define TSI_GENCS_SCNIP            0x00000008                      // Scan In Progress (read-only)
      #define TSI_GENCS_STM_SW           0x00000000                      // Scan Trigger Mode Software
      #define TSI_GENCS_STM_HW           0x00000010                      // Scan Trigger Mode Hardware
      #define TSI_GENCS_STPE             0x00000020                      // Touch Sensing Input STOP Enable (continues running in stop, VLPS, LLS and VLLS{3,2,1})
      #define TSI_GENCS_TSIIEN           0x00000040                      // Touch Sensing Input Interrupt Enable
      #define TSI_GENCS_TSIEN            0x00000080                      // Touch Sensing Input Module Enable
      #define TSI_GENCS_NSCN_1           0x00000000                      // scan 1x per electrode
      #define TSI_GENCS_NSCN_2           0x00000100                      // scan 2x per electrode
      #define TSI_GENCS_NSCN_3           0x00000200                      // scan 3x per electrode
      #define TSI_GENCS_NSCN_4           0x00000300                      // scan 4x per electrode
      #define TSI_GENCS_NSCN_5           0x00000400                      // scan 5x per electrode
      #define TSI_GENCS_NSCN_6           0x00000500                      // scan 6x per electrode
      #define TSI_GENCS_NSCN_7           0x00000600                      // scan 7x per electrode
      #define TSI_GENCS_NSCN_8           0x00000700                      // scan 8x per electrode
      #define TSI_GENCS_NSCN_9           0x00000800                      // scan 9x per electrode
      #define TSI_GENCS_NSCN_10          0x00000900                      // scan 10x per electrode
      #define TSI_GENCS_NSCN_11          0x00000a00                      // scan 11x per electrode
      #define TSI_GENCS_NSCN_12          0x00000b00                      // scan 12x per electrode
      #define TSI_GENCS_NSCN_13          0x00000c00                      // scan 13x per electrode
      #define TSI_GENCS_NSCN_14          0x00000d00                      // scan 14x per electrode
      #define TSI_GENCS_NSCN_15          0x00000e00                      // scan 15x per electrode
      #define TSI_GENCS_NSCN_16          0x00000f00                      // scan 16x per electrode
      #define TSI_GENCS_NSCN_17          0x00001000                      // scan 17x per electrode
      #define TSI_GENCS_NSCN_18          0x00001100                      // scan 18x per electrode
      #define TSI_GENCS_NSCN_19          0x00001200                      // scan 19x per electrode
      #define TSI_GENCS_NSCN_20          0x00001300                      // scan 20x per electrode
      #define TSI_GENCS_NSCN_21          0x00001400                      // scan 21x per electrode
      #define TSI_GENCS_NSCN_22          0x00001500                      // scan 22x per electrode
      #define TSI_GENCS_NSCN_23          0x00001600                      // scan 23x per electrode
      #define TSI_GENCS_NSCN_24          0x00001700                      // scan 24x per electrode
      #define TSI_GENCS_NSCN_25          0x00001800                      // scan 25x per electrode
      #define TSI_GENCS_NSCN_26          0x00001900                      // scan 26x per electrode
      #define TSI_GENCS_NSCN_27          0x00001a00                      // scan 27x per electrode
      #define TSI_GENCS_NSCN_28          0x00001b00                      // scan 28x per electrode
      #define TSI_GENCS_NSCN_29          0x00001c00                      // scan 29x per electrode
      #define TSI_GENCS_NSCN_30          0x00001d00                      // scan 30x per electrode
      #define TSI_GENCS_NSCN_31          0x00001e00                      // scan 31x per electrode
      #define TSI_GENCS_NSCN_32          0x00001f00                      // scan 32x per electrode
      #define TSI_GENCS_PS_DIV_1         0x00000000                      // electrode oscillator frequency divided by 1
      #define TSI_GENCS_PS_DIV_2         0x00002000                      // electrode oscillator frequency divided by 2
      #define TSI_GENCS_PS_DIV_4         0x00004000                      // electrode oscillator frequency divided by 4
      #define TSI_GENCS_PS_DIV_8         0x00006000                      // electrode oscillator frequency divided by 8
      #define TSI_GENCS_PS_DIV_16        0x00008000                      // electrode oscillator frequency divided by 16
      #define TSI_GENCS_PS_DIV_32        0x0000a000                      // electrode oscillator frequency divided by 32
      #define TSI_GENCS_PS_DIV_64        0x0000c000                      // electrode oscillator frequency divided by 64
      #define TSI_GENCS_PS_DIV_128       0x0000e000                      // electrode oscillator frequency divided by 128
      #define TSI_GENCS_EXTCHRG_500nA    0x00000000                      // electrode oscillator charge and discharge current value - 500nA
      #define TSI_GENCS_EXTCHRG_1uA      0x00010000                      // electrode oscillator charge and discharge current value - 1uA
      #define TSI_GENCS_EXTCHRG_2uA      0x00020000                      // electrode oscillator charge and discharge current value - 2uA
      #define TSI_GENCS_EXTCHRG_4uA      0x00030000                      // electrode oscillator charge and discharge current value - 4uA
      #define TSI_GENCS_EXTCHRG_8uA      0x00040000                      // electrode oscillator charge and discharge current value - 8uA
      #define TSI_GENCS_EXTCHRG_16uA     0x00050000                      // electrode oscillator charge and discharge current value - 16uA
      #define TSI_GENCS_EXTCHRG_32uA     0x00060000                      // electrode oscillator charge and discharge current value - 32uA
      #define TSI_GENCS_EXTCHRG_64uA     0x00070000                      // electrode oscillator charge and discharge current value - 64uA
      #define TSI_GENCS_DVOLT_1_03       0x00000000                      // oscillator's voltage rails (DV = 1.03V; Vp = 1.33V; Vm = 0.30V)
      #define TSI_GENCS_DVOLT_0_73       0x00080000                      // oscillator's voltage rails (DV = 0.73V; Vp = 1.18V; Vm = 0.45V)
      #define TSI_GENCS_DVOLT_0_43       0x00100000                      // oscillator's voltage rails (DV = 0.43V; Vp = 1.03V; Vm = 0.60V)
      #define TSI_GENCS_DVOLT_0_29       0x00180000                      // oscillator's voltage rails (DV = 0.29V; Vp = 0.95V; Vm = 0.67V)
      #define TSI_GENCS_REFCHRG_500nA    0x00000000                      // reference oscillator charge and discharge current value - 500nA
      #define TSI_GENCS_REFCHRG_1uA      0x00200000                      // reference oscillator charge and discharge current value - 1uA
      #define TSI_GENCS_REFCHRG_2uA      0x00400000                      // reference oscillator charge and discharge current value - 2uA
      #define TSI_GENCS_REFCHRG_4uA      0x00600000                      // reference oscillator charge and discharge current value - 4uA
      #define TSI_GENCS_REFCHRG_8uA      0x00800000                      // reference oscillator charge and discharge current value - 8uA
      #define TSI_GENCS_REFCHRG_16uA     0x00a00000                      // reference oscillator charge and discharge current value - 16uA
      #define TSI_GENCS_REFCHRG_32uA     0x00c00000                      // reference oscillator charge and discharge current value - 32uA
      #define TSI_GENCS_REFCHRG_64uA     0x00e00000                      // reference oscillator charge and discharge current value - 64uA
      #define TSI_GENCS_MODE_CAPACITIVE  0x00000000                      // capacitive sending (non-noise detection) mode
      #define TSI_GENCS_MODE_SINGLE      0x04000000                      // analog single threshold noise detection mode with disabled frequency limitation circuit
      #define TSI_GENCS_MODE_SINGLE_LIM  0x08000000                      // analog single threshold noise detection mode with enabled frequency limitation circuit
      #define TSI_GENCS_MODE_AUTO        0x0c000000                      // analog in automatic noise detection mode
      #define TSI_GENCS_ESOR_OUT_OF_RANGE 0x00000000                     // out-of-range interrupt selected
      #define TSI_GENCS_ESOR_END_OF_SCAN 0x10000000                      // end-of-scan interrupt selected
      #define TSI_GENCS_OUTRGF           0x80000000                      // out of range flag - write '1' to clear
    #define TSI0_DATA                    *(volatile unsigned long*)(TSI_BLOCK + 0x004) // Data Register
      #define TSI0_DATA_TSICNT           0x003fffff                      // TSI conversion counter value (read-only)
      #define TSI0_DATA_SWTS             0x00400000                      // trigger a software started scan of the selected channel
      #define TSI0_DATA_DMAEN            0x00800000                      // DMA transfer enabled
      #define TSI0_DATA_TSICH_0          0x00000000                      // current channel to be measured - channel 0
      #define TSI0_DATA_TSICH_1          0x10000000                      // current channel to be measured - channel 1
      #define TSI0_DATA_TSICH_2          0x20000000                      // current channel to be measured - channel 2
      #define TSI0_DATA_TSICH_3          0x30000000                      // current channel to be measured - channel 3
      #define TSI0_DATA_TSICH_4          0x40000000                      // current channel to be measured - channel 4
      #define TSI0_DATA_TSICH_5          0x50000000                      // current channel to be measured - channel 5
      #define TSI0_DATA_TSICH_6          0x60000000                      // current channel to be measured - channel 6
      #define TSI0_DATA_TSICH_7          0x70000000                      // current channel to be measured - channel 7
      #define TSI0_DATA_TSICH_8          0x80000000                      // current channel to be measured - channel 8
      #define TSI0_DATA_TSICH_9          0x90000000                      // current channel to be measured - channel 9
      #define TSI0_DATA_TSICH_10         0xa0000000                      // current channel to be measured - channel 10
      #define TSI0_DATA_TSICH_11         0xb0000000                      // current channel to be measured - channel 11
      #define TSI0_DATA_TSICH_12         0xc0000000                      // current channel to be measured - channel 12
      #define TSI0_DATA_TSICH_13         0xd0000000                      // current channel to be measured - channel 13
      #define TSI0_DATA_TSICH_14         0xe0000000                      // current channel to be measured - channel 14
      #define TSI0_DATA_TSICH_15         0xf0000000                      // current channel to be measured - channel 15
    #define TSI0_TSHD                    *(unsigned long*)(TSI_BLOCK + 0x008) // Threshold Register
      #define TSI0_DATA_TSHD_THRESL      0x0000ffff                      // low threshold mask of the wakeup channel
      #define TSI0_DATA_TSHD_THRESH      0xffff0000                      // high threshold mask of the wakeup channel
#else
    #define TSI0_GENCS                   *(volatile unsigned long *)(TSI_BLOCK + 0x000) // General Control and Status Register
      #define TSI_GENCS_STPE             0x00000001                      // allow TSI to continue running in all low power modes
      #define TSI_GENCS_STM_SW_TRIG      0x00000000                      // software trigger scan mode
      #define TSI_GENCS_STM_PERIODIC     0x00000002                      // periodic scan mode
      #define TSI_GENCS_ESOR_OUT_OF_RANGE 0x00000000                     // out-of-range interrupt selected
      #define TSI_GENCS_ESOR_END_OF_SCAN 0x00000010                      // end-of-scan interrupt selected
      #define TSI_GENCS_ERIE             0x00000020                      // TSI error interrupt enable
      #define TSI_GENCS_TSIIE            0x00000040                      // TSI interrupt enable
      #define TSI_GENCS_TSIEN            0x00000080                      // TSI module enable
      #define TSI_GENCS_SWTS             0x00000100                      // software trigger start - write '1' only
      #define TSI_GENCS_SCNIP            0x00000200                      // scan in progress status - read-only
      #define TSI_GENCS_OVRF             0x00001000                      // overrun error flag - write '1' to clear
      #define TSI_GENCS_EXTERF           0x00002000                      // external electrode error occurred - write '1' to clear
      #define TSI_GENCS_OUTRGF           0x00004000                      // out of range flag - write '1' to clear
      #define TSI_GENCS_EOSF             0x00008000                      // end fo scan flag - write '1' to clear
      #define TSI_GENCS_PS_1             0x00000000                      // electrode oscillator prescaler - divide by 1
      #define TSI_GENCS_PS_2             0x00010000                      // electrode oscillator prescaler - divide by 2
      #define TSI_GENCS_PS_4             0x00020000                      // electrode oscillator prescaler - divide by 4
      #define TSI_GENCS_PS_8             0x00030000                      // electrode oscillator prescaler - divide by 8
      #define TSI_GENCS_PS_16            0x00040000                      // electrode oscillator prescaler - divide by 16
      #define TSI_GENCS_PS_32            0x00050000                      // electrode oscillator prescaler - divide by 32
      #define TSI_GENCS_PS_64            0x00060000                      // electrode oscillator prescaler - divide by 64
      #define TSI_GENCS_PS_128           0x00070000                      // electrode oscillator prescaler - divide by 128
      #define TSI_GENCS_NSCN_MASK        0x00f80000                      // number of consecutive scans per electrode (0x00.. 0x1f : 1 .. 32)
      #define TSI_GENCS_LPSCNITV_1ms     0x00000000                      // low power mode scan interval - 1ms
      #define TSI_GENCS_LPSCNITV_5ms     0x01000000                      // low power mode scan interval - 5ms
      #define TSI_GENCS_LPSCNITV_10ms    0x02000000                      // low power mode scan interval - 10ms
      #define TSI_GENCS_LPSCNITV_15ms    0x03000000                      // low power mode scan interval - 15ms
      #define TSI_GENCS_LPSCNITV_20ms    0x04000000                      // low power mode scan interval - 20ms
      #define TSI_GENCS_LPSCNITV_30ms    0x05000000                      // low power mode scan interval - 30ms
      #define TSI_GENCS_LPSCNITV_40ms    0x06000000                      // low power mode scan interval - 40ms
      #define TSI_GENCS_LPSCNITV_50ms    0x07000000                      // low power mode scan interval - 50ms
      #define TSI_GENCS_LPSCNITV_75ms    0x08000000                      // low power mode scan interval - 75ms
      #define TSI_GENCS_LPSCNITV_100ms   0x09000000                      // low power mode scan interval - 100ms
      #define TSI_GENCS_LPSCNITV_125ms   0x0a000000                      // low power mode scan interval - 125ms
      #define TSI_GENCS_LPSCNITV_150ms   0x0b000000                      // low power mode scan interval - 150ms
      #define TSI_GENCS_LPSCNITV_200ms   0x0c000000                      // low power mode scan interval - 200ms
      #define TSI_GENCS_LPSCNITV_300ms   0x0d000000                      // low power mode scan interval - 300ms
      #define TSI_GENCS_LPSCNITV_400ms   0x0e000000                      // low power mode scan interval - 400ms
      #define TSI_GENCS_LPSCNITV_500ms   0x0f000000                      // low power mode scan interval - 500ms
      #define TSI_GENCS_LPCLKS_LPOCLK    0x00000000                      // low power mode clock selection
      #define TSI_GENCS_LPCLKS_VLPOSCCLK 0x10000000                      // low power mode clock selection
    #define TSI0_SCANC                   *(unsigned long*)(TSI_BLOCK + 0x004) // SCAN Control Register
      #define TSI_SCANC_REFCHRG_MASK     0xf8000000                      // reference oscillator charge current select (0x00..0x1f : 1uA..32uA)
      #define TSI_SCANC_CAPTRM_MASK      0x07000000                      // internal capacitance trim value (0x0..0x7 : 0.5pF..1.2pF in steps of 0.1pF)
      #define TSI_SCANC_EXTCHRGG_MASK    0x00f80000                      // external oscillator charge current select (0x00..0x1f : 1uA..32uA)
      #define TSI_SCANC_DELVOL_100mV     0x00000000                      // delta voltage select applied to analogue oscillators - 100mV
      #define TSI_SCANC_DELVOL_150mV     0x00010000                      // delta voltage select applied to analogue oscillators - 150mV
      #define TSI_SCANC_DELVOL_200mV     0x00020000                      // delta voltage select applied to analogue oscillators - 200mV
      #define TSI_SCANC_DELVOL_250mV     0x00030000                      // delta voltage select applied to analogue oscillators - 250mV
      #define TSI_SCANC_DELVOL_300mV     0x00040000                      // delta voltage select applied to analogue oscillators - 300mV
      #define TSI_SCANC_DELVOL_400mV     0x00050000                      // delta voltage select applied to analogue oscillators - 400mV
      #define TSI_SCANC_DELVOL_500mV     0x00060000                      // delta voltage select applied to analogue oscillators - 500mV
      #define TSI_SCANC_DELVOL_600mV     0x00070000                      // delta voltage select applied to analogue oscillators - 600mV
      #define TSI_SCANC_SMOD_CONTINUOUS  0x00000000                      // scan modulo continuous
      #define TSI_SCANC_SMOD_MASK        0x0000ff00                      // scan modulo mask
      #define TSI_SCANC_AMCLKDIV_2048    0x00000020                      // active mode clock divider - divide by 2048
      #define TSI_SCANC_AMCLKDIV_1       0x00000000                      // active mode clock divider off
      #define TSI_SCANC_AMCLKS_BUS_CLK   0x00000000                      // active mode clock source is bus clock
      #define TSI_SCANC_AMCLKS_MCGIRCLK  0x00000008                      // active mode clock source is MCGIRCLK 
      #define TSI_SCANC_AMCLKS_OSCERCLK  0x00000010                      // active mode clock source is OSCERCLK
      #define TSI_SCANC_AMPSC_1          0x00000000                      // active mode prescaler - divide by 1
      #define TSI_SCANC_AMPSC_2          0x00000001                      // active mode prescaler - divide by 2
      #define TSI_SCANC_AMPSC_4          0x00000002                      // active mode prescaler - divide by 4
      #define TSI_SCANC_AMPSC_8          0x00000003                      // active mode prescaler - divide by 8
      #define TSI_SCANC_AMPSC_16         0x00000004                      // active mode prescaler - divide by 16
      #define TSI_SCANC_AMPSC_32         0x00000005                      // active mode prescaler - divide by 32
      #define TSI_SCANC_AMPSC_54         0x00000006                      // active mode prescaler - divide by 64
      #define TSI_SCANC_AMPSC_128        0x00000007                      // active mode prescaler - divide by 128
    #define TSI0_PEN                     *(unsigned long*)(TSI_BLOCK + 0x008) // Pin Enable Register (do not change when GENCS[TSIEN] is set
      #define TSI_PEN_PEN0               0x00000001                      // TSI pin 0 enable
      #define TSI_PEN_PEN1               0x00000002                      // TSI pin 1 enable
      #define TSI_PEN_PEN2               0x00000004                      // TSI pin 2 enable
      #define TSI_PEN_PEN3               0x00000008                      // TSI pin 3 enable
      #define TSI_PEN_PEN4               0x00000010                      // TSI pin 4 enable
      #define TSI_PEN_PEN5               0x00000020                      // TSI pin 5 enable
      #define TSI_PEN_PEN6               0x00000040                      // TSI pin 6 enable
      #define TSI_PEN_PEN7               0x00000080                      // TSI pin 7 enable
      #define TSI_PEN_PEN8               0x00000100                      // TSI pin 8 enable
      #define TSI_PEN_PEN9               0x00000200                      // TSI pin 9 enable
      #define TSI_PEN_PEN10              0x00000400                      // TSI pin 10 enable
      #define TSI_PEN_PEN11              0x00000800                      // TSI pin 11 enable
      #define TSI_PEN_PEN12              0x00001000                      // TSI pin 12 enable
      #define TSI_PEN_PEN13              0x00002000                      // TSI pin 13 enable
      #define TSI_PEN_PEN14              0x00004000                      // TSI pin 14 enable
      #define TSI_PEN_PEN15              0x00008000                      // TSI pin 15 enable
      #define TSI_PEN_LPSP0              0x00000000                      // TSI pin 0 is enabled in low power scan mode
      #define TSI_PEN_LPSP1              0x00010000                      // TSI pin 1 is enabled in low power scan mode
      #define TSI_PEN_LPSP2              0x00020000                      // TSI pin 2 is enabled in low power scan mode
      #define TSI_PEN_LPSP3              0x00030000                      // TSI pin 3 is enabled in low power scan mode
      #define TSI_PEN_LPSP4              0x00040000                      // TSI pin 4 is enabled in low power scan mode
      #define TSI_PEN_LPSP5              0x00050000                      // TSI pin 5 is enabled in low power scan mode
      #define TSI_PEN_LPSP6              0x00060000                      // TSI pin 6 is enabled in low power scan mode
      #define TSI_PEN_LPSP7              0x00070000                      // TSI pin 7 is enabled in low power scan mode
      #define TSI_PEN_LPSP8              0x00080000                      // TSI pin 8 is enabled in low power scan mode
      #define TSI_PEN_LPSP9              0x00090000                      // TSI pin 9 is enabled in low power scan mode
      #define TSI_PEN_LPSP10             0x000a0000                      // TSI pin 10 is enabled in low power scan mode
      #define TSI_PEN_LPSP11             0x000b0000                      // TSI pin 11 is enabled in low power scan mode
      #define TSI_PEN_LPSP12             0x000c0000                      // TSI pin 12 is enabled in low power scan mode
      #define TSI_PEN_LPSP13             0x000d0000                      // TSI pin 13 is enabled in low power scan mode
      #define TSI_PEN_LPSP14             0x000e0000                      // TSI pin 14 is enabled in low power scan mode
      #define TSI_PEN_LPSP15             0x000f0000                      // TSI pin 15 is enabled in low power scan mode
    #define TSI0_STATUS                  *(volatile unsigned long*)(TSI_BLOCK + 0x00c) // Status Register (write '1' to clear)
      #define TSI_STATUS_ORNGF0          0x00000001                      // TSI channel 0 electrode out of range
      #define TSI_STATUS_ORNGF1          0x00000002                      // TSI channel 1 electrode out of range
      #define TSI_STATUS_ORNGF2          0x00000004                      // TSI channel 2 electrode out of range
      #define TSI_STATUS_ORNGF3          0x00000008                      // TSI channel 3 electrode out of range
      #define TSI_STATUS_ORNGF4          0x00000010                      // TSI channel 4 electrode out of range
      #define TSI_STATUS_ORNGF5          0x00000020                      // TSI channel 5 electrode out of range
      #define TSI_STATUS_ORNGF6          0x00000040                      // TSI channel 6 electrode out of range
      #define TSI_STATUS_ORNGF7          0x00000080                      // TSI channel 7 electrode out of range
      #define TSI_STATUS_ORNGF8          0x00000100                      // TSI channel 8 electrode out of range
      #define TSI_STATUS_ORNGF9          0x00000200                      // TSI channel 9 electrode out of range
      #define TSI_STATUS_ORNGF10         0x00000400                      // TSI channel 10 electrode out of range
      #define TSI_STATUS_ORNGF11         0x00000800                      // TSI channel 11 electrode out of range
      #define TSI_STATUS_ORNGF12         0x00001000                      // TSI channel 12 electrode out of range
      #define TSI_STATUS_ORNGF13         0x00002000                      // TSI channel 13 electrode out of range
      #define TSI_STATUS_ORNGF14         0x00004000                      // TSI channel 14 electrode out of range
      #define TSI_STATUS_ORNGF15         0x00008000                      // TSI channel 15 electrode out of range
      #define TSI_STATUS_ERROF0          0x00010000                      // TSI channel 0 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF1          0x00020000                      // TSI channel 1 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF2          0x00040000                      // TSI channel 2 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF3          0x00080000                      // TSI channel 3 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF4          0x00100000                      // TSI channel 4 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF5          0x00200000                      // TSI channel 5 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF6          0x00400000                      // TSI channel 6 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF7          0x00800000                      // TSI channel 7 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF8          0x01000000                      // TSI channel 8 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF9          0x02000000                      // TSI channel 9 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF10         0x04000000                      // TSI channel 10 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF11         0x08000000                      // TSI channel 11 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF12         0x10000000                      // TSI channel 12 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF13         0x20000000                      // TSI channel 13 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF14         0x40000000                      // TSI channel 14 electrode shorted to ground or supply
      #define TSI_STATUS_ERROF15         0x80000000                      // TSI channel 15 electrode shorted to ground or supply
    #define TSI0_CNTR1                   *(volatile unsigned long*)(TSI_BLOCK + 0x100) // Counter 1 Register (read-only)
    #define TSI0_CNTR3                   *(volatile unsigned long*)(TSI_BLOCK + 0x104) // Counter 3 Register (read-only)
    #define TSI0_CNTR5                   *(volatile unsigned long*)(TSI_BLOCK + 0x108) // Counter 5 Register (read-only)
    #define TSI0_CNTR7                   *(volatile unsigned long*)(TSI_BLOCK + 0x10c) // Counter 7 Register (read-only)
    #define TSI0_CNTR9                   *(volatile unsigned long*)(TSI_BLOCK + 0x110) // Counter 9 Register (read-only)
    #define TSI0_CNTR11                  *(volatile unsigned long*)(TSI_BLOCK + 0x114) // Counter 11 Register (read-only)
    #define TSI0_CNTR13                  *(volatile unsigned long*)(TSI_BLOCK + 0x118) // Counter 13 Register (read-only)
    #define TSI0_CNTR15                  *(volatile unsigned long*)(TSI_BLOCK + 0x11c) // Counter 15 Register (read-only)
    #define TSI0_THRESHLD0               *(unsigned long*)(TSI_BLOCK + 0x120) // Channel 0 Threshold Register - threshold registers should not be written when GENCS[SCNIP] is set
     #if KINETIS_MAX_SPEED == 100000000                                      // some parts have only a single threshold register
        #define TSI0_THRESHLD1           *(unsigned long*)(TSI_BLOCK + 0x124) // Channel 1 Threshold Register
        #define TSI0_THRESHLD2           *(unsigned long*)(TSI_BLOCK + 0x128) // Channel 2 Threshold Register
        #define TSI0_THRESHLD3           *(unsigned long*)(TSI_BLOCK + 0x12c) // Channel 3 Threshold Register
        #define TSI0_THRESHLD4           *(unsigned long*)(TSI_BLOCK + 0x130) // Channel 4 Threshold Register
        #define TSI0_THRESHLD5           *(unsigned long*)(TSI_BLOCK + 0x134) // Channel 5 Threshold Register
        #define TSI0_THRESHLD6           *(unsigned long*)(TSI_BLOCK + 0x138) // Channel 6 Threshold Register
        #define TSI0_THRESHLD7           *(unsigned long*)(TSI_BLOCK + 0x13c) // Channel 7 Threshold Register
        #define TSI0_THRESHLD8           *(unsigned long*)(TSI_BLOCK + 0x140) // Channel 8 Threshold Register
        #define TSI0_THRESHLD9           *(unsigned long*)(TSI_BLOCK + 0x144) // Channel 9 Threshold Register
        #define TSI0_THRESHLD10          *(unsigned long*)(TSI_BLOCK + 0x148) // Channel 10 Threshold Register
        #define TSI0_THRESHLD11          *(unsigned long*)(TSI_BLOCK + 0x14c) // Channel 11 Threshold Register
        #define TSI0_THRESHLD12          *(unsigned long*)(TSI_BLOCK + 0x150) // Channel 12 Threshold Register
        #define TSI0_THRESHLD13          *(unsigned long*)(TSI_BLOCK + 0x154) // Channel 13 Threshold Register
        #define TSI0_THRESHLD14          *(unsigned long*)(TSI_BLOCK + 0x158) // Channel 14 Threshold Register
        #define TSI0_THRESHLD15          *(unsigned long*)(TSI_BLOCK + 0x15c) // Channel 15 Threshold Register
     #endif
#endif


// System Integration Module
//
#if defined KINETIS_KE
    #define SIM_SRSID                        *(volatile unsigned long *)(SIM_BLOCK + 0x00)  // System Reset Status and ID Register 1 (read-only)
      #define SIM_SRSID_LVD                  0x00000002                  // reset due to low voltage detection
      #define SIM_SRSID_LOC                  0x00000004                  // reset caused by internal clock source module
      #define SIM_SRSID_WDOG                 0x00000020                  // reset caused by watchdog timeout
      #define SIM_SRSID_PIN                  0x00000040                  // reset caused by external reset pin
      #define SIM_SRSID_POR                  0x00000080                  // power on reset
      #define SIM_SRSID_LOCKUP               0x00000200                  // reset due to core lockup
      #define SIM_SRSID_SW                   0x00000400                  // reset due to software reset
      #define SIM_SRSID_MDMAP                0x00000800                  // reset caused by host debugger system setting the system reset request bit
      #define SIM_SRSID_SACKERR              0x00002000                  // stop mode acknowledge error reset
      #define SIM_SRSID_PINID                0x000f0000
      #define SIM_SRSID_REVID                0x00f00000
      #define SIM_SRSID_SUBFAMID             0x0f000000
      #define SIM_SRSID_FAMID                0xf0000000
    #if (defined KINETIS_KE04 && (SIZE_OF_FLASH > (8 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define SIM_SOPT0                    *(volatile unsigned long *)(SIM_BLOCK + 0x04) // System Options Register
          #define SIM_SOPT_NMIE              0x00000002                  // NMI pin enable (unaffected by reset and write-once only on each reset) - default power on enabled
          #define SIM_SOPT_RSTPE             0x00000004                  // Reset pin enabled (unaffected by reset and write-once only on each reset) - default power on enabled
          #define SIM_SOPT_SWDE              0x00000008                  // SWD pin enabled
          #define SIM_SOPT_ACTRG_0           0x00000000                  // ACMP trigger FTM2 selection - ACMP0 out
          #define SIM_SOPT_ACTRG_1           0x00000020                  // ACMP trigger FTM2 selection - ACMP1 out
          #define SIM_SOPT_RXDFE             0x00000300
          #define SIM_SOPT_RTCC              0x00000400
          #define SIM_SOPT_ACIC              0x00000800
          #define SIM_SOPT_RXDCE             0x00001000
          #define SIM_SOPT_FTMSYNC           0x00004000                  // (write-only)
          #define SIM_SOPT_TXDME             0x00008000
          #define SIM_SOPT_BUSREF            0x00070000
          #define SIM_SOPT_CLKOE             0x00080000
          #define SIM_SOPT_ADHWT_RTC         0x00000000
          #define SIM_SOPT_ADHWT_FTM0        0x00100000                  // ADC hardware trigger source - FTM0 as ADC hardware trigger
          #define SIM_SOPT_ADHWT_FTM2_INIT   0x00200000                  // ADC hardware trigger source - FTM2 init trigger with 8-bit programmable counter delay
          #define SIM_SOPT_ADHWT_FTM2_MATCH  0x00300000                  // ADC hardware trigger source - FTM2 match trigger with 8-bit programmable counter delay
          #define SIM_SOPT_ADHWT_PIT0        0x00400000                  // ADC hardware trigger source - PIT0 overflow as ADC hardware trigger
          #define SIM_SOPT_ADHWT_PIT1        0x00500000                  // ADC hardware trigger source - PIT1 overflow as ADC hardware trigger
          #define SIM_SOPT_ADHWT_ACMP0       0x00600000
          #define SIM_SOPT_ADHWT_ACMP1       0x00700000
          #define SIM_SOPT_DLYACT            0x00800000
          #define SIM_SOPT_DELAY             0xff000000
        #define SIM_SOPT1                    *(volatile unsigned long *)(SIM_BLOCK + 0x08) // System Options Register
          #define SIM_SOPT1_I2C04WEN         0x00000001                  // I2C0 4-wire mode (works only when SIM_PINSEL0[I2C0PS] is 0)
          #define SIM_SOPT1_I2C0OINV         0x00000002                  // I2C0 output invert (SIM_SOPT1_I2C04WEN must also be enabled)
          #define SIM_SOPT1_ACPWTS_1         0x00000000                  // PWT ACMP1_OUT is connected to PWRIN2
          #define SIM_SOPT1_ACPWTS_0         0x00000008                  // PWT ACMP0_OUT is connected to PWRIN2
          #define SIM_SOPT1_UARTPWTS_0       0x00000000                  // UART0 RX is connected to PWTIN3
          #define SIM_SOPT1_UARTPWTS_1       0x00000010                  // UART1 RX is connected to PWTIN3
          #define SIM_SOPT1_UARTPWTS_2       0x00000020                  // UART2 RX is connected to PWTIN3
        #define SIM_PINSEL0                  *(unsigned long *)(SIM_BLOCK + 0x0c) // Pin Selection Register 0
          #define SIM_PINSEL_IRQPS_PTA5      0x00000000                  // IRQ port pin mapped to PTA5
          #define SIM_PINSEL_IRQPS_PTI0      0x00000001                  // IRQ port pin mapped to PTI0
          #define SIM_PINSEL_IRQPS_PTI1      0x00000002                  // IRQ port pin mapped to PTI1
          #define SIM_PINSEL_IRQPS_PTI2      0x00000003                  // IRQ port pin mapped to PTI2
          #define SIM_PINSEL_IRQPS_PTI3      0x00000004                  // IRQ port pin mapped to PTI3
          #define SIM_PINSEL_IRQPS_PTI4      0x00000005                  // IRQ port pin mapped to PTI4
          #define SIM_PINSEL_IRQPS_PTI5      0x00000006                  // IRQ port pin mapped to PTI5
          #define SIM_PINSEL_IRQPS_PTI6      0x00000007                  // IRQ port pin mapped to PTI6
          #define SIM_PINSEL_FTM0CLKPS_0     0x00000000                  // selects TCLK0 for FTM0 module
          #define SIM_PINSEL_FTM0CLKPS_1     0x01000000                  // selects TCLK1 for FTM0 module
          #define SIM_PINSEL_FTM0CLKPS_2     0x02000000                  // selects TCLK2 for FTM0 module
          #define SIM_PINSEL_FTM1CLKPS_0     0x00000000                  // selects TCLK0 for FTM1 module
          #define SIM_PINSEL_FTM1CLKPS_1     0x04000000                  // selects TCLK1 for FTM1 module
          #define SIM_PINSEL_FTM1CLKPS_2     0x08000000                  // selects TCLK2 for FTM1 module
          #define SIM_PINSEL_FTM2CLKPS_0     0x00000000                  // selects TCLK0 for FTM2 module
          #define SIM_PINSEL_FTM2CLKPS_1     0x10000000                  // selects TCLK1 for FTM2 module
          #define SIM_PINSEL_FTM2CLKPS_2     0x20000000                  // selects TCLK2 for FTM2 module
          #define SIM_PINSEL_PWTCLKPS_0      0x00000000                  // selects TCLK0 for PWT module
          #define SIM_PINSEL_PWTCLKPS_1      0x40000000                  // selects TCLK1 for PWT module
          #define SIM_PINSEL_PWTCLKPS_2      0x80000000                  // selects TCLK1 for PWT module
    #else
        #define SIM_SOPT0                    *(volatile unsigned long *)(SIM_BLOCK + 0x04) // System Options Register
          #define SIM_SOPT_NMIE              0x00000002                  // NMI pin enable (unaffected by reset and write-once only on each reset) - default power on enabled
          #define SIM_SOPT_RSTPE             0x00000004                  // Reset pin enabled (unaffected by reset and write-once only on each reset) - default power on enabled
          #define SIM_SOPT_SWDE              0x00000008                  // SWD pin enabled
          #define SIM_SOPT_ADHWT_RTC         0x00000000                  // ADC hardware trigger source - RTC overflow as ADC hardware trigger
          #define SIM_SOPT_ADHWT_PIT0        0x00000100                  // ADC hardware trigger source - PIT0 overflow as ADC hardware trigger
          #define SIM_SOPT_ADHWT_FTM2_INIT   0x00000200                  // ADC hardware trigger source - FTM2 init trigger with 8-bit programmable delay
          #define SIM_SOPT_ADHWT_FTM2_MATCH  0x00000300                  // ADC hardware trigger source - FTM2 match trigger with 8-bit programmable delay
          #define SIM_SOPT_RTCC              0x00000400
          #define SIM_SOPT_ACIC              0x00000800
          #define SIM_SOPT_RXDCE             0x00001000
          #define SIM_SOPT_RXDFE             0x00002000
          #define SIM_SOPT_FTMSYNC           0x00004000                  // (write-only)
          #define SIM_SOPT_TXDME             0x00008000
          #define SIM_SOPT_BUSREF            0x00070000
          #define SIM_SOPT_CLKOE             0x00080000
          #define SIM_SOPT_DLYACT            0x00800000
          #define SIM_SOPT_DELAY             0xff000000
        #define SIM_PINSEL0                  *(unsigned long *)(SIM_BLOCK + 0x08) // Pin Selection Register
          #define SIM_PINSEL_FTM2PS0         0x00001000                  // FTM2[0] mapped to PTH0 rather than PTC0
          #define SIM_PINSEL_FTM2PS1         0x00002000                  // FTM2[1] mapped to PTH1 rather than PTC1
          #define SIM_PINSEL_FTM2PS2         0x00004000                  // FTM2[2] mapped to PTD0 rather than PTC2
          #define SIM_PINSEL_FTM2PS3         0x00008000                  // FTM2[3] mapped to PTD1 rather than PTC3
    #endif
      #define SIM_PINSEL_RCPS                0x00000010                  // RTCO mapped to PTC5 rather than PTC4
      #define SIM_PINSEL_I2C0PS              0x00000020                  // I2C0 mapped to PTB7 and PTB6 rather than PTA3 and PTA2
      #define SIM_PINSEL_SPI0PS              0x00000040                  // SPI0 mapped to PTE0, PTE1, PTE2 and PTE3 rather than PTB2, PTB3, PTB4 and PTB5
      #define SIM_PINSEL_UART0PS             0x00000080                  // UART0 mapped to PTA2 and PTA3 rather than PTB0 and PTB1
      #define SIM_PINSEL_FTM0PS0             0x00000100                  // FTM0[0] mapped to PTB2 rather than PTA0
      #define SIM_PINSEL_FTM0PS1             0x00000200                  // FTM0[1] mapped to PTB3 rather than PTA1
      #define SIM_PINSEL_FTM1PS0             0x00000400                  // FTM1[0] mapped to PTH2 rather than PTC4
      #define SIM_PINSEL_FTM1PS1             0x00000800                  // FTM1[1] mapped to PTE7 rather than PTC5
    #if (defined KINETIS_KE04 && (SIZE_OF_FLASH > (8 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define SIM_PINSEL1                  *(volatile unsigned long *)(SIM_BLOCK + 0x10)  // Pin Selection Register 1
          #define SIM_PINSEL1_FTM2PS0_PTC0   0x00000000                  // FTM2[0] mapped to PTC0
          #define SIM_PINSEL1_FTM2PS0_PTH0   0x00000001                  // FTM2[0] mapped to PTH0
          #define SIM_PINSEL1_FTM2PS0_PTF0   0x00000002                  // FTM2[0] mapped to PTF0
          #define SIM_PINSEL1_FTM2PS1_PTC1   0x00000000                  // FTM2[1] mapped to PTC1
          #define SIM_PINSEL1_FTM2PS1_PTH1   0x00000004                  // FTM2[1] mapped to PTH1
          #define SIM_PINSEL1_FTM2PS1_PTF1   0x00000008                  // FTM2[1] mapped to PTF1
          #define SIM_PINSEL1_FTM2PS2_PTC2   0x00000000                  // FTM2[2] mapped to PTC2
          #define SIM_PINSEL1_FTM2PS2_PTD0   0x00000010                  // FTM2[2] mapped to PTD0
          #define SIM_PINSEL1_FTM2PS2_PTG4   0x00000020                  // FTM2[2] mapped to PTG4
          #define SIM_PINSEL1_FTM2PS3_PTC3   0x00000000                  // FTM2[3] mapped to PTC3
          #define SIM_PINSEL1_FTM2PS3_PTD1   0x00000040                  // FTM2[3] mapped to PTD1
          #define SIM_PINSEL1_FTM2PS3_PTG5   0x00000080                  // FTM2[3] mapped to PTG5
          #define SIM_PINSEL1_FTM2PS4        0x00000100                  // FTM2[4] mapped to PTG6 rather than PTB4
          #define SIM_PINSEL1_FTM2PS5        0x00000200                  // FTM2[5] mapped to PTG7 rather than PTB5
          #define SIM_PINSEL1_I2C1PS         0x00000400                  // I2C1 mapped to PTH4 and PTH3 rather than PTE1 and PTE0
          #define SIM_PINSEL1_SPI1PS         0x00000800                  // SPI1 mapped to PTG4, PTG5, PTG6 and PTG7 rather than PTD0, PTD1, PTD2 and PTD3
          #define SIM_PINSEL1_UART1PS        0x00001000                  // UART1_TX on PTF3 rather than PTC7, UART1_RX on PTF2 rather than PTC6
          #define SIM_PINSEL1_UART2PS        0x00002000                  // UART2_TX on PTI1 rather than PTD7, UART2_RX on PTI0 rather than PTD6
          #define SIM_PINSEL1_PWTIN0PS       0x00004000                  // PWTIN0 on PTE2 rather than PTD5
          #define SIM_PINSEL1_PWTIN1PS       0x00008000                  // PWTIN1 on PTH7 rather than PTB0
          #define SIM_PINSEL1_MSCANPS        0x00010000                  // CAN_TX on PTE7 rather than PTC7, CAN_RX on PTH2 rather than PTC6
        #define SIM_SCGC                     *(unsigned long *)(SIM_BLOCK + 0x14) // System Clock Gating Control Register
    #else
        #define SIM_SCGC                     *(unsigned long *)(SIM_BLOCK + 0x0c) // System Clock Gating Control Register
    #endif
      #define SIM_SCGC_RTC                   0x00000001
      #define SIM_SCGC_PIT                   0x00000002
      #define SIM_SCGC_PWT                   0x00000010
      #define SIM_SCGC_FM0                   0x00000020
      #define SIM_SCGC_FM1                   0x00000040
      #define SIM_SCGC_FM2                   0x00000080
      #define SIM_SCGC_CRC                   0x00000400
      #define SIM_SCGC_FLASH                 0x00001000
      #define SIM_SCGC_SWD                   0x00002000
      #define SIM_SCGC_MSCAN                 0x00008000
      #define SIM_SCGC_I2C_0                 0x00010000
      #define SIM_SCGC_I2C_1                 0x00020000
      #define SIM_SCGC_SPI0                  0x00040000
      #define SIM_SCGC_SPI1                  0x00080000
      #define SIM_SCGC_UART0                 0x00100000
      #define SIM_SCGC_UART1                 0x00200000
      #define SIM_SCGC_UART2                 0x00400000
      #define SIM_SCGC_KBI0                  0x01000000
      #define SIM_SCGC_KBI1                  0x02000000
      #define SIM_SCGC_IRQ                   0x08000000
      #define SIM_SCGC_ADC                   0x20000000
      #define SIM_SCGC_ACMP0                 0x40000000
      #define SIM_SCGC_ACMP1                 0x80000000

      #define SIM_SCGC4_UART0                SIM_SCGC_UART0              // for compatibility
      #define SIM_SCGC4_UART1                SIM_SCGC_UART1
      #define SIM_SCGC4_UART2                SIM_SCGC_UART2
      #if defined KINETIS_KE02
          #define SIM_SCGC4_I2C0             SIM_SCGC_I2C_1
      #else
          #define SIM_SCGC4_I2C0             SIM_SCGC_I2C_0
          #define SIM_SCGC4_I2C1             SIM_SCGC_I2C_1
      #endif
      #define SIM_SCGC6_PIT                  SIM_SCGC_PIT
      #define SIM_SCGC6_FTM0                 SIM_SCGC_FM0
      #define SIM_SCGC6_FTM1                 SIM_SCGC_FM1
      #define SIM_SCGC3_FTM2                 SIM_SCGC_FM2
      #define SIM_SCGC6_ADC0                 SIM_SCGC_ADC
      #define SIM_SCGC4_SPI0                 SIM_SCGC_SPI0
      #define SIM_SCGC4_SPI1                 SIM_SCGC_SPI1
      #define SIM_SCGC6_RTC                  SIM_SCGC_RTC

    #if (defined KINETIS_KE04 && (SIZE_OF_FLASH > (8 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define SIM_UUIDL                    *(volatile unsigned long *)(SIM_BLOCK + 0x18) // Universally Unique Identifier Low Register (read-only)
        #define SIM_UUIDML                   *(volatile unsigned long *)(SIM_BLOCK + 0x1c) // Universally Unique Identifier Middle Low Register (read-only)
        #define SIM_UUIDMH                   *(volatile unsigned long *)(SIM_BLOCK + 0x20) // Universally Unique Identifier Middle High Register (read-only)
        #define SIM_CLKDIV                   *(volatile unsigned long *)(SIM_BLOCK + 0x24) // Clock Divider Register
          #define SIM_CLKDIV_OUTDIV3_1       0x00000000                  // FTM and PWT clocks equal to ICSOUTCLK
          #define SIM_CLKDIV_OUTDIV3_2       0x00100000                  // FTM and PWT clocks equal to ICSOUTCLK/2
          #define SIM_CLKDIV_OUTDIV2_1       0x00000000                  // bus/flash equal to system clock
          #define SIM_CLKDIV_OUTDIV2_2       0x01000000                  // bus/flash equal to system clock/2
          #define SIM_CLKDIV_OUTDIV1_1       0x00000000                  // core/system clock is equal to ICSOUTCLK
          #define SIM_CLKDIV_OUTDIV1_2       0x10000000                  // core/system clock is equal to ICSOUTCLK/2
          #define SIM_CLKDIV_OUTDIV1_3       0x20000000                  // core/system clock is equal to ICSOUTCLK/3
          #define SIM_CLKDIV_OUTDIV1_4       0x30000000                  // core/system clock is equal to ICSOUTCLK/4
    #else
        #define SIM_UUIDL                    *(volatile unsigned long *)(SIM_BLOCK + 0x10) // Universally Unique Identifier Low Register (read-only)
          #if defined KINETIS_KEA8
			#define SIM_UUIDML               *(volatile unsigned long *)(SIM_BLOCK + 0x14) // Universally Unique Identifier Middle Low Register (read-only)
			#define SIM_UUIDMH               *(volatile unsigned long *)(SIM_BLOCK + 0x18) // Universally Unique Identifier Middle High Register (read-only)
          #else
			#define SIM_UUIDH                *(volatile unsigned long *)(SIM_BLOCK + 0x14) // Universally Unique Identifier High Register (read-only)
			#define SIM_BUSDIV               *(volatile unsigned long *)(SIM_BLOCK + 0x18) // Bus Clock Divider Register
			  #define SIM_BUSDIVBUSDIV       0x00000001                  // bus clock is ICSOUTCLK divided by 2 (value not affected by warm reset)
          #endif
        #if (defined KINETIS_KE04 && (SIZE_OF_FLASH <= (8 * 1024))) || defined KINETIS_KEA
            #define SIM_CLKDIV                   *(volatile unsigned long *)(SIM_BLOCK + 0x1c) // Clock Divider Register
              #define SIM_CLKDIV_OUTDIV3_1   0x00000000                  // FTM and PWT clocks equal to ICSOUTCLK
              #define SIM_CLKDIV_OUTDIV3_2   0x00100000                  // FTM and PWT clocks equal to ICSOUTCLK/2
              #define SIM_CLKDIV_OUTDIV2_1   0x00000000                  // bus/flash equal to system clock
              #define SIM_CLKDIV_OUTDIV2_2   0x01000000                  // bus/flash equal to system clock/2
              #define SIM_CLKDIV_OUTDIV1_1   0x00000000                  // core/system clock is equal to ICSOUTCLK
              #define SIM_CLKDIV_OUTDIV1_2   0x10000000                  // core/system clock is equal to ICSOUTCLK/2
              #define SIM_CLKDIV_OUTDIV1_3   0x20000000                  // core/system clock is equal to ICSOUTCLK/3
              #define SIM_CLKDIV_OUTDIV1_4   0x30000000                  // core/system clock is equal to ICSOUTCLK/4
        #endif
    #endif
#else
    #if !defined KINETIS_KL02
        #define SIM_SOPT1                        *(unsigned long *)(SIM_BLOCK + 0x0000) // System Options Register 1 - this register is only reset at power cycles
      #if defined KINETIS_K22
          #define SIM_SOPT1_OSC32KOUT_MASK       0x00030000
          #define SIM_SOPT1_OSC32KOUT_PTE0       0x00010000
          #define SIM_SOPT1_OSC32KOUT_PTE26      0x00020000
      #endif
          #define SIM_SOPT1_OSC32KSEL_MASK       0x000c0000
          #define SIM_SOPT1_OSC32KSEL_SYS_OSC    0x00000000              // OSC32KCLK
        #if defined KINETIS_KL
          #define SIM_SOPT1_OSC32KSEL_RTC_CLKIN  0x00080000              // RTC_CLKIN input
        #else
          #define SIM_SOPT1_OSC32KSEL_32k        0x00080000              // 32kHz oscillator
        #endif
          #define SIM_SOPT1_OSC32KSEL_LPO_1kHz   0x000c0000              // LPO 1kHz clock
      #if !defined KINETIS_KL82
          #define SIM_SOPT1_USBVSTBY             0x20000000
          #define SIM_SOPT1_USBSTBY              0x40000000
          #define SIM_SOPT1_USBREGEN             0x80000000
      #endif
    #endif
    #if defined KINETIS_K_FPU || (defined KINETIS_KL && !defined KINETIS_KL82) // {42}]
        #define SIM_SOPT1CGF                 *(volatile unsigned long *)(SIM_BLOCK + 0x0004) // System Options 1 Configuration Register
            #define SIM_SOPT1CFG_URWE        0x01000000                  // USB voltage regulator enable write enable (self-clearing after a write to SIM_SOPT1_USBREGEN)
            #define SIM_SOPT1CFG_UVSWE       0x02000000                  // USB voltage regulator VLP standby enable write enable (self-clearing after a write to SIM_SOPT1_USBSTBY)
            #define SIM_SOPT1CFG_USSWE       0x04000000                  // USB voltage regulator stop standby enable write enable (self-clearing after a write to SIM_SOPT1_USBVSTBY)
    #endif
    #if defined KINETIS_WITH_USBPHY
        #define SIM_USBPHYCTL                *(volatile unsigned long *)(SIM_BLOCK + 0x0008) // USB PHY control register
            #define SIM_USBPHYCTL_USBVREGSEL 0x00000100                  // select VREG_IN1 instead of VREG_IN0 if both regulator inputs are powered
            #define SIM_USBPHYCTL_USBVREGPD  0x00000200                  // enable pulldown on the output of the USB regulator
            #define SIM_USBPHYCTL_USBVOUTTRG_2_733V 0x00000000           // USB 3V regulator output voltage set by IFR values
            #define SIM_USBPHYCTL_USBVOUTTRG_3_020V 0x00100000
            #define SIM_USBPHYCTL_USBVOUTTRG_3_074V 0x00200000
            #define SIM_USBPHYCTL_USBVOUTTRG_3_130V 0x00300000
            #define SIM_USBPHYCTL_USBVOUTTRG_3_188V 0x00400000
            #define SIM_USBPHYCTL_USBVOUTTRG_3_248V 0x00500000
            #define SIM_USBPHYCTL_USBVOUTTRG_3_310V 0x00600000           // default
          //#define SIM_USBPHYCTL_USBVOUTTRG_3_662V 0x00700000           // for Freescale use only - not for customer use
            #define SIM_USBPHYCTL_USBDISILIM 0x00800000                  // disable current limitior for the USB voltage regulator
    #endif
    #define SIM_SOPT2                        *(unsigned long *)(SIM_BLOCK + 0x1004) // System Options Register 2
      #if defined KINETIS_KL
        #define SIM_SOPT2_RTCCLKOUT_1Hz      0x00000000                  // RTC 1Hz clock is output on RTC_CLKOUT pin
        #if defined KINETIS_HAS_IRC48M                                   // {58}
            #define SIM_SOPT2_RTCCLKOUTSEL   0x00000010                  // select 32.768kHz clock output on RTC_CLKOUT pin rather than 1Hz clock
            #define SIM_SOPT2_CLKOUTSEL_FLEXBUS   0x00000000             // select FlexBus clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_FLASH     0x00000040             // select Flash clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_BUS       SIM_SOPT2_CLKOUTSEL_FLASH // for compatibility
            #define SIM_SOPT2_CLKOUTSEL_LPO       0x00000060             // select 1kHz LPO clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_MCGIRCLK  0x00000080             // select MCGIRCLK clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_LIRC_CLK  0x00000080             // select LIRC_CLK clock as output on CLKOUT (equivalent to MCGIRCLK for certain parts)
            #define SIM_SOPT2_CLKOUTSEL_RTC       0x000000a0             // select RTC 32.768kHz clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_OSCERCLK0 0x000000c0             // select external clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_IRC48M    0x000000e0             // select 48MHz IRC clock as output on CLKOUT
          #if defined KINETIS_KL82
            #define SIM_SOPT2_PLLFLLSEL_FLL       0x00000000             // select peripheral clocking option source - MCGFLLCLK
            #define SIM_SOPT2_PLLFLLSEL_PLL       0x00010000             // select peripheral clocking option source - MCGPLLCLK
            #define SIM_SOPT2_PLLFLLSEL_IRC48M    0x00030000             // select peripheral clocking option source - IRC48 MHz clock
            #define SIM_SOPT2_PLLFLLSEL      SIM_SOPT2_PLLFLLSEL_PLL     // for compatibility
          #else
            #define SIM_SOPT2_PLLFLLSEL_IRC48M    0x00000000             // for compatibility
            #define SIM_SOPT2_PLLFLLSEL           0x00000000             // for compatibility
          #endif
        #else
            #define SIM_SOPT2_RTCCLKOUT_OSC      0x00000010              // OSCERCLK clock is output on RTC_CLKOUT pin
            #define SIM_SOPT2_CLKOUTSEL_BUS      0x00000040              // Bus clock is output on the CLKOUT pin
            #define SIM_SOPT2_CLKOUTSEL_FLASH    SIM_SOPT2_CLKOUTSEL_BUS
            #define SIM_SOPT2_CLKOUTSEL_LPO      0x00000060              // LPO (1kHz) is output on the CLKOUT pin
            #define SIM_SOPT2_CLKOUTSEL_MCGIRCLK 0x00000080              // MCGIRCLK is output on the CLKOUT pin
            #define SIM_SOPT2_CLKOUTSEL_OSCERCLK0 0x000000c0             // OSCERCLK is output on the CLKOUT pin
            #define SIM_SOPT2_PLLFLLSEL          0x00010000              // select PLL source (MCGPLLCLK/2 rather than MCGFLLCLK)
        #endif
        #define SIM_SOPT2_CLKOUTSEL_MASK     0x000000f0
        #define SIM_SOPT2_USBSRC             0x00040000                  // usb clock source is MCGPLLCLK/2 or MCGFLLCLK rather than USB_CLKIN
        #define SIM_SOPT2_TPMSRC_DISABLED    0x00000000                  // TPM clock source disabled
        #define SIM_SOPT2_TPMSRC_MCG         0x01000000                  // TPM clock MCGFLL or MCGPLLCLK/2
        #define SIM_SOPT2_TPMSRC_OSCERCLK    0x02000000                  // TPM clock source OSCERCLK
        #define SIM_SOPT2_TPMSRC_MCGIRCLK    0x03000000                  // TPM clock source MCGIRCLK
        #define SIM_SOPT2_UART0SRC_DISABLED  0x00000000                  // UART0 clock source disabled
        #define SIM_SOPT2_UART0SRC_MCG       0x04000000                  // UART0 clock MCGFLL or MCGPLLCLK/2
        #define SIM_SOPT2_UART0SRC_IRC48M    0x04000000                  // UART0 clock IRC48M (for KL03 and KL43)
        #define SIM_SOPT2_UART0SRC_OSCERCLK  0x08000000                  // UART0 clock source OSCERCLK
        #define SIM_SOPT2_UART0SRC_MCGIRCLK  0x0c000000                  // UART0 clock source MCGIRCLK
        #define SIM_SOPT2_UART1SRC_DISABLED  0x00000000                  // UART1 clock source disabled
        #define SIM_SOPT2_UART1SRC_MCG       0x10000000                  // UART1 clock MCGFLL or MCGPLLCLK/2
        #define SIM_SOPT2_UART1SRC_IRC48M    0x10000000                  // UART1 clock IRC48M (for KL03 and KL43)
        #define SIM_SOPT2_UART1SRC_OSCERCLK  0x20000000                  // UART1 clock source OSCERCLK
        #define SIM_SOPT2_UART1SRC_MCGIRCLK  0x30000000                  // UART1 clock source MCGIRCLK
      #else
        #define SIM_SOPT2_CLKOUTSEL_MASK     0x000000e0
        #if defined KINETIS_WITH_USBPHY
            #define SIM_SOPT2_USBSLSRC_RTC   0x00000001                  // USB slow clock source RTC 32.768kHz instead of MCGIRCLK
            #define SIM_SOPT2_USBREGEN       0x00000002                  // enable USB PHY PLL regulator
        #else
            #define SIM_SOPT2_USBHSSRC_BUS_CLK   0x00000000              // USB HS clock source select from bus clock {25}
            #define SIM_SOPT2_USBHSSRC_MCGPLL0   0x00000004              // USB HS clock source select from MSCGPLL0
            #define SIM_SOPT2_USBHSSRC_MCGPLL1   0x00000008              // USB HS clock source select from MSCGPLL1
            #define SIM_SOPT2_USBHSSRC_OSC0ERCLK 0x0000000c              // USB HS clock source select from OSC0ERCLK
        #endif
        #if defined KINETIS_HAS_IRC48M || defined KINETIS_K22            // {58}
            #define SIM_SOPT2_RTCCLKOUTSEL   0x00000010                  // select 32.768kHz clock output on RTC_CLKOUT pin rather than 1Hz clock
            #define SIM_SOPT2_CLKOUTSEL_FLEXBUS   0x00000000             // select FlexBus clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_FLASH     0x00000040             // select Flash clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_LPO       0x00000060             // select 1kHz LPO clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_MCGIRCLK  0x00000080             // select MCGIRCLK clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_RTC       0x000000a0             // select RTC 32.768kHz clock as output on CLKOUT
            #define SIM_SOPT2_CLKOUTSEL_OSCERCLK0 0x000000c0             // select oscillator clock as output on CLKOUT
            #if defined KINETIS_HAS_IRC48M
                #define SIM_SOPT2_CLKOUTSEL_IRC48M  0x000000e0           // select 48MHz IRC clock as output on CLKOUT
            #endif
            #define SIM_SOPT2_FBSL_NONE      0x00000000                  // FlexBus security level - all off-chip accesses (instruction and data) are disallowed
            #define SIM_SOPT2_FBSL_DATA      0x00000200                  // FlexBus security level - off-chip accesses instruction access disallowed/data access allowed
            #define SIM_SOPT2_FBSL_ALL       0x00000300                  // FlexBus security level - all off-chip accesses (instruction and dats) are allowed
            #define SIM_SOPT2_PTD7PAD        0x00000800                  // select double pad drive strength for PTD7
        #endif
        #define SIM_SOPT2_TRACECLKSEL        0x00001000
        #if defined KINETIS_HAS_IRC48M                                   // {58}
            #define SIM_SOPT2_PLLFLLSEL_FLL    0x00000000                // select peripheral clocking option source - MCGFLLCLK
            #define SIM_SOPT2_PLLFLLSEL_PLL    0x00010000                // select peripheral clocking option source - MCGPLLCLK
            #if defined KINETIS_K66
                #define SIM_SOPT2_PLLFLLSEL_USB1_PFD_CLK 0x00020000      // select peripheral clocking option source - USB1 PDF
            #endif
            #define SIM_SOPT2_PLLFLLSEL_IRC48M 0x00030000                // select peripheral clocking option source - IRC48 MHz clock
            #define SIM_SOPT2_PLLFLLSEL      SIM_SOPT2_PLLFLLSEL_PLL     // for compatibility
        #else
            #define SIM_SOPT2_PLLFLLSEL      0x00010000                  // select PLL source (MCGPLLCLK rather than MCGFLLCLK)
        #endif
            #define SIM_SOPT2_USBSRC         0x00040000                  // usb clock source is MCGPLLCLK/MCGFLLCLK (or IRC48M) clock divided by the USB fractional divider rather than USB_CLKIN
        #if defined KINETIS_K80
            #define SIM_SOPT2_FLEXIOSRC      0x00c00000                  // 
            #define SIM_SOPT2_TPMSRC         0x03000000                  //
            #define SIM_SOPT2_LPUARTSRC_SEL  0x04000000                  // LPUARTs clock source - source selected by PLLFLLSEL
            #define SIM_SOPT2_LPUARTSRC_OSC  0x08000000                  // LPUARTs clock source - OSCERCLK
            #define SIM_SOPT2_LPUARTSRC_MGC  0x0c000000                  // LPUARTs clock source - MCGIRCLK
            #define SIM_SOPT2_SDHCSRC_CORE   0x00000000                  // SDHC clock source - core/system clock
            #define SIM_SOPT2_SDHCSRC_SEL    0x10000000                  // SDHC clock source - source selected by PLLFLLSEL
            #define SIM_SOPT2_SDHCSRC_OSC    0x20000000                  // SDHC clock source - OSCERCLK
            #define SIM_SOPT2_SDHCSRC_MCG    0x30000000                  // SDHC clock source - MCGIRCLK
            #define SIM_SOPT2_EMVSIMSRC_SEL  0x40000000                  // EMVSIM module clock source - source selected by PLLFLLSEL
            #define SIM_SOPT2_EMVSIMSRC_OSC  0x80000000                  // EMVSIM module clock source - OSCERCLK
            #define SIM_SOPT2_EMVSIMSRC_MCG  0xc0000000                  // EMVSIM module clock source - MCGIRCLK
        #else
            #if defined KINETIS_HAS_IRC48M                               // {58}
                #define SIM_SOPT2_RMIISRC_EXTAL      0x00000000          // select Ethernet RMII clock source from EXTAL clock
                #define SIM_SOPT2_RMIISRC_EXT_BYPASS 0x00080000          // select Ethernet RMII clock source from external bypass clock (ENET_1588_CLKIN)
                #define SIM_SOPT2_TIMESRC_CORE       0x00000000
                #define SIM_SOPT2_TIMESRC_MCG_IRC48M 0x00100000
                #define SIM_SOPT2_TIMESRC_OSCERCLK   0x00200000
                #define SIM_SOPT2_TIMESRC_EXT_BYPASS 0x00300000
                #if defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
                    #define SIM_SOPT2_TPMSRC_DISABLED 0x00000000         // TPM clock disabled
                    #define SIM_SOPT2_TPMSRC_ALT      0x01000000         // clock for TPM selected from SOPT2[PLLFLLSEL]
                    #define SIM_SOPT2_TPMSRC_OSCERCLK 0x02000000         // TPM clock from external/oscillator clock
                    #define SIM_SOPT2_TPMSRC_MCGIRCLK 0x03000000         // TPM clock from MCGIRCLK
                #endif
                #if LPUARTS_AVAILABLE > 0
                    #define SIM_SOPT2_UART0SRC_MCG       0x04000000      // LPUART0 clock MCGFLL or MCGPLLCLK/2
                    #define SIM_SOPT2_UART0SRC_IRC48M    0x04000000      // LPUART0 clock IRC48M (for KL03 and KL43)
                    #define SIM_SOPT2_UART0SRC_OSCERCLK  0x08000000      // LPUART0 clock source OSCERCLK
                    #define SIM_SOPT2_UART0SRC_MCGIRCLK  0x0c000000      // LPUART0 clock source MCGIRCLK
                #endif
                #define SIM_SOPT2_SDHCSRC_CORE       0x00000000
                #define SIM_SOPT2_SDHCSRC_MCG_IRC48M 0x10000000
                #define SIM_SOPT2_SDHCSRC_OSCERCLK   0x20000000
                #define SIM_SOPT2_SDHCSRC_EXT_BYPASS 0x30000000
            #elif defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000)
                #define SIM_SOPT2_USBFSRC_MCGPLLCLK  0x00000000          // USB FS clock source select from MSCGPLLCLK/MCGFLLCLK
                #define SIM_SOPT2_USBFSRC_MCGPLL0    0x00400000          // USB FS clock source select from MSCGPLL0CLK
                #define SIM_SOPT2_USBFSRC_MCGPLL1    0x00800000          // USB FS clock source select from MSCGPLL1CLK
                #define SIM_SOPT2_USBFSRC_OSC0ERCLK  0x00c00000          // USB FS clock source select from OSC0ERCLK
                #define SIM_SOPT2_NFCSRC_BUS_CLK     0x00000000          // NFC flash clock source select from bus clock
                #define SIM_SOPT2_NFCSRC_MCGPLL0CLK  0x40000000          // NFC flash clock source select from MCGPLL0CLK
                #define SIM_SOPT2_NFCSRC_MCGPLL1CLK  0x80000000          // NFC flash clock source select from MCGPLL1CLK
                #define SIM_SOPT2_NFCSRC_OSC0ERCLK   0xc0000000          // NFC flash clock source select from OSC0ERCLK
            #endif
        #endif
      #endif
      #if !defined KINETIS_KL82
    #define SIM_SOPT4                        *(unsigned long*)(SIM_BLOCK + 0x100c) // System Options Register 4
        #define SIM_SOPT4_FTM0FLT0           0x00000001                  // FlexTimer 0 fault 0 select - CMP0 OUT (rather than FTM0_FLT0) drives FTM 0 fault 0
        #define SIM_SOPT4_FTM0FLT1           0x00000002                  // FlexTimer 0 fault 1 select - CMP1 OUT (rather than FTM0_FLT1) drives FTM 0 fault 1
        #define SIM_SOPT4_FTM0FLT2           0x00000004                  // FlexTimer 0 fault 2 select - CMP2 OUT (rather than FTM0_FLT2) drives FTM 0 fault 2
        #define SIM_SOPT4_FTM0FLT3           0x00000008                  // FlexTimer 0 fault 3 select - CMP0 OUT (rather than FTM0_FLT3) drives FTM 0 fault 3
        #define SIM_SOPT4_FTM1FLT0           0x00000010                  // FlexTimer 1 fault 0 select - CMP0 OUT (rather than FTM1_FLT0) drives FTM 1 fault 0
        #define SIM_SOPT4_FTM2FLT0           0x00000100                  // FlexTimer 2 fault 0 select - CMP0 OUT (rather than FTM2_FLT0) drives FTM 2 fault 0
        #define SIM_SOPT4_FTM3FLT0           0x00001000                  // FlexTimer 3 fault 0 select - CMP0 OUT (rather than FTM3_FLT0) drives FTM 2 fault 0
        #define SIM_SOPT4_FTM1CH0SRC_CH0     0x00000000                  // FlexTimer 1 cannel 0 input capture source - FTM1_CH0 pin
        #define SIM_SOPT4_FTM1CH0SRC_CMP0    0x00040000                  // FlexTimer 2 cannel 0 input capture source - CMP0 output
        #define SIM_SOPT4_FTM1CH0SRC_CMP1    0x00080000                  // FlexTimer 2 cannel 0 input capture source - CMP1 output
        #define SIM_SOPT4_FTM1CH0SRC_USB_SOF 0x000c0000                  // FlexTimer 2 cannel 0 input capture source - USB SOF trigger
        #define SIM_SOPT4_FTM2CH0SRC_CH0     0x00000000                  // FlexTimer 2 cannel 0 input capture source - FTM2_CH0 pin
        #define SIM_SOPT4_FTM2CH0SRC_CMP0    0x00100000                  // FlexTimer 2 cannel 0 input capture source - CMP0 output
        #define SIM_SOPT4_FTM2CH0SRC_CMP1    0x00200000                  // FlexTimer 2 cannel 0 input capture source - CMP0 output
        #define SIM_SOPT4_FTM0CLKSEL         0x01000000                  // FTM0 external clock driven by FTM CLKIN1 pin rather than CLKIN0 pin
        #define SIM_SOPT4_FTM1CLKSEL         0x02000000                  // FTM1 external clock driven by FTM CLKIN1 pin rather than CLKIN0 pin
        #define SIM_SOPT4_FTM2CLKSEL         0x04000000                  // FTM2 external clock driven by FTM CLKIN1 pin rather than CLKIN0 pin
        #define SIM_SOPT4_FTM3CLKSEL         0x08000000                  // FTM3 external clock driven by FTM CLKIN1 pin rather than CLKIN0 pin
        #define SIM_SOPT4_FTM0TRG0SRC        0x10000000                  // FTM1 channel match trigger drives FTM0 hardware trigger 0 (rather than CMP0 OUT)
        #define SIM_SOPT4_FTM0TRG1SRC        0x20000000                  // FTM2 channel match trigger drives FTM0 hardware trigger 1 (rather than PDB output trigger 1)
        #define SIM_SOPT4_FTM3TRG0SRC        0x40000000                  // FTM1 channel match trigger drives FTM3 hardware trigger 0 (rather than CMP3 OUT)
        #define SIM_SOPT4_FTM3TRG1SRC        0x80000000                  // FTM2 channel match trigger drives FTM3 hardware trigger 1 (rather than PDB output trigger 3)
      #endif
    #define SIM_SOPT5                        *(unsigned long*)(SIM_BLOCK + 0x1010) // System Options Register 5
    #if !defined KINETIS_KL
        #define SIM_SOPT6                    *(unsigned long*)(SIM_BLOCK + 0x1014) // System Options Register 6
    #endif
    #define SIM_SOPT7                        *(unsigned long*)(SIM_BLOCK + 0x1018) // System Options Register 7
      #define SIM_SOPT7_ADC0TRGSEL_EXTRG_IN  0x00000000                  // ADC0 trigger source for alternative is EXTRG_IN
      #define SIM_SOPT7_ADC0TRGSEL_CMP0      0x00000001                  // ADC0 trigger source for alternative is CMP0 output
      #define SIM_SOPT7_ADC0TRGSEL_CMP1      0x00000002                  // ADC0 trigger source for alternative is CMP1 output
      #define SIM_SOPT7_ADC0TRGSEL_CMP2      0x00000003                  // ADC0 trigger source for alternative is CMP2 output
      #define SIM_SOPT7_ADC0TRGSEL_PIT0      0x00000004                  // ADC0 trigger source for alternative is PIT0
      #define SIM_SOPT7_ADC0TRGSEL_PIT1      0x00000005                  // ADC0 trigger source for alternative is PIT1
      #define SIM_SOPT7_ADC0TRGSEL_PIT2      0x00000006                  // ADC0 trigger source for alternative is PIT2
      #define SIM_SOPT7_ADC0TRGSEL_PIT3      0x00000007                  // ADC0 trigger source for alternative is PIT3
      #define SIM_SOPT7_ADC0TRGSEL_TPM0      0x00000008                  // ADC0 trigger source for alternative is TPM0 overflow
      #define SIM_SOPT7_ADC0TRGSEL_TPM1      0x00000009                  // ADC0 trigger source for alternative is TPM1 overflow
      #define SIM_SOPT7_ADC0TRGSEL_TPM2      0x0000000a                  // ADC0 trigger source for alternative is TPM2 overflow
      #define SIM_SOPT7_ADC0TRGSEL_TPM3      0x0000000b                  // ADC0 trigger source for alternative is TPM3 overflow
      #define SIM_SOPT7_ADC0TRGSEL_RTC_ALARM 0x0000000c                  // ADC0 trigger source for alternative is RTC alarm
      #define SIM_SOPT7_ADC0TRGSEL_RTC_SEC   0x0000000d                  // ADC0 trigger source for alternative is RTC seconds
      #define SIM_SOPT7_ADC0TRGSEL_LPTMR0    0x0000000e                  // ADC0 trigger source for alternative is LPTMR0 trigger
      #define SIM_SOPT7_ADC0TRGSEL_CMP3      0x0000000f                  // ADC0 trigger source for alternative is CMP3 output
      #define SIM_SOPT7_ADC0PRETRGSEL_A      0x00000000                  // ADC pretrigger select - pretrigger A
      #define SIM_SOPT7_ADC0PRETRGSEL_B      0x00000010                  // ADC pretrigger select - pretrigger B
      #define SIM_SOPT7_ADC0ALTTRGEN         0x00000080                  // ADC alternate trigger enable
    #if defined KINETIS_K66
        #define SIM_SOPT8                    *(unsigned long*)(SIM_BLOCK + 0x101c) // System Options Register 8
    #endif
    #if defined KINETIS_KL82 || defined KINETIS_K65 || defined KINETIS_K66
        #define SIM_SOPT9                    *(unsigned long*)(SIM_BLOCK + 0x1020) // System Options Register 9
        #if defined KINETIS_KL82
            #define SIM_SOPT9_TPM0CLKSEL     0x01000000                  // TPM0 external clock pin selection
        #endif
            #define SIM_SOPT9_TPM1CLKSEL     0x02000000                  // TPM1 external clock pin selection
            #define SIM_SOPT9_TPM2CLKSEL     0x04000000                  // TPM2 external clock pin selection
    #endif
    #define SIM_SDID                         *(volatile unsigned long *)(SIM_BLOCK + 0x1024) // System Device Identification Register (read-only)
    #if !defined KINETIS_KL
        #define SIM_SCGC1                    *(volatile unsigned long *)(SIM_BLOCK + 0x1028) // System Clock Gating Control Register 1
          #define SIM_SCGC1_OSC1             0x00000020
          #if I2C_AVAILABLE > 2
            #define SIM_SCGC1_I2C2           0x00000040
          #endif
          #if I2C_AVAILABLE > 3
            #define SIM_SCGC1_I2C3           0x00000080
          #endif
          #define SIM_SCGC1_UART4            0x00000400
          #define SIM_SCGC1_UART5            0x00000800
        #define SIM_SCGC2                    *(volatile unsigned long *)(SIM_BLOCK + 0x102c) // System Clock Gating Control Register 2
          #define SIM_SCGC2_ENET             0x00000001
          #if defined KINETIS_K66
            #define SIM_SCGC2_LPUART0        0x00000010
            #define SIM_SCGC2_TPM1           0x00000200
            #define SIM_SCGC2_TPM2           0x00000400
          #elif defined KINETIS_K80
            #define SIM_SCGC2_LPUART0        0x00000010
            #define SIM_SCGC2_LPUART1        0x00000020
            #define SIM_SCGC2_LPUART2        0x00000040
            #define SIM_SCGC2_LPUART3        0x00000080
            #define SIM_SCGC2_TPM1           0x00000200
            #define SIM_SCGC2_TPM2           0x00000400
          #endif
          #define SIM_SCGC2_DAC0             0x00001000
          #define SIM_SCGC2_DAC1             0x00002000
          #if defined KINETIS_K80
            #if defined LTC_AVAILABLE
              #define SIM_SCGC2_LTC          0x00020000
              #define POWER_UP_LTC_MODULE()  POWER_UP(2, SIM_SCGC2_LTC);
            #endif
            #define SIM_SCGC2_EMVSIM0        0x00100000
            #define SIM_SCGC2_EMVSIM1        0x00200000
            #define SIM_SCGC2_LPUART4        0x00400000
            #define SIM_SCGC2_QSPI           0x04000000
            #define SIM_SCGC2_FLEXIO         0x80000000
          #endif
        #define SIM_SCGC3                    *(volatile unsigned long *)(SIM_BLOCK + 0x1030)  // System Clock Gating Control Register 3
          #define SIM_SCGC3_RNGA             0x00000001                                       // {41}
          #define SIM_SCGC3_RNGB             0x00000001
          #define SIM_SCGC3_TRNG             0x00000001
          #define SIM_SCGC3_USBHS            0x00000002
          #define SIM_SCGC3_USBHSPHY         0x00000004
          #define SIM_SCGC3_USBHSDCD         0x00000008
          #define SIM_SCGC3_FLEXCAN1         0x00000010
          #define SIM_SCGC3_NFC              0x00000100
          #define SIM_SCGC3_SPI2             0x00001000
          #define SIM_SCGC3_DDR              0x00004000
          #define SIM_SCGC3_SAI1             0x00008000
          #define SIM_SCGC3_SDHC             0x00020000
          #define SIM_SCGC3_LCDC             0x00400000
          #define SIM_SCGC3_FTM2             0x01000000
          #define SIM_SCGC3_FTM3             0x02000000
          #define SIM_SCGC3_ADC1             0x08000000
          #define SIM_SCGC3_ADC3             0x10000000
          #define SIM_SCGC3_SLCD             0x40000000                                       // K40
    #endif
    #define SIM_SCGC4                        *(volatile unsigned long *)(SIM_BLOCK + 0x1034)  // System Clock Gating Control Register 4
      #if defined KINETIS_KL03
          #define SIM_SCGC4_I2C0             0x00000040
          #define SIM_SCGC4_CMP              0x00080000
          #define SIM_SCGC4_VREF             0x00100000
          #define SIM_SCGC4_SPI0             0x00400000
      #else
          #define SIM_SCGC4_EWM              0x00000002
          #define SIM_SCGC4_CMT              0x00000004
          #define SIM_SCGC4_I2C0             0x00000040
          #define SIM_SCGC4_I2C1             0x00000080
          #define SIM_SCGC4_UART0            0x00000400
          #define SIM_SCGC4_UART1            0x00000800
          #define SIM_SCGC4_UART2            0x00001000
          #define SIM_SCGC4_UART3            0x00002000
          #define SIM_SCGC4_USBOTG           0x00040000
          #define SIM_SCGC4_CMP              0x00080000
          #define SIM_SCGC4_VREF             0x00100000
        #if defined KINETIS_KL
          #define SIM_SCGC4_SPI0             0x00400000
          #define SIM_SCGC4_SPI1             0x00800000
        #endif
        #if !defined KINETIS_K80
          #define SIM_SCGC4_LLWU             0x10000000
        #endif
      #endif
    #define SIM_SCGC5                        *(volatile unsigned long*)(SIM_BLOCK + 0x1038) // System Clock Gating Control Register 5
      #define SIM_SCGC5_LPTIMER              0x00000001
      #define SIM_SCGC5_REGFILE              0x00000002
      #define SIM_SCGC5_DRYICE               0x00000004
      #define SIM_SCGC5_DRYICESECREG         0x00000008
      #define SIM_SCGC5_LPTIMER1             0x00000010
      #define SIM_SCGC5_TSI                  0x00000020
      #define SIM_SCGC5_PORTA                0x00000200
      #define SIM_SCGC5_PORTB                0x00000400
      #define SIM_SCGC5_PORTC                0x00000800
      #define SIM_SCGC5_PORTD                0x00001000
      #define SIM_SCGC5_PORTE                0x00002000
      #if PORTS_AVAILABLE > 5
        #define SIM_SCGC5_PORTF              0x00004000
      #elif (defined KINETIS_KL46 || defined KINETIS_KL43)
        #define SIM_SCGC5_SLCD               0x00080000
      #elif defined KINETIS_KL82
        #define SIM_SCGC5_EMVSIM0            0x00004000
        #define SIM_SCGC5_EMVSIM1            0x00008000
      #endif
      #if defined KINETIS_KL
          #if defined LTC_AVAILABLE
              #define SIM_SCGC5_LTC          0x00020000
              #define POWER_UP_LTC_MODULE()  POWER_UP(5, SIM_SCGC5_LTC);
          #endif
          #if LPUARTS_AVAILABLE > 0
            #define SIM_SCGC5_LPUART0        0x00100000
          #endif
          #if LPUARTS_AVAILABLE > 1
            #define SIM_SCGC5_LPUART1        0x00200000
          #endif
          #if LPUARTS_AVAILABLE > 2
            #define SIM_SCGC5_LPUART3        0x00400000
          #endif
          #if defined KINETIS_KL82
            #define SIM_SCGC5_QSPI0          0x04000000
            #define SIM_SCGC5_FLEXIO0        0x80000000
          #endif
      #endif
    #define SIM_SCGC6                        *(volatile unsigned long *)(SIM_BLOCK + 0x103c) // System Clock Gating Control Register 6
      #define SIM_SCGC6_FTFL                 0x00000001
      #define SIM_SCGC6_DMAMUX0              0x00000002
      #define SIM_SCGC6_DMAMUX1              0x00000004
      #define SIM_SCGC6_FLEXCAN0             0x00000010
    #if !defined KINETIS_KL
      #if !defined KINETIS_K80
        #define SIM_SCGC6_LPUART0            0x00000400
      #endif
      #define SIM_SCGC6_SPI0                 0x00001000
      #define SIM_SCGC6_SPI1                 0x00002000
    #endif
      #define SIM_SCGC6_SAI0                 0x00008000
      #define SIM_SCGC6_I2S                  0x00008000
      #define SIM_SCGC6_CRC                  0x00040000
      #define SIM_SCGC6_USBHS                0x00100000                      // {25}
      #define SIM_SCGC6_USBDCD               0x00200000
      #define SIM_SCGC6_PDB                  0x00400000
      #define SIM_SCGC6_PIT                  0x00800000
      #define SIM_SCGC6_FTM0                 0x01000000                      // TPM0 on KL/KE
      #define SIM_SCGC6_FTM1                 0x02000000                      // TPM1 on KL/KE
    #if defined KINETIS_KL || defined KINETIS_KE || (defined KINETIS_K22 && (SIZE_OF_FLASH <= (512 * 1024)))
      #define SIM_SCGC6_FTM2                 0x04000000                      // TPM2 on KL/KE
    #endif
      #define SIM_SCGC6_ADC0                 0x08000000
      #define SIM_SCGC6_ADC2                 0x10000000
      #define SIM_SCGC6_RTC                  0x20000000
    #if defined KINETIS_KL
      #define SIM_SCGC6_DAC0                 0x80000000
    #endif
    #define SIM_SCGC7                        *(volatile unsigned long*)(SIM_BLOCK + 0x1040) // System Clock Gating Control Register 7
      #if defined KINETIS_KV
          #define SIM_SCGC7_DMA              0x00000002
      #else
          #define SIM_SCGC7_FLEXBUS          0x00000001
          #define SIM_SCGC7_DMA              0x00000002
          #define SIM_SCGC7_MPU              0x00000004
          #if defined KINETIS_K80
              #define SIM_SCGC7_SDRAMC       0x00000008
          #endif
      #endif
    #define SIM_CLKDIV1                      *(unsigned long *)(SIM_BLOCK + 0x1044) // System Clock Divider Register 1
      #define SIM_CLKDIV1_SYSTEM_1           0x00000000                  // divide value for the core/system clock
      #define SIM_CLKDIV1_SYSTEM_2           0x10000000
      #define SIM_CLKDIV1_SYSTEM_3           0x20000000
      #define SIM_CLKDIV1_SYSTEM_4           0x30000000
      #define SIM_CLKDIV1_SYSTEM_5           0x40000000
      #define SIM_CLKDIV1_SYSTEM_6           0x50000000
      #define SIM_CLKDIV1_SYSTEM_7           0x60000000
      #define SIM_CLKDIV1_SYSTEM_8           0x70000000
      #define SIM_CLKDIV1_SYSTEM_9           0x80000000
      #define SIM_CLKDIV1_SYSTEM_10          0x90000000
      #define SIM_CLKDIV1_SYSTEM_11          0xa0000000
      #define SIM_CLKDIV1_SYSTEM_12          0xb0000000
      #define SIM_CLKDIV1_SYSTEM_13          0xc0000000
      #define SIM_CLKDIV1_SYSTEM_14          0xd0000000
      #define SIM_CLKDIV1_SYSTEM_15          0xe0000000
      #define SIM_CLKDIV1_SYSTEM_16          0xf0000000
    #if defined KINETIS_KL
      #define SIM_CLKDIV1_BUS_1              0x00000000                  // divide value for the bus/peripheral clock
      #define SIM_CLKDIV1_BUS_2              0x00010000
      #define SIM_CLKDIV1_BUS_3              0x00020000
      #define SIM_CLKDIV1_BUS_4              0x00030000
      #define SIM_CLKDIV1_BUS_5              0x00040000
      #define SIM_CLKDIV1_BUS_6              0x00050000
      #define SIM_CLKDIV1_BUS_7              0x00060000
      #define SIM_CLKDIV1_BUS_8              0x00070000
      #define SIM_CLKDIV1_BUS_9              0x00080000
      #define SIM_CLKDIV1_BUS_10             0x00090000
      #define SIM_CLKDIV1_BUS_11             0x000a0000
      #define SIM_CLKDIV1_BUS_12             0x000b0000
      #define SIM_CLKDIV1_BUS_13             0x000c0000
      #define SIM_CLKDIV1_BUS_14             0x000d0000
      #define SIM_CLKDIV1_BUS_15             0x000e0000
      #define SIM_CLKDIV1_BUS_16             0x000f0000
    #elif defined KINETIS_KV
      #define SIM_CLKDIV1_BUS_1              0x00000000                  // divide value for the bus/peripheral clock
      #define SIM_CLKDIV1_BUS_2              0x00010000
      #define SIM_CLKDIV1_BUS_3              0x00020000
      #define SIM_CLKDIV1_BUS_4              0x00030000
      #define SIM_CLKDIV1_BUS_5              0x00040000
      #define SIM_CLKDIV1_BUS_6              0x00050000
      #define SIM_CLKDIV1_BUS_7              0x00060000
      #define SIM_CLKDIV1_BUS_8              0x00070000

      #define SIM_CLKDIV5_ADC_1              0x00000000                  // divide value for the bus/peripheral clock
      #define SIM_CLKDIV5_ADC_2              0x00001000
      #define SIM_CLKDIV5_ADC_3              0x00002000
      #define SIM_CLKDIV5_ADC_4              0x00003000
      #define SIM_CLKDIV5_ADC_5              0x00004000
      #define SIM_CLKDIV5_ADC_6              0x00005000
      #define SIM_CLKDIV5_ADC_7              0x00006000
      #define SIM_CLKDIV5_ADC_8              0x00007000
      #define SIM_OUTDIV5EN                  0x00008000
    #else
      #define SIM_CLKDIV1_BUS_1              0x00000000                  // divide value for the bus/peripheral clock
      #define SIM_CLKDIV1_BUS_2              0x01000000
      #define SIM_CLKDIV1_BUS_3              0x02000000
      #define SIM_CLKDIV1_BUS_4              0x03000000
      #define SIM_CLKDIV1_BUS_5              0x04000000
      #define SIM_CLKDIV1_BUS_6              0x05000000
      #define SIM_CLKDIV1_BUS_7              0x06000000
      #define SIM_CLKDIV1_BUS_8              0x07000000
      #define SIM_CLKDIV1_BUS_9              0x08000000
      #define SIM_CLKDIV1_BUS_10             0x09000000
      #define SIM_CLKDIV1_BUS_11             0x0a000000
      #define SIM_CLKDIV1_BUS_12             0x0b000000
      #define SIM_CLKDIV1_BUS_13             0x0c000000
      #define SIM_CLKDIV1_BUS_14             0x0d000000
      #define SIM_CLKDIV1_BUS_15             0x0e000000
      #define SIM_CLKDIV1_BUS_16             0x0f000000
      #define SIM_CLKDIV1_FLEX_1             0x00000000                  // divide value for the flex bus clock
      #define SIM_CLKDIV1_FLEX_2             0x00100000
      #define SIM_CLKDIV1_FLEX_3             0x00200000
      #define SIM_CLKDIV1_FLEX_4             0x00300000
      #define SIM_CLKDIV1_FLEX_5             0x00400000
      #define SIM_CLKDIV1_FLEX_6             0x00500000
      #define SIM_CLKDIV1_FLEX_7             0x00600000
      #define SIM_CLKDIV1_FLEX_8             0x00700000
      #define SIM_CLKDIV1_FLEX_9             0x00800000
      #define SIM_CLKDIV1_FLEX_10            0x00900000
      #define SIM_CLKDIV1_FLEX_11            0x00a00000
      #define SIM_CLKDIV1_FLEX_12            0x00b00000
      #define SIM_CLKDIV1_FLEX_13            0x00c00000
      #define SIM_CLKDIV1_FLEX_14            0x00d00000
      #define SIM_CLKDIV1_FLEX_15            0x00e00000
      #define SIM_CLKDIV1_FLEX_16            0x00f00000
      #define SIM_CLKDIV1_FLASH_1            0x00000000                  // divide value for the flash clock
      #define SIM_CLKDIV1_FLASH_2            0x00010000
      #define SIM_CLKDIV1_FLASH_3            0x00020000
      #define SIM_CLKDIV1_FLASH_4            0x00030000
      #define SIM_CLKDIV1_FLASH_5            0x00040000
      #define SIM_CLKDIV1_FLASH_6            0x00050000
      #define SIM_CLKDIV1_FLASH_7            0x00060000
      #define SIM_CLKDIV1_FLASH_8            0x00070000
      #define SIM_CLKDIV1_FLASH_9            0x00080000
      #define SIM_CLKDIV1_FLASH_10           0x00090000
      #define SIM_CLKDIV1_FLASH_11           0x000a0000
      #define SIM_CLKDIV1_FLASH_12           0x000b0000
      #define SIM_CLKDIV1_FLASH_13           0x000c0000
      #define SIM_CLKDIV1_FLASH_14           0x000d0000
      #define SIM_CLKDIV1_FLASH_15           0x000e0000
      #define SIM_CLKDIV1_FLASH_16           0x000f0000
    #endif
    #if !defined KINETIS_KL || defined KINETIS_KL82
        #define SIM_CLKDIV2                  *(unsigned long *)(SIM_BLOCK + 0x1048) // System Clock Divider Register 2
          #define SIM_CLKDIV2_USBFRAC        0x00000001
          #define SIM_CLKDIV2_USBDIV_1       0x00000000
          #define SIM_CLKDIV2_USBDIV_2       0x00000002
          #define SIM_CLKDIV2_USBDIV_3       0x00000004
          #define SIM_CLKDIV2_USBDIV_4       0x00000006
          #define SIM_CLKDIV2_USBDIV_5       0x00000008
          #define SIM_CLKDIV2_USBDIV_6       0x0000000a
          #define SIM_CLKDIV2_USBDIV_7       0x0000000c
          #define SIM_CLKDIV2_USBDIV_8       0x0000000e
    #endif
    #define SIM_FCFG1                        *(volatile unsigned long *)(SIM_BLOCK + 0x104c) // FLASH Configuration Register 1
    #define SIM_FCFG2                        *(volatile unsigned long *)(SIM_BLOCK + 0x1050) // FLASH Configuration Register 2
    #if !defined KINETIS_KL
        #define SIM_UIDH                     *(volatile unsigned long *)(SIM_BLOCK + 0x1054) // Unique Identification Register High
    #endif
    #define SIM_UIDMH                        *(volatile unsigned long *)(SIM_BLOCK + 0x1058) // Unique Identification Register Mid-High
    #define SIM_UIDML                        *(volatile unsigned long *)(SIM_BLOCK + 0x105c) // Unique Identification Register Mid-Low
    #define SIM_UIDL                         *(volatile unsigned long *)(SIM_BLOCK + 0x1060) // Unique Identification Register Low
    #if defined KINETIS_KL && !defined KINETIS_KL82                          // {42}
        #define SIM_COPC                     *(unsigned long *)(SIM_BLOCK + 0x1100) // COP Control Register - all of the bits in this register can be written only once after a reset
          #define SIM_COPC_COPW              0x00000001                      // COP windowed mode
          #define SIM_COPC_COPCLKS_1K        0x00000000                      // COP source is 1kHz clock
          #define SIM_COPC_COPCLKS_BUS       0x00000002                      // COP source is bus clock
          #define SIM_COPC_COPT_DISABLED     0x00000000                      // COP disabled
          #define SIM_COPC_COPT_SHORTEST     0x00000004                      // 2^13 bus clocks or 32ms timeout
          #define SIM_COPC_COPT_MEDIUM       0x00000008                      // 2^16 bus clocks or 256ms timeout
          #define SIM_COPC_COPT_LONGEST      0x0000000c                      // 2^18 bus clocks or 1.024s timeout
        #define SIM_SRVCOP                  *(volatile unsigned long *)(SIM_BLOCK + 0x1104) // COP Control Register (write-only)
          #define SIM_SRVCOP_1               0x00000055                      // to service the COP 0x55 is written, followed by 0xaa
          #define SIM_SRVCOP_2               0x000000aa
    #elif defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000)
        #define SIM_CLKDIV3                  *(unsigned long *)(SIM_BLOCK + 0x1064) // System Clock Divider Register 3
            #define SIM_CLKDIV3_LCDCFRAC     0x0000ff00                      // LCDCFRAC clock divider fraction
            #define SIM_CLKDIV3_LCDCDIV      0x0fff0000                      // LCDC clock divider fraction
        #define SIM_CLKDIV4                  *(unsigned long *)(SIM_BLOCK + 0x1068) // System Clock Divider Register 4
            #define SIM_CLKDIV4_TRACEFRAC    0x00000001                      // Trace Clock divider fraction
            #define SIM_CLKDIV4_TRACEDIV     0x0000000e                      // Trace clock divider divisor
            #define SIM_CLKDIV4_NFCFRAC      0x07000000                      // NCF clock divider fraction
            #define SIM_CLKDIV4_NFCDIV       0xf8000000                      // NCF clock divider divisor
        #define SIM_MCR                      *(volatile unsigned long *)(SIM_BLOCK + 0x106c) // Misc Control Register
            #define SIM_MCR_DDRSREN          0x00000001                      // DDR self refresh enable
            #define SIM_MCR_DDRS             0x00000002                      // DDR self refresh status (read-only)
            #define SIM_MCR_DDRPEN           0x00000004                      // Pin enable for all DDR I/O
            #define SIM_MCR_DDRDQSDIS        0x00000008                      // DDR_DQS analog circuit disable
            #define SIM_MCR_DDRCFG_LPDDR_2   0x00000000                      // DDR configuration select - LPDDR half strength
            #define SIM_MCR_DDRCFG_LPDDR     0x00000020                      // DDR configuration select - LPDDR full strength
            #define SIM_MCR_DDRCFG_DDR2_2    0x00000040                      // DDR configuration select - DDR2 half strength
            #define SIM_MCR_DDRCFG_DDR1      0x00000060                      // DDR configuration select - DDR1
            #define SIM_MCR_DDRCFG_DDR2      0x000000c0                      // DDR configuration select - DDR2 full strength
            #define SIM_MCR_RCRRSTEN         0x00000100                      // DDR RCR Special Reset Enable
            #define SIM_MCR_RCRRST           0x00000200                      // DDR RCR Reset Status (read-only)
            #define SIM_MCR_LCDSTART         0x00010000                      // start LCDC display
            #define SIM_MCR_PDBLOOP          0x20000000                      // PDB loop mode
            #define SIM_MCR_ULPICLKOBE       0x40000000                      // 60MHz ULPI clock (ULPI_CLK) output enable
            #define SIM_MCR_TRACECLKDIS      0x80000000                      // Trace clock disable
    #endif
#endif

#if defined KINETIS_KE
    #define POWER_UP(reg, module)            SIM_SCGC |= (module)            // power up a module (apply clock to it)
    #define POWER_DOWN(reg, module)          SIM_SCGC &= ~(module)           // power down a module (disable clock to it)
    #define IS_POWERED_UP(reg, module)      (SIM_SCGC & (module))
#else
    #define POWER_UP(reg, module)            SIM_SCGC##reg |= (module)       // power up a module (apply clock to it)
    #define POWER_DOWN(reg, module)          SIM_SCGC##reg &= ~(module)      // power down a module (disable clock to it)

    #if defined KINETIS_K_FPU
        #define SIM_SOPT1_SET(opt, enable)   SIM_SOPT1CGF |= (enable); SIM_SOPT1 |= (opt)
        #define SIM_SOPT1_CLR(opt, enable)   SIM_SOPT1CGF |= (enable); SIM_SOPT1 &= ~(opt)
    #elif !defined KINETIS_KL02
        #define SIM_SOPT1_SET(opt, enable)   SIM_SOPT1 |= (opt)
        #define SIM_SOPT1_CLR(opt, enable)   SIM_SOPT1 &= ~(opt)
    #endif
    #define IS_POWERED_UP(reg, module)      (SIM_SCGC##reg & (module))
#endif


// Port Control and Interrupts
//
#if defined KINETIS_KE
    #if (defined KINETIS_KE04 && (SIZE_OF_FLASH > (8 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define PORT_IOFLT0              *(unsigned long *)(PORT_BLOCK + 0x00) // Port Filter Register 0
        #define PORT_IOFLT1              *(unsigned long *)(PORT_BLOCK + 0x04) // Port Filter Register 0
        #define PORT_PUEL_ADD            (unsigned long *)(PORT_BLOCK + 0x08)
        #define PORT_PUE0                *(unsigned long *)(PORT_BLOCK + 0x08) // Port Pullup Enable Low Register
        #define PORT_PUE1                *(unsigned long *)(PORT_BLOCK + 0x0c) // Port Pullup Enable High Register
        #define PORT_PUE2                *(unsigned long *)(PORT_BLOCK + 0x10) // Port Pullup Enable High Register
        #define PORT_HDRVE               *(unsigned long *)(PORT_BLOCK + 0x14) // Port High Drive Enable Register
    #else
        #define PORT_IOFLT               *(unsigned long *)(PORT_BLOCK + 0x0) // Port Filter Register
        #define PORT_PUEL_ADD            (unsigned long *)(PORT_BLOCK + 0x4)
        #define PORT_PUEL                *(unsigned long *)(PORT_BLOCK + 0x4) // Port Pullup Enable Low Register
        #if (defined KINETIS_KE04 && (SIZE_OF_FLASH > (8 * 1024)))
        #define PORT_PUEH                *(unsigned long *)(PORT_BLOCK + 0x8) // Port Pullup Enable High Register
        #endif
        #define PORT_HDRVE               *(unsigned long *)(PORT_BLOCK + 0xc) // Port High Drive Enable Register
    #endif

    #define PORT_MUX_GPIO                0                               // for simulation compatibility
    #define PORT_MUX_ALT1                1
    #define PORT_MUX_ALT2                2
    #define PORT_MUX_ALT3                3
    #define PORT_MUX_ALT4                4
    #define PORT_MUX_ALT5                5
    #define PORT_MUX_ALT6                6
    #define PORT_MUX_ALT7                7

    #define PORT_NO_PULL                 0                               // for configuration compatibility
    #define PORT_SRE_FAST                0                               // for configuration compatibility
    #define PORT_SRE_SLOW                0                               // for configuration compatibility
    #define PORT_PS_UP_ENABLE            0x1
    #define PORT_DSE_LOW                 0
    #define PORT_DSE_HIGH                0x02
    #define PORT_ODE                     0
#else
    #define PORTA_PCR0                   *(volatile unsigned long *)(PORT0_BLOCK + 0x00)  // Pin Control Register 0
      #define PORT_NO_PULL               0x00000000                                       // no pull-ups enabled
      #define PORT_PE                    0x00000002                                       // enable pull if digital input
      #define PORT_PS_DOWN_ENABLE        (0x00000000 | PORT_PE)                           // pull-down if enabled
      #define PORT_PS_UP_ENABLE          (0x00000001 | PORT_PE)                           // pull-up if enabled
      #define PORT_SRE_FAST              0x00000000                                       // fast slew-rate if digital output
      #define PORT_SRE_SLOW              0x00000004                                       // slow slew-rate if digital output
      #define PORT_PFE                   0x00000010                                       // passive filter enabled if digital input (disable for signals > 2MHz)
      #define PORT_ODE                   0x00000020                                       // open-drain enabled if digital output
      #define PORT_DSE_LOW               0x00000000                                       // digital strength low if digital output
      #define PORT_DSE_HIGH              0x00000040                                       // digital strength high if digital output
      #define PORT_MUX_ANALOG            0x00000000                                       // pin disabled (analog)
      #define PORT_MUX_ALT0              0x00000000                                       // alternative 0
      #define PORT_MUX_GPIO              0x00000100                                       // GPIO (alternative 1)
      #define PORT_MUX_ALT2              0x00000200                                       // alternative 2
      #define PORT_MUX_ALT3              0x00000300                                       // alternative 3
     #if !defined KINETIS_KL02 && !defined KINETIS_KL05
      #define PORT_MUX_ALT4              0x00000400                                       // alternative 4
      #define PORT_MUX_ALT5              0x00000500                                       // alternative 5
      #define PORT_MUX_ALT6              0x00000600                                       // alternative 6
      #define PORT_MUX_ALT7              0x00000700                                       // alternative 7
     #endif
      #define PORT_MUX_MASK              0x00000700
      #define PORT_LOCK                  0x00008000                                       // lock register (bits 0..15) until next reset
      #define PORT_IRQC_DISABLED         0x00000000                                       // IRQ/DMA disabled
      #define PORT_IRQC_DMA_RISING       0x00010000                                       // DMA request on rising edge
      #define PORT_IRQC_DMA_FALLING      0x00020000                                       // DMA request on falling edge
      #define PORT_IRQC_DMA_BOTH         0x00030000                                       // DMA request on both edges
      #define PORT_IRQC_LOW_LEVEL        0x00080000                                       // IRQ level 0
      #define PORT_IRQC_RISING           0x00090000                                       // IRQ rising edge
      #define PORT_IRQC_FALLING          0x000a0000                                       // IRQ falling edge
      #define PORT_IRQC_BOTH             0x000b0000                                       // IRQ both edges
      #define PORT_IRQC_HIGH_LEVEL       0x000c0000                                       // IRQ level 1
      #define PORT_IRQC_INT_MASK         0x000f0000
      #define PORT_ISF                   0x01000000                                       // IRQ status flag (write 1 to clear)
      #define PORT_PSEUDO_FLAG_SET_ONLY_PULLS 0x80000000                                  // not used by the port but passed when only characteristics are to be modified
    #define PORTA_PCR1                   *(volatile unsigned long *)(PORT0_BLOCK + 0x04)  // Pin Control Register 1
    #define PORTA_PCR2                   *(volatile unsigned long *)(PORT0_BLOCK + 0x08)  // Pin Control Register 2
    #define PORTA_PCR3                   *(volatile unsigned long *)(PORT0_BLOCK + 0x0c)  // Pin Control Register 3
    #define PORTA_PCR4                   *(volatile unsigned long *)(PORT0_BLOCK + 0x10)  // Pin Control Register 4
    #define PORTA_PCR5                   *(volatile unsigned long *)(PORT0_BLOCK + 0x14)  // Pin Control Register 5
    #define PORTA_PCR6                   *(volatile unsigned long *)(PORT0_BLOCK + 0x18)  // Pin Control Register 6
    #define PORTA_PCR7                   *(volatile unsigned long *)(PORT0_BLOCK + 0x1c)  // Pin Control Register 7
    #define PORTA_PCR8                   *(volatile unsigned long *)(PORT0_BLOCK + 0x20)  // Pin Control Register 8
    #define PORTA_PCR9                   *(volatile unsigned long *)(PORT0_BLOCK + 0x24)  // Pin Control Register 9
    #define PORTA_PCR10                  *(volatile unsigned long *)(PORT0_BLOCK + 0x28)  // Pin Control Register 10
    #define PORTA_PCR11                  *(volatile unsigned long *)(PORT0_BLOCK + 0x2c)  // Pin Control Register 11
    #define PORTA_PCR12                  *(volatile unsigned long *)(PORT0_BLOCK + 0x30)  // Pin Control Register 12
    #define PORTA_PCR13                  *(volatile unsigned long *)(PORT0_BLOCK + 0x34)  // Pin Control Register 13
    #define PORTA_PCR14                  *(volatile unsigned long *)(PORT0_BLOCK + 0x38)  // Pin Control Register 14
    #define PORTA_PCR15                  *(volatile unsigned long *)(PORT0_BLOCK + 0x3c)  // Pin Control Register 15
    #define PORTA_PCR16                  *(volatile unsigned long *)(PORT0_BLOCK + 0x40)  // Pin Control Register 16
    #define PORTA_PCR17                  *(volatile unsigned long *)(PORT0_BLOCK + 0x44)  // Pin Control Register 17
    #define PORTA_PCR18                  *(volatile unsigned long *)(PORT0_BLOCK + 0x48)  // Pin Control Register 18
    #define PORTA_PCR19                  *(volatile unsigned long *)(PORT0_BLOCK + 0x4c)  // Pin Control Register 19
    #define PORTA_PCR20                  *(volatile unsigned long *)(PORT0_BLOCK + 0x50)  // Pin Control Register 20
    #define PORTA_PCR21                  *(volatile unsigned long *)(PORT0_BLOCK + 0x54)  // Pin Control Register 21
    #define PORTA_PCR22                  *(volatile unsigned long *)(PORT0_BLOCK + 0x58)  // Pin Control Register 22
    #define PORTA_PCR23                  *(volatile unsigned long *)(PORT0_BLOCK + 0x5c)  // Pin Control Register 23
    #define PORTA_PCR24                  *(volatile unsigned long *)(PORT0_BLOCK + 0x60)  // Pin Control Register 24
    #define PORTA_PCR25                  *(volatile unsigned long *)(PORT0_BLOCK + 0x64)  // Pin Control Register 25
    #define PORTA_PCR26                  *(volatile unsigned long *)(PORT0_BLOCK + 0x68)  // Pin Control Register 26
    #define PORTA_PCR27                  *(volatile unsigned long *)(PORT0_BLOCK + 0x6c)  // Pin Control Register 27
    #define PORTA_PCR28                  *(volatile unsigned long *)(PORT0_BLOCK + 0x70)  // Pin Control Register 28
    #define PORTA_PCR29                  *(volatile unsigned long *)(PORT0_BLOCK + 0x74)  // Pin Control Register 29
    #define PORTA_PCR30                  *(volatile unsigned long *)(PORT0_BLOCK + 0x78)  // Pin Control Register 30
    #define PORTA_PCR31                  *(volatile unsigned long *)(PORT0_BLOCK + 0x7c)  // Pin Control Register 31
    #define PORTA_GPCLR                  *(volatile unsigned long *)(PORT0_BLOCK + 0x80)  // Global Pin Control Low Register (write-only)
    #define PORTA_GPCHR                  *(volatile unsigned long *)(PORT0_BLOCK + 0x84)  // Global Pin Control High Register (write-only)
    #define PORTA_ISFR                   *(volatile unsigned long *)(PORT0_BLOCK + 0xa0)  // Interrupt Status Flag Register (read-only/write one to clear)
    #define PORTA_DFER                   *(unsigned long *)(PORT0_BLOCK + 0xc0)           // Digital Filter Enable Register
    #define PORTA_DFCR                   *(unsigned long *)(PORT0_BLOCK + 0xc4)           // Digital Filter Clock Register
      #define PORT_DFCR_BUS_CLOCK        0x00000000                                       // digital filters clocked by bus clock
      #define PORT_DFCR_1K_CLOCK         0x00000001                                       // digital filters clocked by 1kHz clock
    #define PORTA_DFWR                   *(unsigned long *)(PORT0_BLOCK + 0xc8)           // Digital Filter Width Register
      #define PORT_DFWR_MASK             0x0000001f                                       // digital glitch length mask (change only when filters are disabled)

    #if PORTS_AVAILABLE > 1
        #define PORTB_PCR0               *(volatile unsigned long *)(PORT1_BLOCK + 0x00)  // Pin Control Register 0
        #define PORTB_PCR1               *(volatile unsigned long *)(PORT1_BLOCK + 0x04)  // Pin Control Register 1
        #define PORTB_PCR2               *(volatile unsigned long *)(PORT1_BLOCK + 0x08)  // Pin Control Register 2
        #define PORTB_PCR3               *(volatile unsigned long *)(PORT1_BLOCK + 0x0c)  // Pin Control Register 3
        #define PORTB_PCR4               *(volatile unsigned long *)(PORT1_BLOCK + 0x10)  // Pin Control Register 4
        #define PORTB_PCR5               *(volatile unsigned long *)(PORT1_BLOCK + 0x14)  // Pin Control Register 5
        #define PORTB_PCR6               *(volatile unsigned long *)(PORT1_BLOCK + 0x18)  // Pin Control Register 6
        #define PORTB_PCR7               *(volatile unsigned long *)(PORT1_BLOCK + 0x1c)  // Pin Control Register 7
        #define PORTB_PCR8               *(volatile unsigned long *)(PORT1_BLOCK + 0x20)  // Pin Control Register 8
        #define PORTB_PCR9               *(volatile unsigned long *)(PORT1_BLOCK + 0x24)  // Pin Control Register 9
        #define PORTB_PCR10              *(volatile unsigned long *)(PORT1_BLOCK + 0x28)  // Pin Control Register 10
        #define PORTB_PCR11              *(volatile unsigned long *)(PORT1_BLOCK + 0x2c)  // Pin Control Register 11
        #define PORTB_PCR12              *(volatile unsigned long *)(PORT1_BLOCK + 0x30)  // Pin Control Register 12
        #define PORTB_PCR13              *(volatile unsigned long *)(PORT1_BLOCK + 0x34)  // Pin Control Register 13
        #define PORTB_PCR14              *(volatile unsigned long *)(PORT1_BLOCK + 0x38)  // Pin Control Register 14
        #define PORTB_PCR15              *(volatile unsigned long *)(PORT1_BLOCK + 0x3c)  // Pin Control Register 15
        #define PORTB_PCR16              *(volatile unsigned long *)(PORT1_BLOCK + 0x40)  // Pin Control Register 16
        #define PORTB_PCR17              *(volatile unsigned long *)(PORT1_BLOCK + 0x44)  // Pin Control Register 17
        #define PORTB_PCR18              *(volatile unsigned long *)(PORT1_BLOCK + 0x48)  // Pin Control Register 18
        #define PORTB_PCR19              *(volatile unsigned long *)(PORT1_BLOCK + 0x4c)  // Pin Control Register 19
        #define PORTB_PCR20              *(volatile unsigned long *)(PORT1_BLOCK + 0x50)  // Pin Control Register 20
        #define PORTB_PCR21              *(volatile unsigned long *)(PORT1_BLOCK + 0x54)  // Pin Control Register 21
        #define PORTB_PCR22              *(volatile unsigned long *)(PORT1_BLOCK + 0x58)  // Pin Control Register 22
        #define PORTB_PCR23              *(volatile unsigned long *)(PORT1_BLOCK + 0x5c)  // Pin Control Register 23
        #define PORTB_PCR24              *(volatile unsigned long *)(PORT1_BLOCK + 0x60)  // Pin Control Register 24
        #define PORTB_PCR25              *(volatile unsigned long *)(PORT1_BLOCK + 0x64)  // Pin Control Register 25
        #define PORTB_PCR26              *(volatile unsigned long *)(PORT1_BLOCK + 0x68)  // Pin Control Register 26
        #define PORTB_PCR27              *(volatile unsigned long *)(PORT1_BLOCK + 0x6c)  // Pin Control Register 27
        #define PORTB_PCR28              *(volatile unsigned long *)(PORT1_BLOCK + 0x70)  // Pin Control Register 28
        #define PORTB_PCR29              *(volatile unsigned long *)(PORT1_BLOCK + 0x74)  // Pin Control Register 29
        #define PORTB_PCR30              *(volatile unsigned long *)(PORT1_BLOCK + 0x78)  // Pin Control Register 30
        #define PORTB_PCR31              *(volatile unsigned long *)(PORT1_BLOCK + 0x7c)  // Pin Control Register 31
        #define PORTB_GPCLR              *(volatile unsigned long *)(PORT1_BLOCK + 0x80)  // Global Pin Control Low Register (write-only)
        #define PORTB_GPCHR              *(volatile unsigned long *)(PORT1_BLOCK + 0x84)  // Global Pin Control High Register (write-only)
        #define PORTB_ISFR               *(volatile unsigned long *)(PORT1_BLOCK + 0xa0)  // Interrupt Status Flag Register (read-only/write one to clear)
        #define PORTB_DFER               *(unsigned long *)(PORT1_BLOCK + 0xc0)           // Digital Filter Enable Register
        #define PORTB_DFCR               *(unsigned long *)(PORT1_BLOCK + 0xc4)           // Digital Filter Clock Register
        #define PORTB_DFWR               *(unsigned long *)(PORT1_BLOCK + 0xc8)           // Digital Filter Width Register
    #endif
    #if PORTS_AVAILABLE > 2
        #define PORTC_PCR0               *(volatile unsigned long *)(PORT2_BLOCK + 0x00)  // Pin Control Register 0
        #define PORTC_PCR1               *(volatile unsigned long *)(PORT2_BLOCK + 0x04)  // Pin Control Register 1
        #define PORTC_PCR2               *(volatile unsigned long *)(PORT2_BLOCK + 0x08)  // Pin Control Register 2
        #define PORTC_PCR3               *(volatile unsigned long *)(PORT2_BLOCK + 0x0c)  // Pin Control Register 3
        #define PORTC_PCR4               *(volatile unsigned long *)(PORT2_BLOCK + 0x10)  // Pin Control Register 4
        #define PORTC_PCR5               *(volatile unsigned long *)(PORT2_BLOCK + 0x14)  // Pin Control Register 5
        #define PORTC_PCR6               *(volatile unsigned long *)(PORT2_BLOCK + 0x18)  // Pin Control Register 6
        #define PORTC_PCR7               *(volatile unsigned long *)(PORT2_BLOCK + 0x1c)  // Pin Control Register 7
        #define PORTC_PCR8               *(volatile unsigned long *)(PORT2_BLOCK + 0x20)  // Pin Control Register 8
        #define PORTC_PCR9               *(volatile unsigned long *)(PORT2_BLOCK + 0x24)  // Pin Control Register 9
        #define PORTC_PCR10              *(volatile unsigned long *)(PORT2_BLOCK + 0x28)  // Pin Control Register 10
        #define PORTC_PCR11              *(volatile unsigned long *)(PORT2_BLOCK + 0x2c)  // Pin Control Register 11
        #define PORTC_PCR12              *(volatile unsigned long *)(PORT2_BLOCK + 0x30)  // Pin Control Register 12
        #define PORTC_PCR13              *(volatile unsigned long *)(PORT2_BLOCK + 0x34)  // Pin Control Register 13
        #define PORTC_PCR14              *(volatile unsigned long *)(PORT2_BLOCK + 0x38)  // Pin Control Register 14
        #define PORTC_PCR15              *(volatile unsigned long *)(PORT2_BLOCK + 0x3c)  // Pin Control Register 15
        #define PORTC_PCR16              *(volatile unsigned long *)(PORT2_BLOCK + 0x40)  // Pin Control Register 16
        #define PORTC_PCR17              *(volatile unsigned long *)(PORT2_BLOCK + 0x44)  // Pin Control Register 17
        #define PORTC_PCR18              *(volatile unsigned long *)(PORT2_BLOCK + 0x48)  // Pin Control Register 18
        #define PORTC_PCR19              *(volatile unsigned long *)(PORT2_BLOCK + 0x4c)  // Pin Control Register 19
        #define PORTC_PCR20              *(volatile unsigned long *)(PORT2_BLOCK + 0x50)  // Pin Control Register 20
        #define PORTC_PCR21              *(volatile unsigned long *)(PORT2_BLOCK + 0x54)  // Pin Control Register 21
        #define PORTC_PCR22              *(volatile unsigned long *)(PORT2_BLOCK + 0x58)  // Pin Control Register 22
        #define PORTC_PCR23              *(volatile unsigned long *)(PORT2_BLOCK + 0x5c)  // Pin Control Register 23
        #define PORTC_PCR24              *(volatile unsigned long *)(PORT2_BLOCK + 0x60)  // Pin Control Register 24
        #define PORTC_PCR25              *(volatile unsigned long *)(PORT2_BLOCK + 0x64)  // Pin Control Register 25
        #define PORTC_PCR26              *(volatile unsigned long *)(PORT2_BLOCK + 0x68)  // Pin Control Register 26
        #define PORTC_PCR27              *(volatile unsigned long *)(PORT2_BLOCK + 0x6c)  // Pin Control Register 27
        #define PORTC_PCR28              *(volatile unsigned long *)(PORT2_BLOCK + 0x70)  // Pin Control Register 28
        #define PORTC_PCR29              *(volatile unsigned long *)(PORT2_BLOCK + 0x74)  // Pin Control Register 29
        #define PORTC_PCR30              *(volatile unsigned long *)(PORT2_BLOCK + 0x78)  // Pin Control Register 30
        #define PORTC_PCR31              *(volatile unsigned long *)(PORT2_BLOCK + 0x7c)  // Pin Control Register 31
        #define PORTC_GPCLR              *(volatile unsigned long *)(PORT2_BLOCK + 0x80)  // Global Pin Control Low Register (write-only)
        #define PORTC_GPCHR              *(volatile unsigned long *)(PORT2_BLOCK + 0x84)  // Global Pin Control High Register (write-only)
        #define PORTC_ISFR               *(volatile unsigned long *)(PORT2_BLOCK + 0xa0)  // Interrupt Status Flag Register (read-only/write one to clear)
        #define PORTC_DFER               *(unsigned long *)(PORT2_BLOCK + 0xc0)           // Digital Filter Enable Register
        #define PORTC_DFCR               *(unsigned long *)(PORT2_BLOCK + 0xc4)           // Digital Filter Clock Register
        #define PORTC_DFWR               *(unsigned long *)(PORT2_BLOCK + 0xc8)           // Digital Filter Width Register
    #endif
    #if PORTS_AVAILABLE > 3
        #define PORTD_PCR0               *(volatile unsigned long *)(PORT3_BLOCK + 0x00)  // Pin Control Register 0
        #define PORTD_PCR1               *(volatile unsigned long *)(PORT3_BLOCK + 0x04)  // Pin Control Register 1
        #define PORTD_PCR2               *(volatile unsigned long *)(PORT3_BLOCK + 0x08)  // Pin Control Register 2
        #define PORTD_PCR3               *(volatile unsigned long *)(PORT3_BLOCK + 0x0c)  // Pin Control Register 3
        #define PORTD_PCR4               *(volatile unsigned long *)(PORT3_BLOCK + 0x10)  // Pin Control Register 4
        #define PORTD_PCR5               *(volatile unsigned long *)(PORT3_BLOCK + 0x14)  // Pin Control Register 5
        #define PORTD_PCR6               *(volatile unsigned long *)(PORT3_BLOCK + 0x18)  // Pin Control Register 6
        #define PORTD_PCR7               *(volatile unsigned long *)(PORT3_BLOCK + 0x1c)  // Pin Control Register 7
        #define PORTD_PCR8               *(volatile unsigned long *)(PORT3_BLOCK + 0x20)  // Pin Control Register 8
        #define PORTD_PCR9               *(volatile unsigned long *)(PORT3_BLOCK + 0x24)  // Pin Control Register 9
        #define PORTD_PCR10              *(volatile unsigned long *)(PORT3_BLOCK + 0x28)  // Pin Control Register 10
        #define PORTD_PCR11              *(volatile unsigned long *)(PORT3_BLOCK + 0x2c)  // Pin Control Register 11
        #define PORTD_PCR12              *(volatile unsigned long *)(PORT3_BLOCK + 0x30)  // Pin Control Register 12
        #define PORTD_PCR13              *(volatile unsigned long *)(PORT3_BLOCK + 0x34)  // Pin Control Register 13
        #define PORTD_PCR14              *(volatile unsigned long *)(PORT3_BLOCK + 0x38)  // Pin Control Register 14
        #define PORTD_PCR15              *(volatile unsigned long *)(PORT3_BLOCK + 0x3c)  // Pin Control Register 15
        #define PORTD_PCR16              *(volatile unsigned long *)(PORT3_BLOCK + 0x40)  // Pin Control Register 16
        #define PORTD_PCR17              *(volatile unsigned long *)(PORT3_BLOCK + 0x44)  // Pin Control Register 17
        #define PORTD_PCR18              *(volatile unsigned long *)(PORT3_BLOCK + 0x48)  // Pin Control Register 18
        #define PORTD_PCR19              *(volatile unsigned long *)(PORT3_BLOCK + 0x4c)  // Pin Control Register 19
        #define PORTD_PCR20              *(volatile unsigned long *)(PORT3_BLOCK + 0x50)  // Pin Control Register 20
        #define PORTD_PCR21              *(volatile unsigned long *)(PORT3_BLOCK + 0x54)  // Pin Control Register 21
        #define PORTD_PCR22              *(volatile unsigned long *)(PORT3_BLOCK + 0x58)  // Pin Control Register 22
        #define PORTD_PCR23              *(volatile unsigned long *)(PORT3_BLOCK + 0x5c)  // Pin Control Register 23
        #define PORTD_PCR24              *(volatile unsigned long *)(PORT3_BLOCK + 0x60)  // Pin Control Register 24
        #define PORTD_PCR25              *(volatile unsigned long *)(PORT3_BLOCK + 0x64)  // Pin Control Register 25
        #define PORTD_PCR26              *(volatile unsigned long *)(PORT3_BLOCK + 0x68)  // Pin Control Register 26
        #define PORTD_PCR27              *(volatile unsigned long *)(PORT3_BLOCK + 0x6c)  // Pin Control Register 27
        #define PORTD_PCR28              *(volatile unsigned long *)(PORT3_BLOCK + 0x70)  // Pin Control Register 28
        #define PORTD_PCR29              *(volatile unsigned long *)(PORT3_BLOCK + 0x74)  // Pin Control Register 29
        #define PORTD_PCR30              *(volatile unsigned long *)(PORT3_BLOCK + 0x78)  // Pin Control Register 30
        #define PORTD_PCR31              *(volatile unsigned long *)(PORT3_BLOCK + 0x7c)  // Pin Control Register 31
        #define PORTD_GPCLR              *(volatile unsigned long *)(PORT3_BLOCK + 0x80)  // Global Pin Control Low Register (write-only)
        #define PORTD_GPCHR              *(volatile unsigned long *)(PORT3_BLOCK + 0x84)  // Global Pin Control High Register (write-only)
        #define PORTD_ISFR               *(volatile unsigned long *)(PORT3_BLOCK + 0xa0)  // Interrupt Status Flag Register (read-only/write one to clear)
        #define PORTD_DFER               *(unsigned long *)(PORT3_BLOCK + 0xc0)           // Digital Filter Enable Register
        #define PORTD_DFCR               *(unsigned long *)(PORT3_BLOCK + 0xc4)           // Digital Filter Clock Register
        #define PORTD_DFWR               *(unsigned long *)(PORT3_BLOCK + 0xc8)           // Digital Filter Width Register
    #endif
    #if PORTS_AVAILABLE > 4
        #define PORTE_PCR0               *(volatile unsigned long *)(PORT4_BLOCK + 0x00)  // Pin Control Register 0
        #define PORTE_PCR1               *(volatile unsigned long *)(PORT4_BLOCK + 0x04)  // Pin Control Register 1
        #define PORTE_PCR2               *(volatile unsigned long *)(PORT4_BLOCK + 0x08)  // Pin Control Register 2
        #define PORTE_PCR3               *(volatile unsigned long *)(PORT4_BLOCK + 0x0c)  // Pin Control Register 3
        #define PORTE_PCR4               *(volatile unsigned long *)(PORT4_BLOCK + 0x10)  // Pin Control Register 4
        #define PORTE_PCR5               *(volatile unsigned long *)(PORT4_BLOCK + 0x14)  // Pin Control Register 5
        #define PORTE_PCR6               *(volatile unsigned long *)(PORT4_BLOCK + 0x18)  // Pin Control Register 6
        #define PORTE_PCR7               *(volatile unsigned long *)(PORT4_BLOCK + 0x1c)  // Pin Control Register 7
        #define PORTE_PCR8               *(volatile unsigned long *)(PORT4_BLOCK + 0x20)  // Pin Control Register 8
        #define PORTE_PCR9               *(volatile unsigned long *)(PORT4_BLOCK + 0x24)  // Pin Control Register 9
        #define PORTE_PCR10              *(volatile unsigned long *)(PORT4_BLOCK + 0x28)  // Pin Control Register 10
        #define PORTE_PCR11              *(volatile unsigned long *)(PORT4_BLOCK + 0x2c)  // Pin Control Register 11
        #define PORTE_PCR12              *(volatile unsigned long *)(PORT4_BLOCK + 0x30)  // Pin Control Register 12
        #define PORTE_PCR13              *(volatile unsigned long *)(PORT4_BLOCK + 0x34)  // Pin Control Register 13
        #define PORTE_PCR14              *(volatile unsigned long *)(PORT4_BLOCK + 0x38)  // Pin Control Register 14
        #define PORTE_PCR15              *(volatile unsigned long *)(PORT4_BLOCK + 0x3c)  // Pin Control Register 15
        #define PORTE_PCR16              *(volatile unsigned long *)(PORT4_BLOCK + 0x40)  // Pin Control Register 16
        #define PORTE_PCR17              *(volatile unsigned long *)(PORT4_BLOCK + 0x44)  // Pin Control Register 17
        #define PORTE_PCR18              *(volatile unsigned long *)(PORT4_BLOCK + 0x48)  // Pin Control Register 18
        #define PORTE_PCR19              *(volatile unsigned long *)(PORT4_BLOCK + 0x4c)  // Pin Control Register 19
        #define PORTE_PCR20              *(volatile unsigned long *)(PORT4_BLOCK + 0x50)  // Pin Control Register 20
        #define PORTE_PCR21              *(volatile unsigned long *)(PORT4_BLOCK + 0x54)  // Pin Control Register 21
        #define PORTE_PCR22              *(volatile unsigned long *)(PORT4_BLOCK + 0x58)  // Pin Control Register 22
        #define PORTE_PCR23              *(volatile unsigned long *)(PORT4_BLOCK + 0x5c)  // Pin Control Register 23
        #define PORTE_PCR24              *(volatile unsigned long *)(PORT4_BLOCK + 0x60)  // Pin Control Register 24
        #define PORTE_PCR25              *(volatile unsigned long *)(PORT4_BLOCK + 0x64)  // Pin Control Register 25
        #define PORTE_PCR26              *(volatile unsigned long *)(PORT4_BLOCK + 0x68)  // Pin Control Register 26
        #define PORTE_PCR27              *(volatile unsigned long *)(PORT4_BLOCK + 0x6c)  // Pin Control Register 27
        #define PORTE_PCR28              *(volatile unsigned long *)(PORT4_BLOCK + 0x70)  // Pin Control Register 28
        #define PORTE_PCR29              *(volatile unsigned long *)(PORT4_BLOCK + 0x74)  // Pin Control Register 29
        #define PORTE_PCR30              *(volatile unsigned long *)(PORT4_BLOCK + 0x78)  // Pin Control Register 30
        #define PORTE_PCR31              *(volatile unsigned long *)(PORT4_BLOCK + 0x7c)  // Pin Control Register 31
        #define PORTE_GPCLR              *(volatile unsigned long *)(PORT4_BLOCK + 0x80)  // Global Pin Control Low Register (write-only)
        #define PORTE_GPCHR              *(volatile unsigned long *)(PORT4_BLOCK + 0x84)  // Global Pin Control High Register (write-only)
        #define PORTE_ISFR               *(volatile unsigned long *)(PORT4_BLOCK + 0xa0)  // Interrupt Status Flag Register (read-only/write one to clear)
        #define PORTE_DFER               *(unsigned long *)(PORT4_BLOCK + 0xc0)           // Digital Filter Enable Register
        #define PORTE_DFCR               *(unsigned long *)(PORT4_BLOCK + 0xc4)           // Digital Filter Clock Register
        #define PORTE_DFWR               *(unsigned long *)(PORT4_BLOCK + 0xc8)           // Digital Filter Width Register
    #endif
    #if PORTS_AVAILABLE > 5
        #define PORTF_PCR0               *(volatile unsigned long *)(PORT5_BLOCK + 0x00)  // Pin Control Register 0
        #define PORTF_PCR1               *(volatile unsigned long *)(PORT5_BLOCK + 0x04)  // Pin Control Register 1
        #define PORTF_PCR2               *(volatile unsigned long *)(PORT5_BLOCK + 0x08)  // Pin Control Register 2
        #define PORTF_PCR3               *(volatile unsigned long *)(PORT5_BLOCK + 0x0c)  // Pin Control Register 3
        #define PORTF_PCR4               *(volatile unsigned long *)(PORT5_BLOCK + 0x10)  // Pin Control Register 4
        #define PORTF_PCR5               *(volatile unsigned long *)(PORT5_BLOCK + 0x14)  // Pin Control Register 5
        #define PORTF_PCR6               *(volatile unsigned long *)(PORT5_BLOCK + 0x18)  // Pin Control Register 6
        #define PORTF_PCR7               *(volatile unsigned long *)(PORT5_BLOCK + 0x1c)  // Pin Control Register 7
        #define PORTF_PCR8               *(volatile unsigned long *)(PORT5_BLOCK + 0x20)  // Pin Control Register 8
        #define PORTF_PCR9               *(volatile unsigned long *)(PORT5_BLOCK + 0x24)  // Pin Control Register 9
        #define PORTF_PCR10              *(volatile unsigned long *)(PORT5_BLOCK + 0x28)  // Pin Control Register 10
        #define PORTF_PCR11              *(volatile unsigned long *)(PORT5_BLOCK + 0x2c)  // Pin Control Register 11
        #define PORTF_PCR12              *(volatile unsigned long *)(PORT5_BLOCK + 0x30)  // Pin Control Register 12
        #define PORTF_PCR13              *(volatile unsigned long *)(PORT5_BLOCK + 0x34)  // Pin Control Register 13
        #define PORTF_PCR14              *(volatile unsigned long *)(PORT5_BLOCK + 0x38)  // Pin Control Register 14
        #define PORTF_PCR15              *(volatile unsigned long *)(PORT5_BLOCK + 0x3c)  // Pin Control Register 15
        #define PORTF_PCR16              *(volatile unsigned long *)(PORT5_BLOCK + 0x40)  // Pin Control Register 16
        #define PORTF_PCR17              *(volatile unsigned long *)(PORT5_BLOCK + 0x44)  // Pin Control Register 17
        #define PORTF_PCR18              *(volatile unsigned long *)(PORT5_BLOCK + 0x48)  // Pin Control Register 18
        #define PORTF_PCR19              *(volatile unsigned long *)(PORT5_BLOCK + 0x4c)  // Pin Control Register 19
        #define PORTF_PCR20              *(volatile unsigned long *)(PORT5_BLOCK + 0x50)  // Pin Control Register 20
        #define PORTF_PCR21              *(volatile unsigned long *)(PORT5_BLOCK + 0x54)  // Pin Control Register 21
        #define PORTF_PCR22              *(volatile unsigned long *)(PORT5_BLOCK + 0x58)  // Pin Control Register 22
        #define PORTF_PCR23              *(volatile unsigned long *)(PORT5_BLOCK + 0x5c)  // Pin Control Register 23
        #define PORTF_PCR24              *(volatile unsigned long *)(PORT5_BLOCK + 0x60)  // Pin Control Register 24
        #define PORTF_PCR25              *(volatile unsigned long *)(PORT5_BLOCK + 0x64)  // Pin Control Register 25
        #define PORTF_PCR26              *(volatile unsigned long *)(PORT5_BLOCK + 0x68)  // Pin Control Register 26
        #define PORTF_PCR27              *(volatile unsigned long *)(PORT5_BLOCK + 0x6c)  // Pin Control Register 27
        #define PORTF_PCR28              *(volatile unsigned long *)(PORT5_BLOCK + 0x70)  // Pin Control Register 28
        #define PORTF_PCR29              *(volatile unsigned long *)(PORT5_BLOCK + 0x74)  // Pin Control Register 29
        #define PORTF_PCR30              *(volatile unsigned long *)(PORT5_BLOCK + 0x78)  // Pin Control Register 30
        #define PORTF_PCR31              *(volatile unsigned long *)(PORT5_BLOCK + 0x7c)  // Pin Control Register 31
        #define PORTF_GPCLR              *(volatile unsigned long *)(PORT5_BLOCK + 0x80)  // Global Pin Control Low Register (write-only)
        #define PORTF_GPCHR              *(volatile unsigned long *)(PORT5_BLOCK + 0x84)  // Global Pin Control High Register (write-only)
        #define PORTF_ISFR               *(volatile unsigned long *)(PORT5_BLOCK + 0xa0)  // Interrupt Status Flag Register (read-only/write one to clear)
        #define PORTF_DFER               *(unsigned long *)(PORT5_BLOCK + 0xc0)           // Digital Filter Enable Register
        #define PORTF_DFCR               *(unsigned long *)(PORT5_BLOCK + 0xc4)           // Digital Filter Clock Register
        #define PORTF_DFWR               *(unsigned long *)(PORT5_BLOCK + 0xc8)           // Digital Filter Width Register
    #endif
    // Macros for disabling port interrupt and re-arming (or changing sensitivity) {79}
    //
    #define _DIS_ARM_PORT_INTERRUPT(port, bit)       PORT##port##_PCR##bit &= ~(PORT_IRQC_INT_MASK)
    #define _RE_ARM_PORT_INTERRUPT(port, bit, sense) PORT##port##_PCR##bit = ((PORT##port##_PCR##bit & ~(PORT_IRQC_INT_MASK)) | (sense))
#endif

// Port multiplexing peripheral defines
//
#if defined KINETIS_K64
    #define PE_0_TRACE_CLK_OUT           PORT_MUX_ALT5
    #define PE_1_TRACE_D3                PORT_MUX_ALT5
    #define PE_2_TRACE_D2                PORT_MUX_ALT5
    #define PE_3_TRACE_D1                PORT_MUX_ALT5
    #define PE_4_TRACE_D0                PORT_MUX_ALT5
#endif
#if defined KINETIS_K40
    #define PA_9_FB_AD16                 PORT_MUX_ALT5                   // Flex-Bus
    #define PA_10_FB_AD15                PORT_MUX_ALT5
    #define PA_24_FB_AD14                PORT_MUX_ALT5
    #define PA_25_FB_AD13                PORT_MUX_ALT5
    #define PA_26_FB_AD12                PORT_MUX_ALT5
    #define PA_27_FB_AD11                PORT_MUX_ALT5
    #define PA_28_FB_AD10                PORT_MUX_ALT5
    #define PD_10_FB_AD9                 PORT_MUX_ALT5
    #define PD_11_FB_AD8                 PORT_MUX_ALT5
    #define PD_12_FB_AD7                 PORT_MUX_ALT5
    #define PD_13_FB_AD6                 PORT_MUX_ALT5
    #define PD_14_FB_AD5                 PORT_MUX_ALT5
    #define PE_8_FB_AD4                  PORT_MUX_ALT5
    #define PE_9_FB_AD3                  PORT_MUX_ALT5
    #define PE_10_FB_AD2                 PORT_MUX_ALT5
    #define PE_11_FB_AD1                 PORT_MUX_ALT5
    #define PE_12_FB_AD0                 PORT_MUX_ALT5
    #define PE_7_FB_CS0                  PORT_MUX_ALT5
    #define PD_15_FB_RW                  PORT_MUX_ALT5
#else                                                                    // K60
    #define PB_17_FB_AD16                PORT_MUX_ALT5                   // Flex-Bus
    #define PB_18_FB_AD15                PORT_MUX_ALT5
    #define PC_0_FB_AD14                 PORT_MUX_ALT5
    #define PC_1_FB_AD13                 PORT_MUX_ALT5
    #define PC_2_FB_AD12                 PORT_MUX_ALT5
    #define PC_4_FB_AD11                 PORT_MUX_ALT5
    #define PC_5_FB_AD10                 PORT_MUX_ALT5
    #define PC_6_FB_AD9                  PORT_MUX_ALT5
    #define PC_7_FB_AD8                  PORT_MUX_ALT5
    #define PC_8_FB_AD7                  PORT_MUX_ALT5
    #define PC_9_FB_AD6                  PORT_MUX_ALT5
    #define PC_10_FB_AD5                 PORT_MUX_ALT5
    #define PD_2_FB_AD4                  PORT_MUX_ALT5
    #define PD_3_FB_AD3                  PORT_MUX_ALT5
    #define PD_4_FB_AD2                  PORT_MUX_ALT5
    #define PD_5_FB_AD1                  PORT_MUX_ALT5
    #define PD_6_FB_AD0                  PORT_MUX_ALT5
    #define PD_1_FB_CS0                  PORT_MUX_ALT5
    #define PD_0_FB_ALE                  PORT_MUX_ALT5
    #define PD_0_FB_CS1                  PORT_MUX_ALT5
    #define PD_0_FB_TS                   PORT_MUX_ALT5
    #define PC_11_FB_RW                  PORT_MUX_ALT5
    #define PB_19_FB_OE                  PORT_MUX_ALT5                   // {32}
#endif

#define PA_15_MII0_TXEN                  PORT_MUX_ALT4                   // Ethernet
#define PB_0_MII0_MDIO                   PORT_MUX_ALT4
#define PB_1_MII0_MDC                    PORT_MUX_ALT4
#define PA_5_MII0_RXER                   PORT_MUX_ALT4
#define PA_12_MII0_RXD1                  PORT_MUX_ALT4
#define PA_13_MII0_RXD0                  PORT_MUX_ALT4
#define PA_14_RMII0_CRS_DV               PORT_MUX_ALT4
#define PA_15_MII0_TXEN                  PORT_MUX_ALT4
#define PA_16_MII0_TXD0                  PORT_MUX_ALT4
#define PA_17_MII0_TXD1                  PORT_MUX_ALT4
#define PA_9_MII0_RXD3                   PORT_MUX_ALT4
#define PA_10_MII0_RXD2                  PORT_MUX_ALT4
#define PA_11_MII0_RXCLK                 PORT_MUX_ALT4
#define PA_24_MII0_TXD2                  PORT_MUX_ALT4
#define PA_25_MII0_TXCLK                 PORT_MUX_ALT4
#define PA_26_MII0_TXD3                  PORT_MUX_ALT4
#define PA_27_MII0_CRS                   PORT_MUX_ALT4
#define PA_28_MII0_TXER                  PORT_MUX_ALT4
#define PA_29_MII0_COL                   PORT_MUX_ALT4

#if defined KINETIS_K65 || defined KINETIS_K66
    #define PE_26_ENET_1588_CLKIN        PORT_MUX_ALT2
#endif

#define PE_26_USB_CLKIN                  PORT_MUX_ALT7

#if defined KINETIS_KL43 || defined KINETIS_KL26
    #define PC_0_audio_USB_SOF_OUT       PORT_MUX_ALT4
    #define PC_7_audio_USB_SOF_OUT       PORT_MUX_ALT3
#endif
#if defined KINETIS_KL26
    #define PE_6_audio_USB_SOF_OUT       PORT_MUX_ALT5
#endif

#define PA_2_UART0_TX                    PORT_MUX_ALT2                   // UART0
#define PB_17_UART0_TX                   PORT_MUX_ALT3
#define PD_7_UART0_TX                    PORT_MUX_ALT3
#define PA_14_UART0_TX                   PORT_MUX_ALT3
#define PA_1_UART0_RX                    PORT_MUX_ALT2
#define PB_16_UART0_RX                   PORT_MUX_ALT3
#define PD_6_UART0_RX                    PORT_MUX_ALT3
#define PA_15_UART0_RX                   PORT_MUX_ALT3
#define PA_3_UART0_RTS                   PORT_MUX_ALT2
#define PB_2_UART0_RTS                   PORT_MUX_ALT3
#define PD_4_UART0_RTS                   PORT_MUX_ALT3
#define PA_17_UART0_RTS                  PORT_MUX_ALT3
#define PA_0_UART0_CTS                   PORT_MUX_ALT2
#define PB_3_UART0_CTS                   PORT_MUX_ALT3
#define PD_5_UART0_CTS                   PORT_MUX_ALT3
#define PA_16_UART0_CTS                  PORT_MUX_ALT3
#if defined KINETIS_KL
    #if defined KINETIS_KL02 || defined KINETIS_KL03 || defined KINETIS_KL04 || defined KINETIS_KL05
        #define PB_1_UART0_TX            PORT_MUX_ALT2
        #define PB_2_UART0_TX            PORT_MUX_ALT3
        #define PB_3_UART0_TX            PORT_MUX_ALT3
        #if defined KINETIS_KL03
            #define PA_3_UART0_TX        PORT_MUX_ALT4
        #endif
        #define PB_1_UART0_RX            PORT_MUX_ALT3
        #define PB_2_UART0_RX            PORT_MUX_ALT2
        #define PB_4_UART0_RX            PORT_MUX_ALT3
        #if defined KINETIS_KL03
            #define PA_4_UART0_RX        PORT_MUX_ALT4
        #endif
    #else
        #define PE_20_UART0_TX           PORT_MUX_ALT4
        #define PE_21_UART0_RX           PORT_MUX_ALT4
    #endif
    #if defined KINETIS_KL05
        #define PA_5_RTC_CLKIN           PORT_MUX_GPIO                   // GPIO setting used and clock input selected in SIM_SOPT1
    #else
        #define PC_1_RTC_CLKIN           PORT_MUX_GPIO                   // GPIO setting used and clock input selected in SIM_SOPT1
    #endif
#elif defined KINETIS_KE
    #define PA_3_UART0_TX                PORT_MUX_ALT2
    #define PB_1_UART0_TX                PORT_MUX_ALT2
    #define PC_7_UART1_TX                PORT_MUX_ALT2
    #define PD_7_UART2_TX                PORT_MUX_ALT2
    #define PA_2_UART0_RX                PORT_MUX_ALT2
    #define PB_0_UART0_RX                PORT_MUX_ALT2
    #define PC_6_UART1_RX                PORT_MUX_ALT2
    #define PD_6_UART2_RX                PORT_MUX_ALT2
#elif defined KINETIS_KV31
    #define PB_1_UART0_TX                PORT_MUX_ALT7
    #define PB_0_UART0_RX                PORT_MUX_ALT7
#elif defined KINETIS_KV10
    #define PD_1_UART1_TX                PORT_MUX_ALT5
    #define PD_0_UART1_RX                PORT_MUX_ALT5
#endif

#define PC_4_UART1_TX                    PORT_MUX_ALT3                   // UART1
#define PE_0_UART1_TX                    PORT_MUX_ALT3
#define PC_3_UART1_RX                    PORT_MUX_ALT3
#define PE_1_UART1_RX                    PORT_MUX_ALT3
#define PC_1_UART1_RTS                   PORT_MUX_ALT3
#define PE_3_UART1_RTS                   PORT_MUX_ALT3
#define PC_2_UART1_CTS                   PORT_MUX_ALT3
#define PE_2_UART1_CTS                   PORT_MUX_ALT3
#if defined KINETIS_KL
    #define PA_19_UART1_TX               PORT_MUX_ALT3
    #define PA_18_UART1_RX               PORT_MUX_ALT3
#endif

#define PD_3_UART2_TX                    PORT_MUX_ALT3                   // UART2
#define PD_2_UART2_RX                    PORT_MUX_ALT3
#define PD_0_UART2_RTS                   PORT_MUX_ALT3
#define PD_1_UART2_CTS                   PORT_MUX_ALT3
#if defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66
    #define PE_16_UART2_TX               PORT_MUX_ALT3
    #define PE_17_UART2_RX               PORT_MUX_ALT3
#elif (defined KINETIS_K61 || defined KINETIS_K70)                       // {2}{17}
    #define PE_16_UART2_TX               PORT_MUX_ALT3
    #define PF_14_UART2_TX               PORT_MUX_ALT4
    #define PE_17_UART2_RX               PORT_MUX_ALT3
    #define PF_13_UART2_RX               PORT_MUX_ALT4
    #define PE_19_UART2_RTS              PORT_MUX_ALT3
    #define PF_11_UART2_RTS              PORT_MUX_ALT4
    #define PE_18_UART2_CTS              PORT_MUX_ALT3
    #define PF_12_UART2_CTS              PORT_MUX_ALT4
#elif defined KINETIS_K21 || defined KINETIS_KW2X
    #define PE_16_UART2_TX               PORT_MUX_ALT3
    #define PE_17_UART2_RX               PORT_MUX_ALT3
    #define PE_18_UART2_CTS              PORT_MUX_ALT3
    #define PE_19_UART2_RTS              PORT_MUX_ALT3
#elif defined KINETIS_KL                                                 // {42}
    #define PE_16_UART2_TX               PORT_MUX_ALT3
    #define PE_17_UART2_RX               PORT_MUX_ALT3
    #define PE_23_UART2_RX               PORT_MUX_ALT4
    #define PE_4_UART2_RX                PORT_MUX_ALT3
    #define PE_22_UART2_TX               PORT_MUX_ALT4
    #define PE_5_UART2_TX                PORT_MUX_ALT3
#endif

#define PB_11_UART3_TX                   PORT_MUX_ALT3                   // UART3
#define PC_17_UART3_TX                   PORT_MUX_ALT3
#define PE_4_UART3_TX                    PORT_MUX_ALT3
#define PB_10_UART3_RX                   PORT_MUX_ALT3
#define PC_16_UART3_RX                   PORT_MUX_ALT3
#define PE_5_UART3_RX                    PORT_MUX_ALT3
#define PB_8_UART3_RTS                   PORT_MUX_ALT3
#define PC_18_UART3_RTS                  PORT_MUX_ALT3
#define PE_7_UART3_RTS                   PORT_MUX_ALT3
#define PB_9_UART3_CTS                   PORT_MUX_ALT3
#define PC_19_UART3_CTS                  PORT_MUX_ALT3
#define PE_6_UART3_CTS                   PORT_MUX_ALT3
#if (defined KINETIS_K61 || defined KINETIS_K70)                         // {7}{17}
    #define PF_8_UART3_TX                PORT_MUX_ALT4
    #define PF_7_UART3_RX                PORT_MUX_ALT4
    #define PF_9_UART3_RTS               PORT_MUX_ALT4
    #define PF_10_UART3_CTS              PORT_MUX_ALT4
#endif

#define PC_15_UART4_TX                   PORT_MUX_ALT3                   // UART4
#define PE_24_UART4_TX                   PORT_MUX_ALT3
#define PC_14_UART4_RX                   PORT_MUX_ALT3
#define PE_25_UART4_RX                   PORT_MUX_ALT3
#define PC_12_UART4_RTS                  PORT_MUX_ALT3
#define PE_27_UART4_RTS                  PORT_MUX_ALT3
#define PC_13_UART4_CTS                  PORT_MUX_ALT3
#define PE_26_UART4_CTS                  PORT_MUX_ALT3

#define PD_9_UART5_TX                    PORT_MUX_ALT3                   // UART5
#define PE_8_UART5_TX                    PORT_MUX_ALT3
#define PD_8_UART5_RX                    PORT_MUX_ALT3
#define PE_9_UART5_RX                    PORT_MUX_ALT3
#define PD_10_UART5_RTS                  PORT_MUX_ALT3
#define PE_11_UART5_RTS                  PORT_MUX_ALT3
#define PD_11_UART5_CTS                  PORT_MUX_ALT3
#define PE_10_UART5_CTS                  PORT_MUX_ALT3

#if LPUARTS_AVAILABLE > 0
    #if defined KINETIS_KL03
        #define PB_2_LPUART0_RX          PORT_MUX_ALT2
        #define PB_1_LPUART0_TX          PORT_MUX_ALT2
        #define PB_1_LPUART0_RX          PORT_MUX_ALT3
        #define PB_2_LPUART0_TX          PORT_MUX_ALT3
        #define PA_4_LPUART0_RX          PORT_MUX_ALT4
        #define PA_3_LPUART0_TX          PORT_MUX_ALT4
        #define PB_4_LPUART0_RX          PORT_MUX_ALT3
        #define PB_3_LPUART0_TX          PORT_MUX_ALT3
    #elif defined KINETIS_KL43 || defined KINETIS_KL27 || defined KINETIS_KL82 || defined KINETIS_K80
        #if !defined KINETIS_K80
            #define PE_21_LPUART0_RX     PORT_MUX_ALT4
        #endif
        #define PE_20_LPUART0_TX         PORT_MUX_ALT4
        #define PA_1_LPUART0_RX          PORT_MUX_ALT2
        #define PA_2_LPUART0_TX          PORT_MUX_ALT2
        #define PB_16_LPUART0_RX         PORT_MUX_ALT3
        #define PB_17_LPUART0_TX         PORT_MUX_ALT3
        #if defined KINETIS_KL43
            #define PD_6_LPUART0_RX      PORT_MUX_ALT3
            #define PD_7_LPUART0_TX      PORT_MUX_ALT3
        #endif
    #else                                                                // K22, KV31
        #define PC_3_LPUART0_RX          PORT_MUX_ALT7
        #define PC_4_LPUART0_TX          PORT_MUX_ALT7
        #define PE_5_LPUART0_RX          PORT_MUX_ALT3
        #define PE_4_LPUART0_TX          PORT_MUX_ALT3
        #define PB_10_LPUART0_RX         PORT_MUX_ALT3
        #define PB_11_LPUART0_TX         PORT_MUX_ALT3
        #define PD_8_LPUART0_RX          PORT_MUX_ALT5
        #define PD_9_LPUART0_TX          PORT_MUX_ALT5
        #define PD_2_LPUART0_RX          PORT_MUX_ALT6
        #define PD_3_LPUART0_TX          PORT_MUX_ALT6
        #define PC_16_LPUART0_RX         PORT_MUX_ALT3
        #define PC_17_LPUART0_TX         PORT_MUX_ALT3
    #endif
#endif
#if LPUARTS_AVAILABLE > 1
    #if defined KINETIS_KL43 || defined KINETIS_KL27
        #define PC_3_LPUART1_RX          PORT_MUX_ALT3
        #define PC_4_LPUART1_TX          PORT_MUX_ALT3
        #if !defined KINETIS_K80
            #define PA_18_LPUART1_RX     PORT_MUX_ALT3
            #define PA_19_LPUART1_TX     PORT_MUX_ALT3
        #endif
        #define PE_1_LPUART1_RX          PORT_MUX_ALT3
        #define PE_0_LPUART1_TX          PORT_MUX_ALT3
    #endif
#endif
#if LPUARTS_AVAILABLE > 2
    #if defined KINETIS_K80
        #define PE_13_LPUART2_RX         PORT_MUX_ALT3
        #define PE_12_LPUART2_TX         PORT_MUX_ALT3
        #define PE_17_LPUART2_RX         PORT_MUX_ALT3
        #define PE_16_LPUART2_TX         PORT_MUX_ALT3
        #define PD_2_LPUART2_RX          PORT_MUX_ALT3
        #define PD_3_LPUART2_TX          PORT_MUX_ALT3
    #endif
#endif
#if LPUARTS_AVAILABLE > 3
    #if defined KINETIS_K80
        #define PE_3_LPUART3_RX          PORT_MUX_ALT3
        #define PE_4_LPUART3_TX          PORT_MUX_ALT3
        #define PB_10_LPUART3_RX         PORT_MUX_ALT3
        #define PB_11_LPUART3_TX         PORT_MUX_ALT3
        #define PC_16_LPUART3_RX         PORT_MUX_ALT3
        #define PC_17_LPUART3_TX         PORT_MUX_ALT3
    #endif
#endif
#if LPUARTS_AVAILABLE > 4
    #if defined KINETIS_K80
        #define PA_21_LPUART4_RX         PORT_MUX_ALT3
        #define PA_20_LPUART4_TX         PORT_MUX_ALT3
        #define PC_14_LPUART4_RX         PORT_MUX_ALT3
        #define PC_15_LPUART4_TX         PORT_MUX_ALT3
    #endif
#endif

#if defined KINETIS_KL03                                                 // I2C0
    #define PB_1_I2C0_SDA                PORT_MUX_ALT4
    #define PB_0_I2C0_SCL                PORT_MUX_ALT4
#else
    #define PB_1_I2C0_SDA                PORT_MUX_ALT2
    #define PB_0_I2C0_SCL                PORT_MUX_ALT2
#endif
#define PB_3_I2C0_SDA                    PORT_MUX_ALT2
#define PB_2_I2C0_SCL                    PORT_MUX_ALT2
#define PD_9_I2C0_SDA                    PORT_MUX_ALT2
#define PD_8_I2C0_SCL                    PORT_MUX_ALT2
#if defined KINETIS_K64 || defined KINETIS_K24 || defined KINETIS_KL25 || defined KINETIS_KL26 || defined KINETIS_KL27 || defined KINETIS_KL43 || defined KINETIS_KL46
    #define PE_25_I2C0_SDA               PORT_MUX_ALT5
    #define PE_24_I2C0_SCL               PORT_MUX_ALT5
    #if defined KINETIS_KL27
        #define PB_1_I2C0_SDA            PORT_MUX_ALT2
        #define PB_0_I2C0_SCL            PORT_MUX_ALT2
        #define PB_3_I2C0_SDA            PORT_MUX_ALT2
        #define PB_2_I2C0_SCL            PORT_MUX_ALT2
        #define PC_9_I2C0_SDA            PORT_MUX_ALT2
        #define PC_8_I2C0_SCL            PORT_MUX_ALT2
    #endif
#elif (defined KINETIS_K26 || defined KINETIS_K65 || defined KINETIS_K66 ||  defined KINETIS_K70)
    #define PE_18_I2C0_SDA               PORT_MUX_ALT4
    #define PE_19_I2C0_SCL               PORT_MUX_ALT4
#elif defined KINETIS_KE
    #define PA_2_I2C0_SDA                PORT_MUX_ALT3
    #define PA_3_I2C0_SCL                PORT_MUX_ALT3
    #define PB_6_I2C0_SDA                PORT_MUX_ALT2
    #define PB_7_I2C0_SCL                PORT_MUX_ALT2
#elif defined KINETIS_KV10
    #define PC_7_I2C0_SDA                PORT_MUX_ALT7
    #define PC_6_I2C0_SCL                PORT_MUX_ALT7
#elif defined KINETIS_KV30
    #define PD_3_I2C0_SDA                PORT_MUX_ALT7
    #define PD_2_I2C0_SCL                PORT_MUX_ALT7
#elif defined KINETIS_KL02 || defined KINETIS_KL03
    #define PA_9_I2C1_SDA                PORT_MUX_ALT2
    #define PA_8_I2C1_SCL                PORT_MUX_ALT2
    #define PA_3_I2C1_SDA                PORT_MUX_ALT3
    #define PA_4_I2C1_SCL                PORT_MUX_ALT3

    #define PB_4_I2C0_SDA                PORT_MUX_ALT2
    #define PB_3_I2C0_SCL                PORT_MUX_ALT2
#elif defined KINETIS_KL04 || defined KINETIS_KL05
    #define PA_3_I2C0_SCL                PORT_MUX_ALT2
    #define PA_4_I2C0_SDA                PORT_MUX_ALT2
    #define PA_3_I2C0_SDA                PORT_MUX_ALT3
    #define PA_4_I2C0_SCL                PORT_MUX_ALT3

    #define PB_4_I2C0_SDA                PORT_MUX_ALT2
    #define PB_3_I2C0_SCL                PORT_MUX_ALT2
#endif

#if I2C_AVAILABLE > 1
    #if defined KINETIS_KE06                                             // I2C1
        #define PH_3_I2C1_SDA            PORT_MUX_ALT2
        #define PH_4_I2C1_SCL            PORT_MUX_ALT2
        #define PE_0_I2C1_SDA            PORT_MUX_ALT4
        #define PE_1_I2C1_SCL            PORT_MUX_ALT4
    #elif defined KINETIS_KL27
        #define PA_4_I2C1_SDA            PORT_MUX_ALT2
        #define PA_3_I2C1_SCL            PORT_MUX_ALT2
        #define PC_1_I2C1_SDA            PORT_MUX_ALT2
        #define PC_2_I2C1_SCL            PORT_MUX_ALT2
        #define PD_6_I2C1_SDA            PORT_MUX_ALT4
        #define PD_7_I2C1_SCL            PORT_MUX_ALT4
        #define PE_0_I2C1_SDA            PORT_MUX_ALT6
        #define PE_1_I2C1_SCL            PORT_MUX_ALT6
        #define PE_25_I2C1_SDA           PORT_MUX_ALT5
        #define PE_24_I2C1_SCL           PORT_MUX_ALT5
    #else
        #define PE_0_I2C1_SDA            PORT_MUX_ALT6
        #define PE_1_I2C1_SCL            PORT_MUX_ALT6
    #endif
    #define PC_11_I2C1_SDA               PORT_MUX_ALT2
    #define PC_10_I2C1_SCL               PORT_MUX_ALT2
#endif

#if I2C_AVAILABLE > 2
    #if defined KINETIS_K80
        #define PA_7_I2C2_SDA            PORT_MUX_ALT2
        #define PA_6_I2C2_SCL            PORT_MUX_ALT2
        #define PA_10_I2C2_SDA           PORT_MUX_ALT2
        #define PA_11_I2C2_SCL           PORT_MUX_ALT2
        #define PB_10_I2C2_SDA           PORT_MUX_ALT4
        #define PB_11_I2C2_SCL           PORT_MUX_ALT4
    #else
        #define PA_11_I2C2_SDA           PORT_MUX_ALT5
        #define PA_12_I2C2_SCL           PORT_MUX_ALT5
    #endif
    #define PA_13_I2C2_SDA               PORT_MUX_ALT5
    #define PA_14_I2C2_SCL               PORT_MUX_ALT5
#endif

#if I2C_AVAILABLE > 3
    #define PA_1_I2C3_SDA                PORT_MUX_ALT4
    #define PA_2_I2C3_SCL                PORT_MUX_ALT4
    #define PE_10_I2C3_SDA               PORT_MUX_ALT2
    #define PE_11_I2C3_SCL               PORT_MUX_ALT2
#endif

#if defined KINETIS_K80
    #define PE_0_QSPI0A_DATA3            PORT_MUX_ALT5
    #define PE_1_QSPI0A_SCLK             PORT_MUX_ALT5
    #define PE_2_QSPI0A_DATA0            PORT_MUX_ALT5
    #define PE_3_QSPI0A_DATA2            PORT_MUX_ALT5
    #define PE_4_QSPI0A_DATA1            PORT_MUX_ALT5
    #define PE_5_QSPI0A_SS0_B            PORT_MUX_ALT5
    #define PE_6_QSPI0B_DATA3            PORT_MUX_ALT5
    #define PE_7_QSPI0B_SCLK             PORT_MUX_ALT5
    #define PE_7_QSPI0A_SS1_B            PORT_MUX_ALT7
    #define PE_8_QSPI0B_DATA0            PORT_MUX_ALT5
    #define PE_9_QSPI0B_DATA2            PORT_MUX_ALT5
    #define PE_10_QSPI0B_DATA1           PORT_MUX_ALT5
    #define PE_11_QSPI0B_SS0_B           PORT_MUX_ALT5
    #define PE_11_QSPI0A_DQS             PORT_MUX_ALT7
    #define PE_12_QSPI0B_DQS             PORT_MUX_ALT5
    #define PE_13_QSPI0B_SS1_B           PORT_MUX_ALT5
#endif

#define PA_15_SPI0_SCK                   PORT_MUX_ALT2                   // SPI0
#define PC_5_SPI0_SCK                    PORT_MUX_ALT2
#define PD_1_SPI0_SCK                    PORT_MUX_ALT2
#define PA_16_SPI0_SOUT                  PORT_MUX_ALT2
#define PC_6_SPI0_SOUT                   PORT_MUX_ALT2
#define PD_2_SPI0_SOUT                   PORT_MUX_ALT2
#define PD_2_SPI0_MOSI                   PD_2_SPI0_SOUT
#define PA_17_SPI0_SIN                   PORT_MUX_ALT2
#define PC_7_SPI0_SIN                    PORT_MUX_ALT2
#define PD_3_SPI0_SIN                    PORT_MUX_ALT2
#define PD_3_SPI0_MISO                   PD_3_SPI0_SIN
#define PA_14_SPI0_PCS0                  PORT_MUX_ALT2
#define PC_4_SPI0_PCS0                   PORT_MUX_ALT2
#define PD_0_SPI0_PCS0                   PORT_MUX_ALT2
#define PC_3_SPI0_PCS1                   PORT_MUX_ALT2
#define PD_4_SPI0_PCS1                   PORT_MUX_ALT2
#define PC_2_SPI0_PCS2                   PORT_MUX_ALT2
#define PD_5_SPI0_PCS2                   PORT_MUX_ALT2
#define PC_1_SPI0_PCS3                   PORT_MUX_ALT2
#define PD_6_SPI0_PCS3                   PORT_MUX_ALT2
#define PC_0_SPI0_PCS4                   PORT_MUX_ALT2
#define PB_23_SPI0_PCS5                  PORT_MUX_ALT3

#if defined KINETIS_KL46 || defined KINETIS_KL43 || defined KINETIS_KL17 || defined KINETIS_KL26 || defined KINETIS_KL27
    #define PD_2_SPI0_MISO               PORT_MUX_ALT5
    #define PD_3_SPI0_MOSI               PORT_MUX_ALT5
    #define PC_6_SPI0_MOSI               PORT_MUX_ALT2
    #define PC_6_SPI0_MISO               PORT_MUX_ALT5
    #define PC_7_SPI0_MISO               PORT_MUX_ALT2
    #define PC_7_SPI0_MOSI               PORT_MUX_ALT5
#elif defined KINETIS_KL03
    #define PB_0_SPI0_SCK                PORT_MUX_ALT3
    #define PA_7_SPI0_MOSI               PORT_MUX_ALT3
    #define PA_6_SPI0_MISO               PORT_MUX_ALT3
#endif
                                                                         // SPI1
#if defined KINETIS_KE
    #define PB_5_SPI0_PCS0               PORT_MUX_ALT2
    #define PE_3_SPI0_PCS0               PORT_MUX_ALT2
    #define PD_3_SPI1_PCS0               PORT_MUX_ALT2
    #define PD_2_SPI1_MISO               PORT_MUX_ALT2
    #define PD_1_SPI1_MOSI               PORT_MUX_ALT3
    #define PD_0_SPI1_SCK                PORT_MUX_ALT3
    #define PE_0_SPI0_SCK                PORT_MUX_ALT2
    #define PB_4_SPI0_MISO               PORT_MUX_ALT2
    #define PE_2_SPI0_MISO               PORT_MUX_ALT2
    #define PB_3_SPI0_MOSI               PORT_MUX_ALT2
    #define PE_1_SPI0_MOSI               PORT_MUX_ALT2
    #define PB_2_SPI0_SCK                PORT_MUX_ALT3
#else
    #define PB_11_SPI1_SCK               PORT_MUX_ALT2
    #define PE_2_SPI1_SCK                PORT_MUX_ALT2
    #if defined KINETIS_K64
        #define PD_5_SPI1_SCK            PORT_MUX_ALT7
    #else
        #define PD_5_SPI1_SCK            PORT_MUX_ALT2
    #endif
    #define PB_16_SPI1_SOUT              PORT_MUX_ALT2
    #define PE_1_SPI1_SOUT               PORT_MUX_ALT2
    #define PE_1_SPI1_MOSI               PE_1_SPI1_SOUT
    #define PD_6_SPI1_MOSI               PORT_MUX_ALT2
    #define PD_6_SPI1_SOUT               PORT_MUX_ALT7
    #define PE_3_SPI1_SOUT               PORT_MUX_ALT7                   // {30} only newer parts
    #define PE_1_SPI1_SIN                PORT_MUX_ALT7                   // {30} only newer parts
    #define PD_4_SPI1_PCS0               PORT_MUX_ALT7
    #define PB_17_SPI1_SIN               PORT_MUX_ALT2
    #define PD_7_SPI1_MISO               PORT_MUX_ALT2
    #define PD_7_SPI1_SIN                PORT_MUX_ALT7
    #define PE_3_SPI1_SIN                PORT_MUX_ALT2
    #define PE_3_SPI1_MISO               PE_3_SPI1_SIN
    #define PB_10_SPI1_PCS0              PORT_MUX_ALT2
    #define PE_4_SPI1_PCS0               PORT_MUX_ALT2
    #define PB_9_SPI1_PCS1               PORT_MUX_ALT2
    #define PE_0_SPI1_PCS1               PORT_MUX_ALT2
    #define PE_5_SPI1_PCS2               PORT_MUX_ALT2
    #define PE_6_SPI1_PCS3               PORT_MUX_ALT2
    #if defined KINETIS_KL43 || defined KINETIS_KL27
        #define PE_0_SPI1_MISO           PORT_MUX_ALT2
        #define PE_1_SPI1_MISO           PORT_MUX_ALT5
        #define PB_16_SPI1_MOSI          PORT_MUX_ALT2
        #define PB_16_SPI1_MISO          PORT_MUX_ALT5
        #define PB_17_SPI1_MISO          PORT_MUX_ALT2
        #define PB_17_SPI1_MOSI          PORT_MUX_ALT5
        #define PC_3_SPI1_SCK            PORT_MUX_ALT2
        #define PD_4_SPI1_SS             PORT_MUX_ALT2
        #define PD_6_SPI1_MISO           PORT_MUX_ALT5
        #define PD_7_SPI1_MOSI           PORT_MUX_ALT5
    #endif
#endif


#define PB_21_SPI2_SCK                   PORT_MUX_ALT2                   // SPI2
#define PD_12_SPI2_SCK                   PORT_MUX_ALT2
#define PB_22_SPI2_SOUT                  PORT_MUX_ALT2
#define PD_13_SPI2_SOUT                  PORT_MUX_ALT2
#define PB_23_SPI2_SIN                   PORT_MUX_ALT2
#define PD_14_SPI2_SIN                   PORT_MUX_ALT2
#define PB_20_SPI2_PCS0                  PORT_MUX_ALT2
#define PD_11_SPI2_PCS0                  PORT_MUX_ALT2
#define PD_15_SPI2_PCS1                  PORT_MUX_ALT2

#define PE_2_SDHC0_DCLK                  PORT_MUX_ALT4                   // SDHC
#define PE_3_SDHC0_CMD                   PORT_MUX_ALT4
#define PE_1_SDHC0_D0                    PORT_MUX_ALT4
#define PE_0_SDHC0_D1                    PORT_MUX_ALT4
#define PE_5_SDHC0_D2                    PORT_MUX_ALT4
#define PE_4_SDHC0_D3                    PORT_MUX_ALT4

#if defined MSCAN_CAN_INTERFACE                                          // MSCAN
    #define PE_7_CAN0_TX                 PORT_MUX_ALT5
    #define PH_2_CAN0_RX                 PORT_MUX_ALT5
    #define PC_7_CAN0_TX                 PORT_MUX_ALT5
    #define PC_6_CAN0_RX                 PORT_MUX_ALT5
#else
    #define PA_12_CAN0_TX                PORT_MUX_ALT2                   // FlexCAN
    #define PA_13_CAN0_RX                PORT_MUX_ALT2
    #define PB_18_CAN0_TX                PORT_MUX_ALT2
    #define PB_19_CAN0_RX                PORT_MUX_ALT2
    #define PC_17_CAN1_TX                PORT_MUX_ALT2
    #define PC_16_CAN1_RX                PORT_MUX_ALT2
    #define PE_24_CAN1_TX                PORT_MUX_ALT2
    #define PE_25_CAN1_RX                PORT_MUX_ALT2
#endif

#define PF_0_GLCD_PCLK                   PORT_MUX_ALT7                   // {60} LCD
#define PF_1_GLCD_DE                     PORT_MUX_ALT7
#define PF_2_GLCD_HFS                    PORT_MUX_ALT7
#define PF_3_GLCD_VFS                    PORT_MUX_ALT7
#define PF_4_GLCD_D0                     PORT_MUX_ALT7
#define PF_5_GLCD_D1                     PORT_MUX_ALT7
#define PF_6_GLCD_D2                     PORT_MUX_ALT7
#define PF_7_GLCD_D3                     PORT_MUX_ALT7
#define PF_8_GLCD_D4                     PORT_MUX_ALT7
#define PF_9_GLCD_D5                     PORT_MUX_ALT7
#define PF_10_GLCD_D6                    PORT_MUX_ALT7
#define PF_11_GLCD_D7                    PORT_MUX_ALT7
#define PF_12_GLCD_D8                    PORT_MUX_ALT7
#define PF_13_GLCD_D9                    PORT_MUX_ALT7
#define PF_14_GLCD_D10                   PORT_MUX_ALT7
#define PF_15_GLCD_D11                   PORT_MUX_ALT7
#define PF_16_GLCD_D12                   PORT_MUX_ALT5
#define PF_17_GLCD_D13                   PORT_MUX_ALT5
#define PF_18_GLCD_D14                   PORT_MUX_ALT5
#define PF_19_GLCD_D15                   PORT_MUX_ALT5
#define PF_20_GLCD_D16                   PORT_MUX_ALT5
#define PF_21_GLCD_D17                   PORT_MUX_ALT7
#define PF_22_GLCD_D18                   PORT_MUX_ALT7
#define PF_23_GLCD_D19                   PORT_MUX_ALT7
#define PF_24_GLCD_D20                   PORT_MUX_ALT7
#define PF_25_GLCD_D21                   PORT_MUX_ALT7
#define PF_26_GLCD_D22                   PORT_MUX_ALT7
#define PF_27_GLCD_D23                   PORT_MUX_ALT7
#define PD_11_GLCD_GLCD_CONTRAST         PORT_MUX_ALT7
                                                                         // FlexTimer 0
#if defined KINETIS_KE
    #define PB_2_FTM0_CH0                PORT_MUX_ALT3
    #define PA_0_FTM0_CH0                PORT_MUX_ALT2
    #define PB_3_FTM0_CH1                PORT_MUX_ALT3
    #define PA_1_FTM0_CH1                PORT_MUX_ALT2
    #define PH_2_FTM1_CH0                PORT_MUX_ALT4
    #if defined KINETIS_KE06
        #define PC_4_FTM1_CH0            PORT_MUX_ALT3
        #define PC_5_FTM1_CH1            PORT_MUX_ALT3
        #define PF_0_FTM2_CH0            PORT_MUX_ALT2
        #define PG_4_FTM2_CH2            PORT_MUX_ALT2
        #define PG_5_FTM2_CH3            PORT_MUX_ALT2
        #define PF_1_FTM2_CH1            PORT_MUX_ALT2
        #define PG_6_FTM2_CH4            PORT_MUX_ALT2
        #define PG_7_FTM2_CH5            PORT_MUX_ALT2
    #else
        #define PC_4_FTM1_CH0            PORT_MUX_ALT2
        #define PC_5_FTM1_CH1            PORT_MUX_ALT2
    #endif
    #define PE_7_FTM1_CH1                PORT_MUX_ALT4
    #define PH_0_FTM2_CH0                PORT_MUX_ALT2
    #define PC_0_FTM2_CH0                PORT_MUX_ALT2
    #define PH_1_FTM2_CH1                PORT_MUX_ALT2
    #define PC_1_FTM2_CH1                PORT_MUX_ALT2
    #define PD_0_FTM2_CH2                PORT_MUX_ALT2
    #define PC_2_FTM2_CH2                PORT_MUX_ALT1
    #define PD_1_FTM2_CH3                PORT_MUX_ALT2
    #define PC_3_FTM2_CH3                PORT_MUX_ALT1
    #define PB_4_FTM2_CH4                PORT_MUX_ALT1
    #define PB_5_FTM2_CH5                PORT_MUX_ALT1
#else
    #define PC_1_FTM0_CH0                PORT_MUX_ALT4
    #define PA_3_FTM0_CH0                PORT_MUX_ALT3
    #define PC_2_FTM0_CH1                PORT_MUX_ALT4
    #define PA_4_FTM0_CH1                PORT_MUX_ALT3
    #define PC_3_FTM0_CH2                PORT_MUX_ALT4
    #define PA_5_FTM0_CH2                PORT_MUX_ALT3
    #define PC_4_FTM0_CH3                PORT_MUX_ALT4
    #define PA_6_FTM0_CH3                PORT_MUX_ALT3
    #define PD_4_FTM0_CH4                PORT_MUX_ALT4
    #define PA_7_FTM0_CH4                PORT_MUX_ALT3
    #define PD_5_FTM0_CH5                PORT_MUX_ALT4
    #define PA_0_FTM0_CH5                PORT_MUX_ALT3
    #define PD_6_FTM0_CH6                PORT_MUX_ALT4
    #define PA_1_FTM0_CH6                PORT_MUX_ALT3
    #define PD_7_FTM0_CH7                PORT_MUX_ALT4
    #define PA_6_FTM0_CH7                PORT_MUX_ALT3
#endif

#if defined KINETIS_KL02                                                 // TPM0
    #define PA_6_TPM0_CH0                PORT_MUX_ALT2
    #define PA_5_TPM0_CH1                PORT_MUX_ALT2
    #define PB_7_TPM1_CH0                PORT_MUX_ALT2
    #define PB_6_TPM1_CH0                PORT_MUX_ALT2
#endif
#if defined KINETIS_KL25 || defined KINETIS_KL26 || defined KINETIS_KL27 || defined KINETIS_KL43
    #define PD_0_FTM0_CH0                PORT_MUX_ALT4
    #define PD_1_FTM0_CH1                PORT_MUX_ALT4
    #define PD_2_FTM0_CH2                PORT_MUX_ALT4
    #define PD_3_FTM0_CH3                PORT_MUX_ALT4
    #define PE_24_TPM0_CH0               PORT_MUX_ALT3
    #define PE_25_TPM0_CH1               PORT_MUX_ALT3
    #define PE_29_TPM0_CH2               PORT_MUX_ALT3
    #define PE_30_TPM0_CH3               PORT_MUX_ALT3
    #define PE_31_TPM0_CH4               PORT_MUX_ALT3
    #define PE_26_TPM0_CH5               PORT_MUX_ALT3
    #define PE_20_TPM1_CH0               PORT_MUX_ALT3
    #define PE_21_TPM1_CH1               PORT_MUX_ALT3
    #define PE_22_TPM2_CH0               PORT_MUX_ALT3
    #define PE_23_TPM2_CH1               PORT_MUX_ALT3
#endif
    #define PE_29_TPM_CLKIN0             PORT_MUX_ALT4
    #define PE_30_TPM_CLKIN1             PORT_MUX_ALT4
#if defined KINETIS_KL02 || defined KINETIS_KL03 || defined KINETIS_KL04 || defined KINETIS_KL05
    #define PB_11_TPM0_CH0               PORT_MUX_ALT2
    #define PB_10_TPM0_CH1               PORT_MUX_ALT2
    #define PB_9_TPM0_CH2                PORT_MUX_ALT2
    #define PB_8_TPM0_CH3                PORT_MUX_ALT2
    #define PA_6_TPM0_CH4                PORT_MUX_ALT2
    #define PA_5_TPM0_CH5                PORT_MUX_ALT2
    #define PA_1_TPM_CLKIN0              PORT_MUX_ALT2
    #define PA_12_TPM_CLKIN0             PORT_MUX_ALT3
    #define PB_6_TPM_CLKIN1              PORT_MUX_ALT3
#endif

#define PB_0_FTM1_CH0                    PORT_MUX_ALT3                   // FlexTimer 1
#define PA_12_FTM1_CH0                   PORT_MUX_ALT3
#define PA_8_FTM1_CH0                    PORT_MUX_ALT3
#define PB_1_FTM1_CH1                    PORT_MUX_ALT3
#define PA_13_FTM1_CH1                   PORT_MUX_ALT3
#define PA_9_FTM1_CH1                    PORT_MUX_ALT3

#if defined KINETIS_KL02 || defined KINETIS_KL03 || defined KINETIS_KL04 || defined KINETIS_KL05 // TPM1
    #define PA_0_TPM1_CH0                PORT_MUX_ALT2
    #define PA_12_TPM1_CH0               PORT_MUX_ALT2
    #define PB_5_TPM1_CH1                PORT_MUX_ALT2
    #define PB_13_TPM1_CH1               PORT_MUX_ALT2
#endif

#define PB_18_FTM2_CH0                   PORT_MUX_ALT3                   // FlexTimer 2
#define PA_10_FTM2_CH0                   PORT_MUX_ALT3
#define PB_19_FTM2_CH1                   PORT_MUX_ALT3
#define PA_11_FTM2_CH1                   PORT_MUX_ALT3
#if defined KINETIS_KL25 || defined KINETIS_KL26 || defined KINETIS_KL27
    #define PB_2_FTM2_CH0                PORT_MUX_ALT3
    #define PB_3_FTM2_CH1                PORT_MUX_ALT3
#endif

#define PE_5_FTM3_CH0                    PORT_MUX_ALT6                   // FlexTimer 3
#define PD_0_FTM3_CH0                    PORT_MUX_ALT4
#define PE_6_FTM3_CH1                    PORT_MUX_ALT6
#define PD_1_FTM3_CH1                    PORT_MUX_ALT4
#define PE_7_FTM3_CH2                    PORT_MUX_ALT6
#define PD_2_FTM3_CH2                    PORT_MUX_ALT4
#define PE_8_FTM3_CH3                    PORT_MUX_ALT6
#define PD_3_FTM3_CH3                    PORT_MUX_ALT4
#define PE_9_FTM3_CH4                    PORT_MUX_ALT6
#define PC_8_FTM3_CH4                    PORT_MUX_ALT3
#define PE_10_FTM3_CH5                   PORT_MUX_ALT6
#define PC_9_FTM3_CH5                    PORT_MUX_ALT3
#define PE_11_FTM3_CH6                   PORT_MUX_ALT6
#define PC_10_FTM3_CH6                   PORT_MUX_ALT3
#define PE_5_FTM3_CH7                    PORT_MUX_ALT6
#define PC_11_FTM3_CH7                   PORT_MUX_ALT3

#if defined KINETIS_K66
    #define PB_0_TPM1_CH0                PORT_MUX_ALT6
    #define PA_12_TPM1_CH0               PORT_MUX_ALT7
    #define PA_8_TPM1_CH0                PORT_MUX_ALT6
    #define PB_1_TPM1_CH1                PORT_MUX_ALT6
    #define PA_13_TPM1_CH1               PORT_MUX_ALT7
    #define PA_9_TPM1_CH1                PORT_MUX_ALT6
    #define PB_18_TPM2_CH0               PORT_MUX_ALT6
    #define PA_10_TPM2_CH0               PORT_MUX_ALT6
    #define PB_19_TPM2_CH1               PORT_MUX_ALT6
    #define PA_11_TPM2_CH1               PORT_MUX_ALT6
#endif

#define PA_18_FTM_CLKIN0                 PORT_MUX_ALT4
#define PA_19_FTM_CLKIN1                 PORT_MUX_ALT4

#define PB_16_FTM_CLKIN0                 PORT_MUX_ALT4
#if defined KINETIS_K66
    #define PC_12_FTM_CLKIN0             PORT_MUX_ALT4
    #define PA_18_TPM_CLKIN0             PORT_MUX_ALT7
    #define PB_16_TPM_CLKIN0             PORT_MUX_ALT7
    #define PC_12_TPM_CLKIN0             PORT_MUX_ALT7
    #define PA_19_TPM_CLKIN1             PORT_MUX_ALT7
    #define PB_17_TPM_CLKIN1             PORT_MUX_ALT7
    #define PC_13_TPM_CLKIN1             PORT_MUX_ALT7
#endif

#if defined KINETIS_KL02 || defined KINETIS_KL04 || defined KINETIS_KL05 // TPM
    #if defined KINETIS_KL02
        #define PA_12_TPM_CLKIN0         PORT_MUX_ALT3
        #define PB_6_TPM_CLKIN1          PORT_MUX_ALT3
    #endif
    #define PB_17_TPM_CLKIN1             PORT_MUX_ALT2
    #define PA_1_TPM_CLKIN0              PORT_MUX_ALT2
#endif

#if defined KINETIS_KE                                                   // KBI
    #define PA_0_KBI0_P0                 PORT_MUX_ALT1
    #define PA_1_KBI0_P1                 PORT_MUX_ALT1
    #define PA_2_KBI0_P2                 PORT_MUX_ALT1
    #define PA_3_KBI0_P3                 PORT_MUX_ALT1
    #if defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define PA_4_KBI0_P4             PORT_MUX_ALT1
        #define PA_5_KBI0_P5             PORT_MUX_ALT1
        #define PA_6_KBI0_P6             PORT_MUX_ALT1
        #define PA_7_KBI0_P7             PORT_MUX_ALT1
        #define PB_0_KBI0_P8             PORT_MUX_ALT1
        #define PB_1_KBI0_P9             PORT_MUX_ALT1
        #define PB_2_KBI0_P10            PORT_MUX_ALT1
        #define PB_3_KBI0_P11            PORT_MUX_ALT1
        #define PB_4_KBI0_P12            PORT_MUX_ALT1
        #define PB_5_KBI0_P13            PORT_MUX_ALT1
        #define PB_6_KBI0_P14            PORT_MUX_ALT1
        #define PB_7_KBI0_P15            PORT_MUX_ALT1
        #define PC_0_KBI0_P16            PORT_MUX_ALT1
        #define PC_1_KBI0_P17            PORT_MUX_ALT1
        #define PC_2_KBI0_P18            PORT_MUX_ALT1
        #define PC_3_KBI0_P19            PORT_MUX_ALT1
        #define PC_4_KBI0_P20            PORT_MUX_ALT1
        #define PC_5_KBI0_P21            PORT_MUX_ALT1
        #define PC_6_KBI0_P22            PORT_MUX_ALT1
        #define PC_7_KBI0_P23            PORT_MUX_ALT1
        #define PD_0_KBI0_P24            PORT_MUX_ALT1
        #define PD_1_KBI0_P25            PORT_MUX_ALT1
        #define PD_2_KBI0_P26            PORT_MUX_ALT1
        #define PD_3_KBI0_P27            PORT_MUX_ALT1
        #define PD_4_KBI0_P28            PORT_MUX_ALT1
        #define PD_5_KBI0_P29            PORT_MUX_ALT1
        #define PD_6_KBI0_P30            PORT_MUX_ALT1
        #define PD_7_KBI0_P31            PORT_MUX_ALT1
        #define PE_0_KBI1_P0             PORT_MUX_ALT1
        #define PE_1_KBI1_P1             PORT_MUX_ALT1
        #define PE_2_KBI1_P2             PORT_MUX_ALT1
        #define PE_3_KBI1_P3             PORT_MUX_ALT1
        #define PE_4_KBI1_P4             PORT_MUX_ALT1
        #define PE_5_KBI1_P5             PORT_MUX_ALT1
        #define PE_6_KBI1_P6             PORT_MUX_ALT1
        #define PE_7_KBI1_P7             PORT_MUX_ALT1
        #define PF_0_KBI1_P8             PORT_MUX_ALT1
        #define PF_1_KBI1_P9             PORT_MUX_ALT1
        #define PF_2_KBI1_P10            PORT_MUX_ALT1
        #define PF_3_KBI1_P11            PORT_MUX_ALT1
        #define PF_4_KBI1_P12            PORT_MUX_ALT1
        #define PF_5_KBI1_P13            PORT_MUX_ALT1
        #define PF_6_KBI1_P14            PORT_MUX_ALT1
        #define PF_7_KBI1_P15            PORT_MUX_ALT1
        #define PG_0_KBI1_P16            PORT_MUX_ALT1
        #define PG_1_KBI1_P17            PORT_MUX_ALT1
        #define PG_2_KBI1_P18            PORT_MUX_ALT1
        #define PG_3_KBI1_P19            PORT_MUX_ALT1
        #define PG_4_KBI1_P20            PORT_MUX_ALT1
        #define PG_5_KBI1_P21            PORT_MUX_ALT1
        #define PG_6_KBI1_P22            PORT_MUX_ALT1
        #define PG_7_KBI1_P23            PORT_MUX_ALT1
        #define PH_0_KBI1_P24            PORT_MUX_ALT1
        #define PH_1_KBI1_P25            PORT_MUX_ALT1
        #define PH_2_KBI1_P26            PORT_MUX_ALT1
        #define PH_3_KBI1_P27            PORT_MUX_ALT1
        #define PH_4_KBI1_P28            PORT_MUX_ALT1
        #define PH_5_KBI1_P29            PORT_MUX_ALT1
        #define PH_6_KBI1_P30            PORT_MUX_ALT1
        #define PH_7_KBI1_P31            PORT_MUX_ALT1
    #else
        #define PB_0_KBI0_P4             PORT_MUX_ALT1
        #define PB_1_KBI0_P5             PORT_MUX_ALT1
        #define PB_2_KBI0_P6             PORT_MUX_ALT1
        #define PB_3_KBI0_P7             PORT_MUX_ALT1
        #define PD_0_KBI1_P0             PORT_MUX_ALT1
        #define PD_1_KBI1_P1             PORT_MUX_ALT1
        #define PD_2_KBI1_P2             PORT_MUX_ALT1
        #define PD_3_KBI1_P3             PORT_MUX_ALT1
        #define PD_4_KBI1_P4             PORT_MUX_ALT1
        #define PD_5_KBI1_P5             PORT_MUX_ALT1
        #define PD_6_KBI1_P6             PORT_MUX_ALT1
        #define PD_7_KBI1_P7             PORT_MUX_ALT1
    #endif
#endif

#define PB_0_TSI_CH0                     PORT_MUX_ANALOG                 // TSI
#define PA_0_TSI_CH1                     PORT_MUX_ANALOG
#define PA_1_TSI_CH2                     PORT_MUX_ANALOG
#define PA_2_TSI_CH3                     PORT_MUX_ANALOG
#define PA_4_TSI_CH5                     PORT_MUX_ANALOG
#define PB_1_TSI_CH6                     PORT_MUX_ANALOG
#define PB_2_TSI_CH7                     PORT_MUX_ANALOG
#define PB_3_TSI_CH8                     PORT_MUX_ANALOG
#define PB_16_TSI_CH9                    PORT_MUX_ANALOG
#define PB_17_TSI_CH10                   PORT_MUX_ANALOG
#define PB_18_TSI_CH11                   PORT_MUX_ANALOG
#define PB_19_TSI_CH12                   PORT_MUX_ANALOG
#define PC_0_TSI_CH13                    PORT_MUX_ANALOG
#define PC_1_TSI_CH14                    PORT_MUX_ANALOG
#define PC_2_TSI_CH15                    PORT_MUX_ANALOG


#define PC_16_NFC_RB                     PORT_MUX_ALT6
#define PC_17_NFC_CE0                    PORT_MUX_ALT6
#define PC_11_NFC_WE                     PORT_MUX_ALT5
#define PD_10_NFC_RE                     PORT_MUX_ALT6
#define PD_8_NFC_CLE                     PORT_MUX_ALT6
#define PD_9_NFC_ALE                     PORT_MUX_ALT6
#define PD_5_NFC_NFC_DATA0               PORT_MUX_ALT5
#define PD_4_NFC_NFC_DATA1               PORT_MUX_ALT5
#define PC_10_NFC_NFC_DATA2              PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA3               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA4               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA5               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA6               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA7               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA8               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA9               PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA10              PORT_MUX_ALT5
#define PC_5_NFC_NFC_DATA11              PORT_MUX_ALT5
#define PB_5_NFC_NFC_DATA12              PORT_MUX_ALT5
#define PB_5_NFC_NFC_DATA13              PORT_MUX_ALT5
#define PB_5_NFC_NFC_DATA14              PORT_MUX_ALT5
#define PB_5_NFC_NFC_DATA15              PORT_MUX_ALT5

#define PA_7_ULPI_DIR                    PORT_MUX_ALT2                   // {25} ULPI
#define PA_8_ULPI_NXT                    PORT_MUX_ALT2
#define PA_10_ULPI_DATA0                 PORT_MUX_ALT2
#define PA_11_ULPI_DATA1                 PORT_MUX_ALT2
#define PA_24_ULPI_DATA2                 PORT_MUX_ALT2
#define PA_25_ULPI_DATA3                 PORT_MUX_ALT2
#define PA_26_ULPI_DATA4                 PORT_MUX_ALT2
#define PA_27_ULPI_DATA5                 PORT_MUX_ALT2
#define PA_28_ULPI_DATA6                 PORT_MUX_ALT2
#define PA_29_ULPI_DATA7                 PORT_MUX_ALT2
#define PA_6_ULPI_CLK                    PORT_MUX_ALT2
#define PA_9_ULPI_STP                    PORT_MUX_ALT2

#if defined KINETIS_KE
    #if (defined KINETIS_KE04 && (SIZE_OF_FLASH > (8 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
        #define PB_6_XTAL                PORT_MUX_ALT6
        #define PB_7_EXTAL               PORT_MUX_ALT6
        #define PC_4_SWD_CLK             PORT_MUX_ALT5
        #define PI_0_IRQ                 PORT_MUX_ALT2
        #define PI_1_IRQ                 PORT_MUX_ALT2
        #define PI_2_IRQ                 PORT_MUX_ALT1
        #define PI_3_IRQ                 PORT_MUX_ALT1
        #define PI_4_IRQ                 PORT_MUX_ALT2
        #define PI_5_IRQ                 PORT_MUX_ALT1
        #define PI_6_IRQ                 PORT_MUX_ALT1
        #define PA_5_IRQ                 PORT_MUX_ALT2
        #define PB_4_NMI                 PORT_MUX_ALT5
        #define PA_4_SWD_DIO             PORT_MUX_ALT4
        #define PA_5_RESET               PORT_MUX_ALT4
    #elif (SIZE_OF_FLASH <= (8 * 1024))
        #define PB_6_XTAL                PORT_MUX_ALT6
        #define PB_7_EXTAL               PORT_MUX_ALT6
        #define PA_0_SWD_CLK             PORT_MUX_ALT6
        #define PA_5_IRQ                 PORT_MUX_ALT1
        #define PA_4_SWD_DIO             PORT_MUX_ALT6
        #define PA_5_RESET               PORT_MUX_ALT6
        #define PB_4_NMI                 PORT_MUX_ALT5
    #else
        #define PB_6_XTAL                PORT_MUX_ALT4
        #define PB_7_EXTAL               PORT_MUX_ALT4
        #define PC_4_SWD_CLK             PORT_MUX_ALT4
        #define PA_5_IRQ                 PORT_MUX_ALT1
        #define PA_4_SWD_DIO             PORT_MUX_ALT4
        #define PA_5_RESET               PORT_MUX_ALT4
        #define PB_4_NMI                 PORT_MUX_ALT3
    #endif
#endif
#if defined KINETIS_KL43
    #define PB_18_I2S0_TX_BCLK           PORT_MUX_ALT4
    #define PC_1_I2S0_TXD0               PORT_MUX_ALT6
    #define PC_2_I2S0_TX_FS              PORT_MUX_ALT6
    #define PC_4_I2S0_MCLK               PORT_MUX_ALT5
    #define PC_5_I2S0_RXD0               PORT_MUX_ALT4
#endif
#if defined KINETIS_KL
    #if defined KINETIS_KL05
        #define PB_1_DAC0_OUT            PORT_MUX_ALT0
    #else
        #define PE_30_DAC0_OUT           PORT_MUX_ALT0
    #endif
    #define PB_0_ADC0_SE8                PORT_MUX_ALT0
    #define PE_21_ADC0_SE4               PORT_MUX_ALT0
    #define PE_30_ADC0_SE23              PORT_MUX_ALT0
    #if defined KINETIS_KL03
        #define PA_4_CLKOUT              PORT_MUX_ALT5
        #define PA_12_CLKOUT             PORT_MUX_ALT5
    #elif defined KINETIS_KL05
        #define PA_15_CLKOUT             PORT_MUX_ALT3
    #else
        #define PC_3_CLKOUT              PORT_MUX_ALT5
    #endif
#else
    #define PC_3_CLKOUT                  PORT_MUX_ALT5
    #define PE_0_RTC_CLKOUT              PORT_MUX_ALT7
    #define PE_26_RTC_CLKOUT             PORT_MUX_ALT6
#endif

#if defined KINETIS_KE04 && (SIZE_OF_FLASH <= (8 * 1024))                // KE04 ADC
    #define PA_1_ADC0_SE1                PORT_MUX_ALT6
    #define PA_6_ADC0_SE2                PORT_MUX_ALT6
    #define PA_7_ADC0_SE3                PORT_MUX_ALT6
    #define PB_0_ADC0_SE4                PORT_MUX_ALT6
    #define PB_1_ADC0_SE5                PORT_MUX_ALT6
    #define PB_2_ADC0_SE6                PORT_MUX_ALT6
    #define PB_3_ADC0_SE7                PORT_MUX_ALT6
    #define PC_0_ADC0_SE8                PORT_MUX_ALT6
    #define PC_1_ADC0_SE9                PORT_MUX_ALT6
    #define PC_2_ADC0_SE10               PORT_MUX_ALT6
    #define PC_3_ADC0_SE11               PORT_MUX_ALT6

    #define PB_5_ACMP1_OUT               PORT_MUX_ALT4
#endif
#if defined KINETIS_KE02 || defined KINETIS_KE06
    #define PA_0_ADC0_SE0                PORT_MUX_ALT5
    #define PA_1_ADC0_SE1                PORT_MUX_ALT5
    #define PA_6_ADC0_SE2                PORT_MUX_ALT4
    #define PA_7_ADC0_SE3                PORT_MUX_ALT4
    #define PB_0_ADC0_SE4                PORT_MUX_ALT4
    #define PB_1_ADC0_SE5                PORT_MUX_ALT4
    #define PB_2_ADC0_SE6                PORT_MUX_ALT4
    #define PB_3_ADC0_SE7                PORT_MUX_ALT4
    #define PC_0_ADC0_SE8                PORT_MUX_ALT4
    #define PC_1_ADC0_SE9                PORT_MUX_ALT4
    #define PC_2_ADC0_SE10               PORT_MUX_ALT4
    #define PC_3_ADC0_SE11               PORT_MUX_ALT4
    #define PF_4_ADC0_SE12               PORT_MUX_ALT4
    #define PF_5_ADC0_SE13               PORT_MUX_ALT4
    #define PF_6_ADC0_SE14               PORT_MUX_ALT4
    #define PF_7_ADC0_SE15               PORT_MUX_ALT4
#endif

#if defined KINETIS_KE04 && (SIZE_OF_FLASH <= (8 * 1024))                // KE04 default pins
    #define PA_1_DEFAULT                 PA_1_ADC0_SE1
    #define PA_6_DEFAULT                 PA_6_ADC0_SE2
    #define PA_7_DEFAULT                 PA_7_ADC0_SE3
    #define PB_2_DEFAULT                 PB_2_ADC0_SE6
    #define PB_3_DEFAULT                 PB_3_ADC0_SE7
    #define PB_4_DEFAULT                 PB_4_NMI
    #define PB_5_DEFAULT                 PB_5_ACMP1_OUT
    #define PC_0_DEFAULT                 PC_0_ADC0_SE8
    #define PC_1_DEFAULT                 PC_1_ADC0_SE9
    #define PC_2_DEFAULT                 PC_2_ADC0_SE10
    #define PC_3_DEFAULT                 PC_3_ADC0_SE11
#endif

#if !defined KINETIS_KL || defined KINETIS_KL82                          // {42}
    // Watchdog
    //
    #if defined KINETIS_KE
        #define WDOG_CS1                 *(volatile unsigned char *)(WDOG_BLOCK + 0x00)  // Watchdog Status and Control Register 1
          #define WDOG_CS1_STOP          0x01                            // watchdog enabled in chip stop mode
          #define WDOG_CS1_WAIT          0x02                            // watchdog enabled in chip wait mode
          #define WDOG_CS1_DBG           0x04                            // watchdog enabled in chip debug mode
          #define WDOG_CS1_TST           0x18                            // watchdog test mask
          #define WDOG_CS1_UPDATE        0x20                            // allow updates
          #define WDOG_CS1_INT           0x40                            // watchdog interrupt enable
          #define WDOG_CS1_EN            0x80                            // watchdog enable
        #define WDOG_CS2                 *(volatile unsigned char *)(WDOG_BLOCK + 0x01)  // Watchdog Status and Control Register 2
          #define WDOG_CS2_CLK_BUS       0x00                            // watchdog clocked from bus clock
          #define WDOG_CS2_CLK_1kHz      0x01                            // watchdog clocked from internal low-power oscillator (LPOCLK)
          #define WDOG_CS2_CLK_32kHz     0x02                            // watchdog clocked from internal 32kHz ICSIRCLK oscillator
          #define WDOG_CS2_CLK_EXT       0x03                            // watchdog clocked from external clock source
          #define WDOG_CS2_PRES_256      0x10                            // prescaler of 256 enabled
          #define WDOG_CS2_FLG           0x40                            // write '1' to clear
          #define WDOG_CS2_WIN           0x80                            // window mode enabled
        #define WDOG_UNLOCK              *(volatile unsigned short *)(WDOG_BLOCK + 0x02) // unlock sequence address
        #define WDOG_REFRESH             *(volatile unsigned short *)(WDOG_BLOCK + 0x02) // retrigger sequence address
            #define WDOG_UNLOCK_SEQUENCE_1  0x20c5                       // unlock and retrigger sequences must be performed with two writes within 16 bus clock
            #define WDOG_UNLOCK_SEQUENCE_2  0x28d9
            #define WDOG_REFRESH_SEQUENCE_1 0x02a6
            #define WDOG_REFRESH_SEQUENCE_2 0x80b4
        #define WDOG_CNTH                *(volatile unsigned char *)(WDOG_BLOCK + 0x02)  // Watchdog Counter Register: High (read-only)
        #define WDOG_CNTL                *(volatile unsigned char *)(WDOG_BLOCK + 0x03)  // Watchdog Counter Register: Low (read-only)
        #define WDOG_TOVAL               *(volatile unsigned short *)(WDOG_BLOCK + 0x04) // Watchdog Timeout Value Register (16 bit access)
        #define WDOG_TOVALH              *(volatile unsigned char *)(WDOG_BLOCK + 0x04)  // Watchdog Timeout Value Register: High
        #define WDOG_TOVALL              *(volatile unsigned char *)(WDOG_BLOCK + 0x05)  // Watchdog Timeout Value Register: Low
        #define WDOG_WIN                 *(volatile unsigned short *)(WDOG_BLOCK + 0x06) // Watchdog Timeout Value Register (16  bit access)
        #define WDOG_WINH                *(volatile unsigned char *)(WDOG_BLOCK + 0x06)  // Watchdog Timeout Value Register: High
        #define WDOG_WINL                *(volatile unsigned char *)(WDOG_BLOCK + 0x07)  // Watchdog Timeout Value Register: Low

        #if defined _WINDOWS
            #define REFRESH_WDOG()           WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_1; WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_2; WDOG_CNTH = 0; WDOG_CNTL = 0; // this sequence must be performed within 16 bus cycles (it should be protected against interrupt disturbing this)
        #else
            #define REFRESH_WDOG()           WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_1; WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_2 // this sequence must be performed within 16 bus cycles (it should be protected against interrupt disturbing this)
        #endif
    #else
        #define WDOG_STCTRLH                 *(volatile unsigned short*)(WDOG_BLOCK + 0x00)   // Watchdog Status and Control Register: High
          #define WDOG_STCTRLH_WDOGEN        0x0001                      // watchdog enable
          #define WDOG_STCTRLH_CLKSRC        0x0002                      // watchdog clock source is alternative source (bus clock), rather than LPO
          #define WDOG_STCTRLH_IRQRSTEN      0x0004
          #define WDOG_STCTRLH_WINEN         0x0008                      // enable windowing mode
          #define WDOG_STCTRLH_ALLOWUPDATE   0x0010
          #define WDOG_STCTRLH_DBGEN         0x0020
          #define WDOG_STCTRLH_STOPEN        0x0040
          #define WDOG_STCTRLH_WAITEN        0x0080
          #define WDOG_STCTRLH_STNDBYEN      0x0100
          #define WDOG_STCTRLH_TESTWDOG      0x0400
          #define WDOG_STCTRLH_TESTSEL       0x0800
          #define WDOG_STCTRLH_BYTESEL_0     0x0000
          #define WDOG_STCTRLH_BYTESEL_1     0x1000
          #define WDOG_STCTRLH_BYTESEL_2     0x2000
          #define WDOG_STCTRLH_BYTESEL_3     0x3000
          #define WDOG_STCTRLH_DISTESTWDOG   0x4000
        #define WDOG_STCTRLL                 *(volatile unsigned short *)(WDOG_BLOCK + 0x02)  // Watchdog Status and Control Register: Low
        #define WDOG_TOVALH                  *(unsigned short *)(WDOG_BLOCK + 0x04)           // Watchdog Time-out Value Register: High
        #define WDOG_TOVALL                  *(unsigned short *)(WDOG_BLOCK + 0x06)           // Watchdog Time-out Value Register: Low
        #define WDOG_WINH                    *(unsigned short *)(WDOG_BLOCK + 0x08)           // Watchdog Window Register: High
        #define WDOG_WINL                    *(unsigned short *)(WDOG_BLOCK + 0x0a)           // Watchdog Window Register: Low
        #define WDOG_REFRESH                 *(volatile unsigned short *)(WDOG_BLOCK + 0x0c)  // Watchdog Refresh Register
          #define WDOG_REFRESH_SEQUENCE_1    0xa602
          #define WDOG_REFRESH_SEQUENCE_2    0xb480
        #define WDOG_UNLOCK                  *(volatile unsigned short *)(WDOG_BLOCK + 0x0e)  // Watchdog Unlock Register
          #define WDOG_UNLOCK_SEQUENCE_1     0xc520
          #define WDOG_UNLOCK_SEQUENCE_2     0xd928
        #define WDOG_TMROUTH                 *(volatile unsigned short *)(WDOG_BLOCK + 0x10)  // Watchdog Timer Output Register: High
        #define WDOG_TMROUTL                 *(volatile unsigned short *)(WDOG_BLOCK + 0x12)  // Watchdog Timer Output Register: Low
        #define WDOG_RSTCNT                  *(volatile unsigned short *)(WDOG_BLOCK + 0x14)  // Watchdog Reset Count Register (write 1 to clear bits)
        #define WDOG_PRESC                   *(unsigned short *)(WDOG_BLOCK + 0x16)           // Watchdog Prescaler Register

        #if defined _WINDOWS
            #define REFRESH_WDOG()           WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_1; WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_2; WDOG_TMROUTH = 0; WDOG_TMROUTL = 0; // this sequence must be performed within 20 bus cycles (it should be protected against interrupt disturbing this)
        #else
            #define REFRESH_WDOG()           WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_1; WDOG_REFRESH = WDOG_REFRESH_SEQUENCE_2 // this sequence must be performed within 20 bus cycles (it should be protected against interrupt disturbing this)
        #endif
    #endif
    #define UNLOCK_WDOG()                    WDOG_UNLOCK = WDOG_UNLOCK_SEQUENCE_1; WDOG_UNLOCK = WDOG_UNLOCK_SEQUENCE_2 // this sequence must be performed within 20 bus cycles and the writes are possible for the WCT period (16 bus clocks for KE and 128 bus clocks for configuration)
#endif


#if defined CHIP_HAS_FLEXIO
    #define FLEXIO_VERID                 *(volatile unsigned long *)(FLEXIO_BLOCK + 0x000) // version ID register (read-only)
    #define FLEXIO_PARAM                 *(volatile unsigned long *)(FLEXIO_BLOCK + 0x004) // parameter register (read-only)
    #define FLEXIO_CTRL                  *(volatile unsigned long *)(FLEXIO_BLOCK + 0x008) // FlexIO control register
    #define FLEXIO_SHIFTSTAT             *(volatile unsigned long *)(FLEXIO_BLOCK + 0x010) // shifter status register (write '1' to clear)
    #define FLEXIO_SHIFTERR              *(volatile unsigned long *)(FLEXIO_BLOCK + 0x014) // shifter error register (write '1' to clear)
    #define FLEXIO_TIMSTAT               *(volatile unsigned long *)(FLEXIO_BLOCK + 0x018) // timer status register (write '1' to clear)
    #define FLEXIO_SHIFTSIEN             *(unsigned long *)(FLEXIO_BLOCK + 0x020) // shifter status interrupt enable register
    #define FLEXIO_SHIFTEIEN             *(unsigned long *)(FLEXIO_BLOCK + 0x024) // shifter error interrupt enable register
    #define FLEXIO_TIMIEN                *(unsigned long *)(FLEXIO_BLOCK + 0x028) // timer interrupt enable register
    #define FLEXIO_SHIFTSDEN             *(unsigned long *)(FLEXIO_BLOCK + 0x030) // shifter status DMA enable
    #define FLEXIO_SHIFTCTL0             *(unsigned long *)(FLEXIO_BLOCK + 0x080) // shifter control 0 register
    #define FLEXIO_SHIFTCTL1             *(unsigned long *)(FLEXIO_BLOCK + 0x084) // shifter control 1 register
    #define FLEXIO_SHIFTCTL2             *(unsigned long *)(FLEXIO_BLOCK + 0x088) // shifter control 2 register
    #define FLEXIO_SHIFTCTL3             *(unsigned long *)(FLEXIO_BLOCK + 0x08c) // shifter control 3 register
    #define FLEXIO_SHIFTCFG0             *(unsigned long *)(FLEXIO_BLOCK + 0x100) // shifter configuration 0 register
    #define FLEXIO_SHIFTCFG1             *(unsigned long *)(FLEXIO_BLOCK + 0x104) // shifter configuration 1 register
    #define FLEXIO_SHIFTCFG2             *(unsigned long *)(FLEXIO_BLOCK + 0x108) // shifter configuration 2 register
    #define FLEXIO_SHIFTCFG3             *(unsigned long *)(FLEXIO_BLOCK + 0x10c) // shifter configuration 3 register
    #define FLEXIO_SHIFTBUF0             *(unsigned long *)(FLEXIO_BLOCK + 0x200) // shifter buffer 0 register
    #define FLEXIO_SHIFTBUF1             *(unsigned long *)(FLEXIO_BLOCK + 0x204) // shifter buffer 1 register
    #define FLEXIO_SHIFTBUF2             *(unsigned long *)(FLEXIO_BLOCK + 0x208) // shifter buffer 2 register
    #define FLEXIO_SHIFTBUF3             *(unsigned long *)(FLEXIO_BLOCK + 0x20c) // shifter buffer 3 register
    #define FLEXIO_SHIFTBUFBIS0          *(unsigned long *)(FLEXIO_BLOCK + 0x280) // shifter buffer 0 bit swapped register
    #define FLEXIO_SHIFTBUFBIS1          *(unsigned long *)(FLEXIO_BLOCK + 0x284) // shifter buffer 1 bit swapped register
    #define FLEXIO_SHIFTBUFBIS2          *(unsigned long *)(FLEXIO_BLOCK + 0x288) // shifter buffer 2 bit swapped register
    #define FLEXIO_SHIFTBUFBIS3          *(unsigned long *)(FLEXIO_BLOCK + 0x28c) // shifter buffer 3 bit swapped register
    #define FLEXIO_SHIFTBUFBYS0          *(unsigned long *)(FLEXIO_BLOCK + 0x300) // shifter buffer 0 byte swapped register
    #define FLEXIO_SHIFTBUFBYS1          *(unsigned long *)(FLEXIO_BLOCK + 0x304) // shifter buffer 1 byte swapped register
    #define FLEXIO_SHIFTBUFBYS2          *(unsigned long *)(FLEXIO_BLOCK + 0x308) // shifter buffer 2 byte swapped register
    #define FLEXIO_SHIFTBUFBYS3          *(unsigned long *)(FLEXIO_BLOCK + 0x30c) // shifter buffer 3 byte swapped register
    #define FLEXIO_SHIFTBUFBBS0          *(unsigned long *)(FLEXIO_BLOCK + 0x380) // shifter buffer 0 bit byte swapped register
    #define FLEXIO_SHIFTBUFBBS1          *(unsigned long *)(FLEXIO_BLOCK + 0x384) // shifter buffer 1 bit byte swapped register
    #define FLEXIO_SHIFTBUFBBS2          *(unsigned long *)(FLEXIO_BLOCK + 0x388) // shifter buffer 2 bit byte swapped register
    #define FLEXIO_SHIFTBUFBBS3          *(unsigned long *)(FLEXIO_BLOCK + 0x38c) // shifter buffer 3 bit byte swapped register
    #define FLEXIO_TIMCTL0               *(unsigned long *)(FLEXIO_BLOCK + 0x400) // timer control 0 register
    #define FLEXIO_TIMCTL1               *(unsigned long *)(FLEXIO_BLOCK + 0x404) // timer control 1 register
    #define FLEXIO_TIMCTL2               *(unsigned long *)(FLEXIO_BLOCK + 0x408) // timer control 2 register
    #define FLEXIO_TIMCTL3               *(unsigned long *)(FLEXIO_BLOCK + 0x40c) // timer control 3 register
    #define FLEXIO_TIMCFG0               *(unsigned long *)(FLEXIO_BLOCK + 0x480) // timer configuration 0 register
    #define FLEXIO_TIMCFG1               *(unsigned long *)(FLEXIO_BLOCK + 0x484) // timer configuration 1 register
    #define FLEXIO_TIMCFG2               *(unsigned long *)(FLEXIO_BLOCK + 0x488) // timer configuration 2 register
    #define FLEXIO_TIMCFG3               *(unsigned long *)(FLEXIO_BLOCK + 0x48c) // timer configuration 3 register
    #define FLEXIO_TIMCMP0               *(unsigned long *)(FLEXIO_BLOCK + 0x500) // timer compare 0 register
    #define FLEXIO_TIMCMP1               *(unsigned long *)(FLEXIO_BLOCK + 0x504) // timer compare 1 register
    #define FLEXIO_TIMCMP2               *(unsigned long *)(FLEXIO_BLOCK + 0x508) // timer compare 2 register
    #define FLEXIO_TIMCMP3               *(unsigned long *)(FLEXIO_BLOCK + 0x50c) // timer compare 3 register
#endif

// External Watchdog Monitor
//
#define EWM_CTRL                         *(volatile unsigned short *)(EWM_BLOCK + 0x0)  // External Watchdog Monitor Control Register
#define EWM_SERV                         *(volatile unsigned short *)(EWM_BLOCK + 0x1)  // External Watchdog Monitor Service Register
#define EWM_CMPL                         *(volatile unsigned short *)(EWM_BLOCK + 0x2)  // External Watchdog Monitor Compare Low Register
#define EWM_CMPH                         *(volatile unsigned short *)(EWM_BLOCK + 0x3)  // External Watchdog Monitor Compare High Register


#if defined KINETIS_KE
    // Internal Clock Source
    //
    #define ICS_C1                       *(volatile unsigned char *)(INTERNAL_CLOCK_BLOCK + 0x0) // ICS Control Register 1
      #define ICS_C1_IREFSTEN            0x01                            // internal reference enabled in stop mode
      #define ICS_C1_IRCLKEN             0x02                            // internal reference clock enabled - for use as ICSIRCLK
      #define ICS_C1_IREFS               0x04                            // internal reference select for FLL (default - as opposed to the FLL using the external clock)
      #define ICS_C1_RDIV_RANGE0_1       0x00                            // when RANGE is 0 the FLL reference is divided by 1
      #define ICS_C1_RDIV_RANGE0_2       0x08                            // when RANGE is 0 the FLL reference is divided by 2
      #define ICS_C1_RDIV_RANGE0_4       0x10                            // when RANGE is 0 the FLL reference is divided by 4
      #define ICS_C1_RDIV_RANGE0_8       0x18                            // when RANGE is 0 the FLL reference is divided by 8
      #define ICS_C1_RDIV_RANGE0_16      0x20                            // when RANGE is 0 the FLL reference is divided by 16
      #define ICS_C1_RDIV_RANGE0_32      0x28                            // when RANGE is 0 the FLL reference is divided by 32
      #define ICS_C1_RDIV_RANGE0_64      0x30                            // when RANGE is 0 the FLL reference is divided by 64
      #define ICS_C1_RDIV_RANGE0_128     0x38                            // when RANGE is 0 the FLL reference is divided by 128
      #define ICS_C1_RDIV_RANGE1_32      0x00                            // when RANGE is 1 the FLL reference is divided by 32
      #define ICS_C1_RDIV_RANGE1_64      0x08                            // when RANGE is 1 the FLL reference is divided by 64
      #define ICS_C1_RDIV_RANGE1_128     0x10                            // when RANGE is 1 the FLL reference is divided by 128
      #define ICS_C1_RDIV_RANGE1_256     0x18                            // when RANGE is 1 the FLL reference is divided by 256
      #define ICS_C1_RDIV_RANGE1_512     0x20                            // when RANGE is 1 the FLL reference is divided by 512
      #define ICS_C1_RDIV_RANGE1_1024    0x28                            // when RANGE is 1 the FLL reference is divided by 1024
      #define ICS_C1_CLKS_FLL            0x00                            // clock source select - FLL
      #define ICS_C1_CLKS_INTERNAL_REF   0x40                            // clock source select - internal reference clock
      #define ICS_C1_CLKS_EXTERNAL_REF   0x80                            // clock source select - external reference clock
    #define ICS_C2                       *(volatile unsigned char *)(INTERNAL_CLOCK_BLOCK + 0x1) // ICS Control Register 2
      #define ICS_C2_BDIV_1              0x00                            // bus frequency divider - divide by 1
      #define ICS_C2_BDIV_2              0x20                            // bus frequency divider - divide by 2 (default)
      #define ICS_C2_BDIV_4              0x40                            // bus frequency divider - divide by 4
      #define ICS_C2_BDIV_8              0x60                            // bus frequency divider - divide by 8
      #define ICS_C2_BDIV_16             0x80                            // bus frequency divider - divide by 16
      #define ICS_C2_BDIV_32             0xa0                            // bus frequency divider - divide by 32
      #define ICS_C2_BDIV_64             0xc0                            // bus frequency divider - divide by 64
      #define ICS_C2_BDIV_128            0xe0                            // bus frequency divider - divide by 128
      #define ICS_C2_LP                  0x10                            // 
    #define ICS_C3                       *(volatile unsigned char *)(INTERNAL_CLOCK_BLOCK + 0x2) // ICS Control Register 3
    #define ICS_C4                       *(volatile unsigned char *)(INTERNAL_CLOCK_BLOCK + 0x3) // ICS Control Register 4
      #define ICS_C4_SCFTRIM             0x01                            // slow internal reference clock fine trim
      #define ICS_C4_CME                 0x20                            // clock monitor enable (reset generate on loss of lock)
      #define ICS_C4_LOLIE               0x80                            // loss of lock interrupt enable
    #define ICS_S                        *(volatile unsigned char *)(INTERNAL_CLOCK_BLOCK + 0x4) // ICS Status Register (read-only)
      #define ICS_S_CLKST_FLL_SELECTED   0x00                            // clock mode status - output of FLL is selected
      #define ICS_S_CLKST_FLL_BYPASS_INT 0x04                            // clock mode status - FLL bypassed, internal reference clock selected
      #define ICS_S_CLKST_FLL_BYPASS_EXT 0x08                            // clock mode status - FLL bypassed, external reference clock selected
      #define ICS_S_CLKST_MASK           0x0c                            // clock mode status mask
      #define ICS_S_IREFST               0x10                            // source of reference clock is internal clock
      #define ICS_S_LOCK                 0x40                            // FLL is currently locked
      #define ICS_S_LOLS                 0x80                            // FLL has lost lock since LOLS was last cleared (write '1' to clear)
#elif defined KINETIS_WITH_SCG                                           // {91}
    // System Clock Generator
    //
    #define SCG_VERID                    *(unsigned long *)(SCG_BLOCK + 0x000) // version ID register (read-only)
    #define SCG_PARAM                    *(unsigned long *)(SCG_BLOCK + 0x004) // parameter register (read-only)
    #define SCG_CSR                      *(volatile unsigned long *)(SCG_BLOCK + 0x010) // clock status register (read-only)
    #define SCG_RCCR                     *(unsigned long *)(SCG_BLOCK + 0x014) // run clock control register
    #define SCG_VCCR                     *(unsigned long *)(SCG_BLOCK + 0x018) // VLPR clock control register
    #define SCG_HCCR                     *(unsigned long *)(SCG_BLOCK + 0x01c) // HSRUN clock control register
    #define SCG_CLKOUTCNFG               *(unsigned long *)(SCG_BLOCK + 0x020) // SCG_CLKOUT configuration register
    #define SCG_SOSCCSR                  *(volatile unsigned long *)(SCG_BLOCK + 0x100) // system OSC control status register
    #define SCG_SOSCDIV                  *(unsigned long *)(SCG_BLOCK + 0x104) // system OSC divide register
    #define SCG_SOSCCFG                  *(unsigned long *)(SCG_BLOCK + 0x108) // system oscillator configuration register
    #define SCG_SIRCCSR                  *(volatile unsigned long *)(SCG_BLOCK + 0x200) // slow IRC control status register
    #define SCG_SIRCDIV                  *(unsigned long *)(SCG_BLOCK + 0x204) // slow IRC divide register
    #define SCG_SIRCCFG                  *(unsigned long *)(SCG_BLOCK + 0x208) // slow IRC configuration register
    #define SCG_FIRCCSR                  *(volatile unsigned long *)(SCG_BLOCK + 0x300) // fast IRC control status register
    #define SCG_FIRCDIV                  *(unsigned long *)(SCG_BLOCK + 0x304) // fast IRC divide register
    #define SCG_FIRCCFG                  *(unsigned long *)(SCG_BLOCK + 0x308) // fast IRC configuration register
    #define SCG_FIRCTCFG                 *(unsigned long *)(SCG_BLOCK + 0x30c) // fast IRC trim configuration register
    #define SCG_FIRCSTAT                 *(volatile unsigned long *)(SCG_BLOCK + 0x318) // fast IRC status register
    #define SCG_SPPLCCSR                 *(volatile unsigned long *)(SCG_BLOCK + 0x600) // system PPL control status register
    #define SCG_SPPLCDIV                 *(unsigned long *)(SCG_BLOCK + 0x604) // system PLL divide register
    #define SCG_SPPLCFG                  *(unsigned long *)(SCG_BLOCK + 0x608) // system PLL configuration register
#else
    // Multi-purpose Clock Generator
    //
    #define MCG_C1                       *(volatile unsigned char *)(MCG_BLOCK + 0x00) // MSG Control 1 Register
      #define MCG_C1_IREFSTEN            0x01                            // internal reference stop enable
      #define MCG_C1_IRCLKEN             0x02                            // internal reference clock enable
      #if defined KINETIS_WITH_MCG_LITE
        #define MCG_C1_CLKS_HIRC         0x00                            // MCGOUTCLK selected from HIRC (HIRC mode)
        #define MCG_C1_CLKS_LIRC         0x40                            // MCGOUTCLK selected from LIRC (LIRC2M or LIRC8M mode)
        #define MCG_C1_CLKS_EXTERN_CLK   0x80                            // MCGOUTCLK selected from external reference clock (EXT mode)
      #else
      #define MCG_C1_IREFS               0x04                            // select slow internal reference clock as source for FLL (rather than external reference clock)
      #define MCG_C1_FRDIV_RANGE0_1      0x00                            // when RANGE is 0 the external reference is divided by 1
      #define MCG_C1_FRDIV_RANGE0_2      0x08                            // when RANGE is 0 the external reference is divided by 2
      #define MCG_C1_FRDIV_RANGE0_4      0x10                            // when RANGE is 0 the external reference is divided by 4
      #define MCG_C1_FRDIV_RANGE0_8      0x18                            // when RANGE is 0 the external reference is divided by 8
      #define MCG_C1_FRDIV_RANGE0_16     0x20                            // when RANGE is 0 the external reference is divided by 16
      #define MCG_C1_FRDIV_RANGE0_32     0x28                            // when RANGE is 0 the external reference is divided by 32
      #define MCG_C1_FRDIV_RANGE0_64     0x30                            // when RANGE is 0 the external reference is divided by 64
      #define MCG_C1_FRDIV_RANGE0_128    0x38                            // when RANGE is 0 the external reference is divided by 128
      #define MCG_C1_FRDIV_32            0x00                            // when RANGE is not 0 the external reference is divided by 32
      #define MCG_C1_FRDIV_64            0x08                            // when RANGE is not 0 the external reference is divided by 64
      #define MCG_C1_FRDIV_128           0x10                            // when RANGE is not 0 the external reference is divided by 128
      #define MCG_C1_FRDIV_256           0x18                            // when RANGE is not 0 the external reference is divided by 256
      #define MCG_C1_FRDIV_512           0x20                            // when RANGE is not 0 the external reference is divided by 512
      #define MCG_C1_FRDIV_1024          0x28                            // when RANGE is not 0 the external reference is divided by 1024
          #if defined KINETIS_KL || defined KINETIS_HAS_IRC48M
      #define MCG_C1_FRDIV_1280          0x30                            // when RANGE is not 0 the external reference is divided by 1280
      #define MCG_C1_FRDIV_1536          0x38                            // when RANGE is not 0 the external reference is divided by 1536
          #endif
      #define MCG_C1_CLKS_PLL_FLL        0x00                            // MCGOUTCLK selected from either PLL or FLL, depending on PLLS control bit
      #define MCG_C1_CLKS_INTERN_CLK     0x40                            // MCGOUTCLK selected from internal reference clock
      #define MCG_C1_CLKS_EXTERN_CLK     0x80                            // MCGOUTCLK selected from external reference clock
      #endif
    #define MCG_C2                       *(volatile unsigned char *)(MCG_BLOCK + 0x01) // MSG control 2 register
      #define MCG_C2_IRCS                0x01                            // select fast internal reference clock rather than slow one
      #define MCG_C2_EREFS               0x04                            // external reference from oscillator requested
      #if !defined KINETIS_WITH_MCG_LITE
        #define MCG_C2_LP                0x02                            // low power select (FLL/PLL disabled in bypass mode)
        #define MCG_C2_HGO               0x08                            // high gain operation
        #define MCG_C2_RANGE_32K_40K     0x00                            // selects crystal range
        #define MCG_C2_RANGE_1M_8M       0x10
        #define MCG_C2_RANGE_8M_32M      0x20
        #if defined KINETIS_KL
          #define MCG_C2_FCFTRIM         0x40                            // Fast Internal Reference Clock Fine Tune
        #endif
        #if defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000) || (defined KINETIS_KL && !defined KINETSI_KL03) || defined KINETIS_KW2X
          #define MCG_C2_LOCRE0          0x80                            // reset on loss of clock
        #else
          #define MCG_C2_LOCRE0          0x00
        #endif
      #endif
    #if !defined KINETIS_WITH_MCG_LITE
    #define MCG_C3                       *(unsigned char *)(MCG_BLOCK + 0x02) // MSG Control 3 Register (SCTRIM [slow internal reference clock trim setting] value)
    #define MCG_C4                       *(unsigned char *)(MCG_BLOCK + 0x03) // MSG Control 4 Register
        #define MCG_C4_SCFTRIM           0x01                            // slow internal reference clock fine trim
        #define MCG_C4_FCTRIM_MASK       0x1e                            // fast internal reference clock trip setting
        #define MCG_C4_LOW_RANGE         0x00                            // default
        #define MCG_C4_MID_RANGE         0x20
        #define MCG_C4_MID_HIGH_RANGE    0x40
        #define MCG_C4_HIGH_RANGE        0x60
        #define MCG_C4_DMX32             0x80                            // DCO is fine-tuned for maximum frequency with 32.768 kHz
      #if defined KINETIS_KL05 || defined KINETIS_KL02 || defined KINETIS_K02
        #define MCG_C6                   *(unsigned char *)(MCG_BLOCK + 0x05) // MSG Control 6 Register
          #define MCG_C6_CME             0x20                            // clock monitor enable
      #else
        #if !defined KINETIS_KV10
            #define MCG_C5                   *(unsigned char *)(MCG_BLOCK + 0x04) // MSG Control 5 Register
              #if (defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000)) && !defined KINETIS_K21
                #define MCG_C5_PRDIV0_MASK   0x07
                #define MCG_C5_PLLREFSEL0    0x80
              #else
                #define MCG_C5_PRDIV0_MASK   0x1f
              #endif
              #define MCG_C5_PLLSTEN0        0x20
              #define MCG_C5_PLLCLKEN0       0x40
        #endif
        #define MCG_C6                   *(unsigned char *)(MCG_BLOCK + 0x05) // MSG Control 6 Register
          #if (defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000)) && !defined KINETIS_K21 && !defined KINETIS_K22 && !defined KINETIS_K24 && !defined KINETIS_K64 && !defined KINETIS_KV30
              #define MCG_C6_VDIV0_LOWEST  16
          #else
              #define MCG_C6_VDIV0_LOWEST  24
          #endif
          #define MCG_C6_VDIV0_MASK      0x1f
          #define MCG_C6_CME             0x20                            // clock monitor enable
          #define MCG_C6_PLLS_FLL        0x00                            // FLL select
          #define MCG_C6_PLLS            0x40                            // PLL select
          #define MCG_C6_LOLIE           0x80                            // loss of lock interrupt enable
      #endif
    #endif
    #define MCG_S                        *(volatile unsigned char *)(MCG_BLOCK + 0x06) // MSG Status Register (read-only)
      #if defined KINETIS_WITH_MCG_LITE
        #define MCG_S_OSCINIT0           0x02                            // set when the initialisation cycles of the crystal oscillator have completed
        #define MCG_S_CLKST_HICR         0x00                            // HIRC clock is selected as the main clock source (HIRC mode)
        #define MCG_S_CLKST_LICR         0x04                            // LICR clock is selected as the main clock source (LIRC2M or LIRC8M)
        #define MCG_S_CLKST_EXT          0x08                            // external clock is selected as the main clock source (EXT mode)
        #define MCG_S_CLKST_MASK         0x0c
      #else
        #define MCG_S_IRCST              0x01                            // source of internal reference clock is the fast clock (4MHz IRC) rather than slow clock (32kHz)
        #define MCG_S_OSCINIT            0x02                            // set when the initialisation cycles of the crystal oscillator have completed
        #define MCG_S_CLKST_FLL          0x00                            // FLL output is selected
        #define MCG_S_CLKST_INTERN_CLK   0x04                            // internal reference clock is selected
        #define MCG_S_CLKST_EXTERN_CLK   0x08                            // external reference clock is selected
        #define MCG_S_CLKST_PLL          0x0c                            // PLL output is selected
        #define MCG_S_CLKST_MASK         0x0c                            // clock selection field mask
        #define MCG_S_IREFST             0x10                            // FLL reference source is internal reference clock
        #define MCG_S_PLLST_FLL          0x00                            // source of PLLS is FLL clock
        #define MCG_S_PLLST              0x20                            // source of PLLS is PLL clock
        #define MCG_S_LOCK               0x40                            // PLL has acquired lock
        #define MCG_S_LOLS               0x80                            // PLL has lost lock since LOLS was last cleared
      #endif
      #if (defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000)) || defined KINETIS_KL || defined KINETIS_KV || defined KINETIS_KW2X
        #define MCG_SC                   *(volatile unsigned char *)(MCG_BLOCK + 0x08) // MSG status and control register
          #if !defined KINETIS_WITH_MCG_LITE
              #define MCG_SC_LOCS0       0x01                            // 
          #endif
          #define MCG_SC_FCRDIV_1        0x00                            // internal fast clock divided by 1
          #define MCG_SC_FCRDIV_2        0x02                            // internal fast clock divided by 2
          #define MCG_SC_FCRDIV_4        0x04                            // internal fast clock divided by 4
          #define MCG_SC_FCRDIV_8        0x06                            // internal fast clock divided by 8
          #define MCG_SC_FCRDIV_16       0x08                            // internal fast clock divided by 16
          #define MCG_SC_FCRDIV_32       0x0a                            // internal fast clock divided by 32
          #define MCG_SC_FCRDIV_64       0x0c                            // internal fast clock divided by 64
          #define MCG_SC_FCRDIV_128      0x0e                            // internal fast clock divided by 128
          #if !defined KINETIS_WITH_MCG_LITE
              #define MCG_SC_FLTPRSRV    0x10                            // FLL filter preserve enable
              #define MCG_SC_ATMF        0x20                            // automatic trim machine fail frag (read-only)
              #define MCG_SC_ATMS        0x40                            // automatic trim machine select
              #define MCG_SC_ATME        0x80                            // automatic trim machine enable
          #endif
        #if !defined KINETIS_WITH_MCG_LITE
         #define MCG_ATCVH               *(unsigned char *)(MCG_BLOCK + 0x0a) // MSG Auto Trim Compare Value High Register
         #define MCG_ATCVL               *(unsigned char *)(MCG_BLOCK + 0x0b) // MSG Auto Trim Compare Value Low Register
        #endif
      #endif
      #if defined KINETIS_K_FPU || (KINETIS_MAX_SPEED > 100000000) || defined KINETIS_KW2X
        #define MCG_C7                   *(unsigned char *)(MCG_BLOCK + 0x0c) // MSG Control 7 Register
          #define MCG_C7_OSCSEL_OSCCLK   0x00                            // MCG FLL external reference clock is OSCCLK
          #define MCG_C7_OSCSEL_32K      0x01                            // MCG FLL external reference clock is 32 kHz RTC Oscillator
        #if defined KINETIS_K64 || defined KINETIS_K22 || defined KINETIS_K24 || defined KINETIS_K02
          #define MCG_C7_OSCSEL_IRC48MCLK 0x02                           // MCG FLL external reference clock is IRC48M
        #endif
        #define MCG_C8                   *(volatile unsigned char *)(MCG_BLOCK + 0x0d) // MSG Control 8 Register
        #define MCG_C10                  *(unsigned char *)(MCG_BLOCK + 0x0f) // MSG Control 10 Register
        #if !defined KINETIS_KW2X
            #define MCG_C11                  *(unsigned char *)(MCG_BLOCK + 0x10) // MSG Control 11 Register
              #define MCG_C11_PRDIV1_MASK    0x07                        // PLL1 external reference divider
              #define MCG_C11_PLLCS_PPL0     0x00                        // PLL0 output is selected as the MCG source when CLKS are programmed in PLL engaged external mode
              #define MCG_C11_PLLCS_PPL1     0x10                        // PLL1 output is selected as the MCG source when CLKS are programmed in PLL engaged external mode
              #define MCG_C11_PLLSTEN1       0x20                        // PLL1 and its clocks remain enabled if system is in normal stop mode
              #define MCG_C11_PLLCLKEN1      0x40                        // enable MCGPLL1CLK, MCGPLL1CLK2X and MCGDDRCLK2 (as long as MCG is not in bypass mode)
              #define MCG_C11_PLLREFSEL1_OSC0 0x00                       // select OSC0 clock source as external reference clock source for PLL1
              #define MCG_C11_PLLREFSEL1_OSC1 0x80                       // select OSC1 clock source as external reference clock source for PLL1
            #define MCG_C12                  *(unsigned char *)(MCG_BLOCK + 0x11) // MSG Control 12 Register
              #define MCG_C12_VDIV1_MASK     0x1f                        // VCO1 divider
              #define MCG_C12_VDIV1_LOWEST   16
              #define MCG_C12_CME2           0x20                        // clock monitor enable 2
              #define MCG_C12_LOLIE1         0x80                        // PLL1 lost of lock interrupt enable
            #define MCG_S2                   *(volatile unsigned char *)(MCG_BLOCK + 0x12) // MSG Status 2 Register
              #define MCG_S2_LOCKS2          0x01                        // loss of OSC1 external reference clock has occurred
              #define MCG_S2_OSCINIT1        0x02                        // OSC1 has been initialised
              #define MCG_S2_PLLCST          0x10                        // FLL reference course is internal reference clock
              #define MCG_S2_LOCK1           0x40                        // PLL1 has acquired lock
              #define MCG_S2_LOLS1           0x80                        // PLL1 has lost lock since LOLS1 was last cleared
        #endif
      #elif !defined KINETIS_KL && !defined KINETIS_KV
          #define MCG_ATC                *(unsigned char *)(MCG_BLOCK + 0x08) // MSG Auto Trim Control Register
          #define MCG_ATCVH              *(unsigned char *)(MCG_BLOCK + 0x0a) // MSG Auto Trim Compare Value High Register
          #define MCG_ATCVL              *(unsigned char *)(MCG_BLOCK + 0x0b) // MSG Auto Trim Compare Value Low Register
      #elif defined KINETIS_WITH_MCG_LITE
          #define MCG_MC                 *(unsigned char *)(MCG_BLOCK + 0x18) // Miscellaneous control register
            #define MCG_MC_LIRC_DIV2_1   0x00                            // second low-frequency internal reference clock divider - divide by 1
            #define MCG_MC_LIRC_DIV2_2   0x01                            // second low-frequency internal reference clock divider - divide by by 2
            #define MCG_MC_LIRC_DIV2_4   0x02                            // second low-frequency internal reference clock divider - divide by by 4
            #define MCG_MC_LIRC_DIV2_8   0x03                            // second low-frequency internal reference clock divider - divide by by 8
            #define MCG_MC_LIRC_DIV2_16  0x04                            // second low-frequency internal reference clock divider - divide by by 16
            #define MCG_MC_LIRC_DIV2_32  0x05                            // second low-frequency internal reference clock divider - divide by by 32
            #define MCG_MC_LIRC_DIV2_64  0x06                            // second low-frequency internal reference clock divider - divide by by 64
            #define MCG_MC_LIRC_DIV2_128 0x07                            // second low-frequency internal reference clock divider - divide by by 128
            #define MCG_MC_HIRCEN        0x80                            // high-frequency IRC enable
      #endif
#endif

// Oscillator
//
#define OSC0_CR                          *(volatile unsigned char *)(OSC0_BLOCK + 0x00) // OSC0 Control Register
#if defined KINETIS_KE
  #define OSC_CR_OSCINIT                 0x01                            // OSC initialisation (read-only) 
  #define OSC_CR_HGO                     0x02                            // high gain mode
  #define OSC_CR_RANGE_LOW               0x00                            // high frequency range 32kHz
  #define OSC_CR_RANGE_HIGH              0x04                            // high frequency range 4..20MHz
  #define OSC_CR_OSCOS_EXT               0x00                            // select external clock source as output clock
  #define OSC_CR_OSCOS_SOURCE            0x10                            // select oscillator clock source as output clock
  #define OSC_CR_OSCSTEN                 0x20                            // enable oscillator in stop mode
  #define OSC_CR_OSCEN                   0x80                            // enable OSC module
#else
  #define OSC_CR_SC16P                   0x01                            // add 16pF capacitor to oscillator load
  #define OSC_CR_SC18P                   0x02                            // add 8pF capacitor to oscillator load
  #define OSC_CR_SC4P                    0x04                            // add 4pF capacitor to oscillator load
  #define OSC_CR_SC2P                    0x08                            // add 2pF capacitor to oscillator load
  #define OSC_CR_EREFSTEN                0x20                            // external reference clock stays enabled in stop mode if ERCLKEN is set before entering stop mode
  #define OSC_CR_ERCLKEN                 0x80                            // enable external reference clock
#endif

#if defined ERRATA_ID_3402 && !defined KINETIS_KL
    #define XTAL0_PORT                   _PORTA                          // when the OSC is enabled the XTAL port pin is forced to default function and can not be used as GPIO
    #define XTAL0_PIN                    19
#endif

#define OSC1_CR                      *(unsigned char*)(OSC1_BLOCK + 0x00) // OSC1 Control Register

// I2C
//
#define I2C0_A1                          *(unsigned char *)(I2C0_BLOCK + 0x0) // I2C0 Address Register 1
#define I2C0_F                           *(unsigned char *)(I2C0_BLOCK + 0x1) // I2C0 Frequency Divider Register 
#define I2C0_C1_ADD                      (volatile unsigned char *)(I2C0_BLOCK + 0x2) // I2C0 Control Register 1 address
#define I2C0_C1                          *(volatile unsigned char *)(I2C0_BLOCK + 0x2) // I2C0 Control Register 1
  #define I2C_DMAEN                      0x01                            // DMA enable
  #define I2C_WUEN                       0x02                            // wakeup enable
  #define I2C_RSTA                       0x04                            // repeat start (write '1' - not readable)
  #define I2C_TXAK                       0x08                            // transmit acknowledge enable
  #define I2C_MTX                        0x10                            // transmit mode select
  #define I2C_MSTA                       0x20                            // master mode
  #define I2C_IIEN                       0x40                            // I2C interrupt enable
  #define I2C_IEN                        0x80                            // I2C enable
#define I2C0_S                           *(volatile unsigned char *)(I2C0_BLOCK + 0x3) // I2C0 Status Register
  #define I2C_RXACK                      0x01                            // no ack signal detected (read-only)
  #define I2C_IIF                        0x02                            // I2C interrupt (write '1' to clear)
  #define I2C_SRW                        0x04                            // slave transmit (read-only)
  #define I2C_RAM                        0x08                            // range address match
  #define I2C_IAL                        0x10                            // arbitration lost (write '1' to clear)
  #define I2C_IBB                        0x20                            // bus busy status (read-only)
  #define I2C_IAAS                       0x40                            // addressed as slave
  #define I2C_TCF                        0x80                            // transfer complete (read-only)
#define I2C0_D                           *(volatile unsigned char *)(I2C0_BLOCK + 0x4) // I2C0 Data Register
#define I2C0_C2                          *(volatile unsigned char *)(I2C0_BLOCK + 0x5) // I2C0 Control Register 2
#define I2C0_FLT                         *(volatile unsigned char *)(I2C0_BLOCK + 0x6) // I2C0 Programmable Input Glitch Filter Register 
  #if defined DOUBLE_BUFFERED_I2C || defined I2C_START_CONDITION_INTERRUPT
    #define I2C_FLT_FLT_MASK             0x0f                            // programmable filter factor
    #define I2C_FLT_FLT_STARTF           0x10                            // I2C bus start detect flag (write '1' to clear)
    #define I2C_FLT_FLT_SSIE             0x20                            // I2C bus stop or start interrupt enable
    #define I2C_FLT_FLT_INT              I2C_FLT_FLT_SSIE
  #else
    #define I2C_FLT_FLT_MASK             0x1f                            // programmable filter factor
    #define I2C_FLT_FLT_STOPIE           0x20                            // I2C bus stop interrupt enable
    #define I2C_FLT_FLT_INT              I2C_FLT_FLT_STOPIE
  #endif
  #define I2C_FLT_FLT_STOPF              0x40                            // I2C bus stop detected (write '1' to clear)
  #define I2C_FLT_FLT_SHEN               0x80                            // stop hold enable
#define I2C0_RA                          *(unsigned char *)(I2C0_BLOCK + 0x7) // I2C0 Range Address Register
#define I2C0_SMB                         *(volatile unsigned char *)(I2C0_BLOCK + 0x8) // I2C0 SMBus Control and Status Register
#define I2C0_A2                          *(unsigned char *)(I2C0_BLOCK + 0x9) // I2C0 Address Register 2
#define I2C0_SLTH                        *(unsigned char *)(I2C0_BLOCK + 0xa) // I2C0 SCL Low Timeout Register High
#define I2C0_SLTL                        *(unsigned char *)(I2C0_BLOCK + 0xb) // I2C0 SCL Low Timeout Register Low
#if defined DOUBLE_BUFFERED_I2C
    #define I2C0_S2                      *(volatile unsigned char *)(I2C0_BLOCK + 0xc) // I2C0 Status Register 2
      #define I2C_S2_EMPTY               0x00000001                      // tx or rx buffer is empty and can be writtenm to (new data loaded) (read-only)
      #define I2C_S2_ERROR               0x00000002                      // there are 3 or more write/read errors during the data transfer phase (when the empty flag is not set and the buffer is busy) (write '1' to clear)
#endif

#if I2C_AVAILABLE > 1
    #define I2C1_A1                      *(unsigned char *)(I2C1_BLOCK + 0x0) // I2C1 Address Register 1
    #define I2C1_F                       *(unsigned char *)(I2C1_BLOCK + 0x1) // I2C1 Frequency Divider Register 
    #define I2C1_C1_ADD                  (volatile unsigned char *)(I2C1_BLOCK + 0x2) // I2C1 Control Register 1 address
    #define I2C1_C1                      *(volatile unsigned char *)(I2C1_BLOCK + 0x2) // I2C1 Control Register 1
    #define I2C1_S                       *(volatile unsigned char *)(I2C1_BLOCK + 0x3) // I2C1 Status Register
    #define I2C1_D                       *(volatile unsigned char *)(I2C1_BLOCK + 0x4) // I2C1 Data Register
    #define I2C1_C2                      *(volatile unsigned char *)(I2C1_BLOCK + 0x5) // I2C1 Control Register 2
    #define I2C1_FLT                     *(volatile unsigned char *)(I2C1_BLOCK + 0x6) // I2C1 Programmable Input Glitch Filter Register 
    #define I2C1_RA                      *(unsigned char *)(I2C1_BLOCK + 0x7) // I2C1 Range Address Register
    #define I2C1_SMB                     *(volatile unsigned char *)(I2C1_BLOCK + 0x8) // I2C1 SMBus Control and Status Register
    #define I2C1_A2                      *(unsigned char *)(I2C1_BLOCK + 0x9) // I2C1 Address Register 2
    #define I2C1_SLTH                    *(unsigned char *)(I2C1_BLOCK + 0xa) // I2C1 SCL Low Timeout Register High
    #define I2C1_SLTL                    *(unsigned char *)(I2C1_BLOCK + 0xb) // I2C1 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C1_S2                  *(volatile unsigned char *)(I2C1_BLOCK + 0xc) // I2C1 Status Register 2
    #endif
#endif

#if I2C_AVAILABLE > 2
    #define I2C2_A1                      *(unsigned char *)(I2C2_BLOCK + 0x0) // I2C2 Address Register 1
    #define I2C2_F                       *(unsigned char *)(I2C2_BLOCK + 0x1) // I2C2 Frequency Divider Register 
    #define I2C2_C1_ADD                  (volatile unsigned char *)(I2C2_BLOCK + 0x2) // I2C2 Control Register 1 address
    #define I2C2_C1                      *(volatile unsigned char *)(I2C2_BLOCK + 0x2) // I2C2 Control Register 1
    #define I2C2_S                       *(volatile unsigned char *)(I2C2_BLOCK + 0x3) // I2C2 Status Register
    #define I2C2_D                       *(volatile unsigned char *)(I2C2_BLOCK + 0x4) // I2C2 Data Register
    #define I2C2_C2                      *(volatile unsigned char *)(I2C2_BLOCK + 0x5) // I2C2 Control Register 2
    #define I2C2_FLT                     *(volatile unsigned char *)(I2C2_BLOCK + 0x6) // I2C2 Programmable Input Glitch Filter Register 
    #define I2C2_RA                      *(unsigned char *)(I2C2_BLOCK + 0x7) // I2C2 Range Address Register
    #define I2C2_SMB                     *(volatile unsigned char *)(I2C2_BLOCK + 0x8) // I2C2 SMBus Control and Status Register
    #define I2C2_A2                      *(unsigned char *)(I2C2_BLOCK + 0x9) // I2C2 Address Register 2
    #define I2C2_SLTH                    *(unsigned char *)(I2C2_BLOCK + 0xa) // I2C2 SCL Low Timeout Register High
    #define I2C2_SLTL                    *(unsigned char *)(I2C2_BLOCK + 0xb) // I2C2 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C2_S2                  *(volatile unsigned char *)(I2C2_BLOCK + 0xc) // I2C2 Status Register 2
    #endif
#endif

#if I2C_AVAILABLE > 3
    #define I2C3_A1                      *(unsigned char *)(I2C3_BLOCK + 0x0) // I2C3 Address Register 1
    #define I2C3_F                       *(unsigned char *)(I2C3_BLOCK + 0x1) // I2C3 Frequency Divider Register 
    #define I2C3_C1_ADD                  (volatile unsigned char *)(I2C3_BLOCK + 0x2) // I2C3 Control Register 1 address
    #define I2C3_C1                      *(volatile unsigned char *)(I2C3_BLOCK + 0x2) // I2C3 Control Register 1
    #define I2C3_S                       *(volatile unsigned char *)(I2C3_BLOCK + 0x3) // I2C3 Status Register
    #define I2C3_D                       *(volatile unsigned char *)(I2C3_BLOCK + 0x4) // I2C3 Data Register
    #define I2C3_C2                      *(volatile unsigned char *)(I2C3_BLOCK + 0x5) // I2C3 Control Register 2
    #define I2C3_FLT                     *(volatile unsigned char *)(I2C3_BLOCK + 0x6) // I2C3 Programmable Input Glitch Filter Register 
    #define I2C3_RA                      *(unsigned char *)(I2C3_BLOCK + 0x7) // I2C3 Range Address Register
    #define I2C3_SMB                     *(volatile unsigned char *)(I2C3_BLOCK + 0x8) // I2C3 SMBus Control and Status Register
    #define I2C3_A2                      *(unsigned char *)(I2C3_BLOCK + 0x9) // I2C3 Address Register 2
    #define I2C3_SLTH                    *(unsigned char *)(I2C3_BLOCK + 0xa) // I2C3 SCL Low Timeout Register High
    #define I2C3_SLTL                    *(unsigned char *)(I2C3_BLOCK + 0xb) // I2C3 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C3_S2                  *(volatile unsigned char *)(I2C2_BLOCK + 0xc) // I2C2 Status Register 2
    #endif
#endif

typedef struct stKINETIS_I2C_CONTROL
{
    unsigned char I2C_A1;
    unsigned char I2C_F;
    volatile unsigned char I2C_C1;
    volatile unsigned char I2C_S;
    volatile unsigned char I2C_D;
    volatile unsigned char I2C_C2;
    volatile unsigned char I2C_FLT;
    unsigned char I2C_RA;
    volatile unsigned char I2C_SMB;
    unsigned char I2C_A2;
    unsigned char I2C_SLTH;
    unsigned char I2C_SLTL;
    #if defined DOUBLE_BUFFERED_I2C
        volatile unsigned char I2C_S2;
    #endif
} KINETIS_I2C_CONTROL;


// CAN Configuration module
//
#define CAN0_MCR             *(volatile unsigned long *)(CAN0_BASE_ADD + 0x0) // CAN Module Configuration Register
  #define CAN_MDIS           0x80000000                                  // module disable
  #define CAN_FRZ            0x40000000                                  // freeze enable
  #define CAN_RFEN           0x20000000                                  // rx-fifo enable
  #define CAN_HALT           0x10000000                                  // halt FlexCAN
  #define CAN_NOTRDY         0x08000000                                  // FlexCAN not ready (read-only)
  #define CAN_WAKMSK         0x04000000                                  // wake up interrupt mask
  #define CAN_SOFTRST        0x02000000                                  // resets registers affected by the soft-reset
  #define CAN_FRZACK         0x01000000                                  // freeze mode acknowledge
  #define CAN_SUPV           0x00800000                                  // supervisor mode
  #define CAN_SLFWAK         0x00400000                                  // self wake up
  #define CAN_WRNEN          0x00200000                                  // warning interrupt enable
  #define CAN_LPMACK         0x00100000                                  // low power mode acknowledge
  #define CAN_SRXDIS         0x00020000                                  // self reception disable
  #define CAN_IRMQ           0x00010000                                  // Individual Rx Masking and Queue enable
  #define CAN_LPRIOEN        0x00002000                                  // local priority enable
  #define CAN_AEN            0x00001000                                  // abort enable
  #define CAN_IDAM_A         0x00000000                                  // ID acceptance modes - one full ID
  #define CAN_IDAM_B         0x00000100                                  // ID acceptance modes - two full standard or two partial
  #define CAN_IDAM_C         0x00000200                                  // ID acceptance modes - four partial 8-bit standard
  #define CAN_IDAM_D         0x00000300                                  // ID acceptance modes - all frames rejected
  #define CAN_MAXMB_MASK     0x0000007f                                  // ID acceptance modes 
#define CAN0_CTRL1           *(volatile unsigned long *)(CAN0_BASE_ADD + 0x4) // CAN Control Register 1
  #define CAN_DIV_3          (0x02 << 24)
  #define EXTAL_CLK_SOURCE   0                                           // use crystal source for clock (lower jitter than PLL)
  #define RJW_0              (0 << 22)
  #define RJW_1              (1 << 22)
  #define RJW_2              (2 << 22)
  #define RJW_3              (3 << 22)
  #define PHASE_BUF_SEG1_LEN1 (0 << 19)
  #define PHASE_BUF_SEG1_LEN2 (1 << 19)
  #define PHASE_BUF_SEG1_LEN3 (2 << 19)
  #define PHASE_BUF_SEG1_LEN4 (3 << 19)
  #define PHASE_BUF_SEG1_LEN5 (4 << 19)
  #define PHASE_BUF_SEG1_LEN6 (5 << 19)
  #define PHASE_BUF_SEG1_LEN7 (6 << 19)
  #define PHASE_BUF_SEG1_LEN8 (7 << 19)
  #define PHASE_BUF_SEG2_LEN1 (0 << 16)
  #define PHASE_BUF_SEG2_LEN2 (1 << 16)
  #define PHASE_BUF_SEG2_LEN3 (2 << 16)
  #define PHASE_BUF_SEG2_LEN4 (3 << 16)
  #define PHASE_BUF_SEG2_LEN5 (4 << 16)
  #define PHASE_BUF_SEG2_LEN6 (5 << 16)
  #define PHASE_BUF_SEG2_LEN7 (6 << 16)
  #define PHASE_BUF_SEG2_LEN8 (7 << 16)
  #define BOFFMSK            0x00008000                                  // Bus off interrupt mask
  #define ERRMSK             0x00004000                                  // Error interrupt mask
  #define CLK_SRC_PERIPH_CLK 0x00002000                                  // Clock source is the peripheral clock
  #define LPB                0x00001000                                  // Loop Back Mode
  #define TWRNMSK            0x00000800                                  // Tx warning Interrupt mask
  #define RWRNMSK            0x00000400                                  // Rx warning Interrupt mask
  #define SMP                0x00000080                                  // Sampling Mode - three samples decide rx value
  #define BOFFREC            0x00000040                                  // Bus off recovery mode disable
  #define TSYN               0x00000020                                  // Timer synchronisation
  #define LBUF               0x00000010                                  // Lowest number buffer transmitted first
  #define LOM                0x00000008                                  // Listen-only mode
  #define PROPSEG_BIT_TIME1  (0)
  #define PROPSEG_BIT_TIME2  (1)
  #define PROPSEG_BIT_TIME3  (2)
  #define PROPSEG_BIT_TIME4  (3)
  #define PROPSEG_BIT_TIME5  (4)
  #define PROPSEG_BIT_TIME6  (5)
  #define PROPSEG_BIT_TIME7  (6)
  #define PROPSEG_BIT_TIME8  (7)
#define CAN0_TIMER           *(volatile unsigned long *)(CAN0_BASE_ADD + 0x8) // CAN Free running timer

#define CAN0_RXGMASK         *(unsigned long *)(CAN0_BASE_ADD + 0x10)    // CAN Rx Global mask
#define CAN0_RX14MASK        *(unsigned long *)(CAN0_BASE_ADD + 0x14)    // CAN Rx Buffer 14 mask
#define CAN0_RX15MASK        *(unsigned long *)(CAN0_BASE_ADD + 0x18)    // CAN Rx Buffer 15 mask
#define CAN0_ECR             *(volatile unsigned long *)(CAN0_BASE_ADD + 0x1c) // CAN Error Counter Register
#define CAN0_ESR1            *(volatile unsigned long *)(CAN0_BASE_ADD + 0x20) // CAN Error and Status 1 Register
  #define BIT1ERROR          0x00008000
  #define BIT0ERROR          0x00004000
  #define CAN_ACK_ERR        0x00002000
  #define CAN_CRC_ERR        0x00001000
  #define CAN_FRM_ERR        0x00000800
  #define CAN_STF_ERR        0x00000400
  #define TXWRN              0x00000200
  #define RXWRN              0x00000100
  #define CAN_BUS_IDLE       0x00000080
  #define CAN_ERROR_PASSIVE  0x00000010
  #define BOFFINT            0x00000004
  #define ERRINT             0x00000002
#define CAN0_IMASK2          *(unsigned long *)(CAN0_BASE_ADD + 0x24)    // CAN Interrupt Mask Register 2
#define CAN0_IMASK1          *(unsigned long *)(CAN0_BASE_ADD + 0x28)    // CAN Interrupt Mask Register 1
#define CAN0_IFLAG2          *(volatile unsigned long *)(CAN0_BASE_ADD + 0x2c) // CAN Interrupt Flag Register 2
#define CAN0_IFLAG1          *(volatile unsigned long *)(CAN0_BASE_ADD + 0x30) // CAN Interrupt Flag Register 1
  #define CAN_BUF_0_INT      0x00000001
  #define CAN_BUF_1_INT      0x00000002
  #define CAN_BUF_2_INT      0x00000004
  #define CAN_BUF_3_INT      0x00000008
  #define CAN_BUF_4_INT      0x00000010
  #define CAN_BUF_5_INT      0x00000020
  #define CAN_BUF_6_INT      0x00000040
  #define CAN_BUF_7_INT      0x00000080
  #define CAN_BUF_8_INT      0x00000100
  #define CAN_BUF_9_INT      0x00000200
  #define CAN_BUF_10_INT     0x00000400
  #define CAN_BUF_11_INT     0x00000800
  #define CAN_BUF_12_INT     0x00001000
  #define CAN_BUF_13_INT     0x00002000
  #define CAN_BUF_14_INT     0x00004000
  #define CAN_BUF_15_INT     0x00008000
#define CAN0_CTRL2           *(unsigned long *)(CAN0_BASE_ADD + 0x34)    // CAN Control Register 2
#define CAN0_ESR2            *(volatile unsigned long *)(CAN0_BASE_ADD + 0x38) // CAN Error and Status Register 2

#define CAN0_CRCR            *(volatile unsigned long *)(CAN0_BASE_ADD + 0x44) // CAN CRC Register
#define CAN0_RXFGMASK        *(unsigned long *)(CAN0_BASE_ADD + 0x48)    // CAN FIFO Global mask Register
#define CAN0_RXFIR           *(volatile unsigned long *)(CAN0_BASE_ADD + 0x4c) // CAN FIFI Information Register (read-only)

  #define CAN_ALL_BUFFERS_INT (CAN_BUF_0_INT | CAN_BUF_1_INT | CAN_BUF_2_INT | CAN_BUF_3_INT | CAN_BUF_4_INT | CAN_BUF_5_INT | CAN_BUF_6_INT | CAN_BUF_7_INT | CAN_BUF_8_INT | CAN_BUF_9_INT | CAN_BUF_10_INT | CAN_BUF_11_INT | CAN_BUF_12_INT | CAN_BUF_13_INT | CAN_BUF_14_INT | CAN_BUF_15_INT)

#define MAX_TX_CAN_TRIES     5                                           // let the controller try this many times before declaring a transmission error

#define MB_RX_INACTIVE       0x00000000
#define MB_RX_EMPTY          0x04000000
#define MB_RX_FULL           0x02000000
#define MB_RX_OVERRUN        0x06000000
#define MB_RX_BUSY_BIT       0x01000000
#define MB_TX_INACTIVE       0x08000000
#define MB_TX_SEND_ONCE      0x0c000000
#define MB_TX_SEND_ON_REQ    0x0a000000

#define CAN_CODE_FIELD       0x0f000000                                 // CODE field mask
#define CAN_RX_CODE_FIELD    0x07000000

#define SRR                  0x00400000                                 // Substitute remote request
#define IDE                  0x00200000                                 // ID extended bit
#define RTR                  0x00100000                                 // Remote transmission request

#define CAN_LENGTH_AND_TIME  0x000fffff
#define CAN_KEEP_CONTENTS    0x00ffffff
#define CAN_EXTENDED_MASK    0x1fffffff
#define CAN_STANDARD_MASK    0x7ff
#define CAN_STANDARD_BITMASK 0x1ffc0000
#define CAN_STANDARD_SHIFT   18

#define MBUFF0_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x80)   // CAN Message Buffer 0 (16 bytes)
#define MBUFF1_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x90)   // CAN Message Buffer 1 (16 bytes)
#define MBUFF2_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xa0)   // CAN Message Buffer 2 (16 bytes)
#define MBUFF3_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xb0)   // CAN Message Buffer 3 (16 bytes)
#define MBUFF4_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xc0)   // CAN Message Buffer 4 (16 bytes)
#define MBUFF5_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xd0)   // CAN Message Buffer 5 (16 bytes)
#define MBUFF6_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xe0)   // CAN Message Buffer 6 (16 bytes)
#define MBUFF7_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xf0)   // CAN Message Buffer 7 (16 bytes)
#define MBUFF8_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x100)  // CAN Message Buffer 8 (16 bytes)
#define MBUFF9_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x110)  // CAN Message Buffer 9 (16 bytes)
#define MBUFF10_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x120)  // CAN Message Buffer 10 (16 bytes)
#define MBUFF11_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x130)  // CAN Message Buffer 11 (16 bytes)
#define MBUFF12_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x140)  // CAN Message Buffer 12 (16 bytes)
#define MBUFF13_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x150)  // CAN Message Buffer 13 (16 bytes)
#define MBUFF14_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x160)  // CAN Message Buffer 14 (16 bytes)
#define MBUFF15_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x170)  // CAN Message Buffer 15 (16 bytes)

#define CAN0_RXIMR0          *(unsigned long *)(CAN0_BASE_ADD + 0x880)   // CAN Rx Individual Mask Register 0
#define CAN0_RXIMR1          *(unsigned long *)(CAN0_BASE_ADD + 0x884)   // CAN Rx Individual Mask Register 1
#define CAN0_RXIMR2          *(unsigned long *)(CAN0_BASE_ADD + 0x888)   // CAN Rx Individual Mask Register 2
#define CAN0_RXIMR3          *(unsigned long *)(CAN0_BASE_ADD + 0x88c)   // CAN Rx Individual Mask Register 3
#define CAN0_RXIMR4          *(unsigned long *)(CAN0_BASE_ADD + 0x890)   // CAN Rx Individual Mask Register 4
#define CAN0_RXIMR5          *(unsigned long *)(CAN0_BASE_ADD + 0x894)   // CAN Rx Individual Mask Register 5
#define CAN0_RXIMR6          *(unsigned long *)(CAN0_BASE_ADD + 0x898)   // CAN Rx Individual Mask Register 6
#define CAN0_RXIMR7          *(unsigned long *)(CAN0_BASE_ADD + 0x89c)   // CAN Rx Individual Mask Register 7
#define CAN0_RXIMR8          *(unsigned long *)(CAN0_BASE_ADD + 0x8a0)   // CAN Rx Individual Mask Register 8
#define CAN0_RXIMR9          *(unsigned long *)(CAN0_BASE_ADD + 0x8a4)   // CAN Rx Individual Mask Register 9
#define CAN0_RXIMR10         *(unsigned long *)(CAN0_BASE_ADD + 0x8a8)   // CAN Rx Individual Mask Register 10
#define CAN0_RXIMR11         *(unsigned long *)(CAN0_BASE_ADD + 0x8ac)   // CAN Rx Individual Mask Register 11
#define CAN0_RXIMR12         *(unsigned long *)(CAN0_BASE_ADD + 0x8b0)   // CAN Rx Individual Mask Register 12
#define CAN0_RXIMR13         *(unsigned long *)(CAN0_BASE_ADD + 0x8b4)   // CAN Rx Individual Mask Register 13
#define CAN0_RXIMR14         *(unsigned long *)(CAN0_BASE_ADD + 0x8b8)   // CAN Rx Individual Mask Register 14
#define CAN0_RXIMR15         *(unsigned long *)(CAN0_BASE_ADD + 0x8bc)   // CAN Rx Individual Mask Register 15



#if NUMBER_OF_CAN_INTERFACES > 1
    #define CAN1_MCR         *(volatile unsigned long *)(CAN1_BASE_ADD + 0x0) // CAN Module Configuration Register (supervisor only)
    #define CAN1_CTRL1       *(volatile unsigned long *)(CAN1_BASE_ADD + 0x4) // CAN Control Register 1
    #define CAN1_TIMER       *(volatile unsigned long *)(CAN1_BASE_ADD + 0x8) // CAN Free running timer
    #define CAN1_RXGMASK     *(unsigned long *)(CAN1_BASE_ADD + 0x10)    // CAN Rx Global mask
    #define CAN1_RX14MASK    *(unsigned long *)(CAN1_BASE_ADD + 0x14)    // CAN Rx Buffer 14 mask
    #define CAN1_RX15MASK    *(unsigned long *)(CAN1_BASE_ADD + 0x18)    // CAN Rx Buffer 15 mask
    #define CAN1_ECR         *(volatile unsigned long *)(CAN1_BASE_ADD + 0x1c) // CAN Error Counter Register
    #define CAN1_ESR1        *(volatile unsigned long *)(CAN1_BASE_ADD + 0x20) // CAN Error and Status 1 Register
    #define CAN1_IMASK2      *(unsigned long *)(CAN1_BASE_ADD + 0x24)    // CAN Interrupt Mask Register 2
    #define CAN1_IMASK1      *(unsigned long *)(CAN1_BASE_ADD + 0x28)    // CAN Interrupt Mask Register 1
    #define CAN1_IFLAG2      *(unsigned long *)(CAN1_BASE_ADD + 0x2c)    // CAN Interrupt Flag Register 1
    #define CAN1_IFLAG1      *(unsigned long *)(CAN1_BASE_ADD + 0x30)    // CAN Interrupt Flag Register 1
    #define CAN1_CTRL2       *(unsigned long *)(CAN1_BASE_ADD + 0x34)    // CAN Control Register 2
    #define CAN1_ESR2        *(volatile unsigned long *)(CAN1_BASE_ADD + 0x38) // CAN Error and Status Register 2

    #define CAN1_CRCR        *(volatile unsigned long *)(CAN1_BASE_ADD + 0x44) // CAN CRC Register
    #define CAN1_RXFGMASK    *(unsigned long *)(CAN1_BASE_ADD + 0x48)    // CAN FIFO Global mask Register
    #define CAN1_RXFIR       *(volatile unsigned long *)(CAN1_BASE_ADD + 0x4c) // CAN FIFI Information Register (read-only)

    #define MBUFF0_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x80)   // CAN Message Buffer 0 (16 bytes)
    #define MBUFF1_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x90)   // CAN Message Buffer 1 (16 bytes)
    #define MBUFF2_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xa0)   // CAN Message Buffer 2 (16 bytes)
    #define MBUFF3_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xb0)   // CAN Message Buffer 3 (16 bytes)
    #define MBUFF4_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xc0)   // CAN Message Buffer 4 (16 bytes)
    #define MBUFF5_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xd0)   // CAN Message Buffer 5 (16 bytes)
    #define MBUFF6_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xe0)   // CAN Message Buffer 6 (16 bytes)
    #define MBUFF7_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xf0)   // CAN Message Buffer 7 (16 bytes)
    #define MBUFF8_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x100)  // CAN Message Buffer 8 (16 bytes)
    #define MBUFF9_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x110)  // CAN Message Buffer 9 (16 bytes)
    #define MBUFF10_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x120)  // CAN Message Buffer 10 (16 bytes)
    #define MBUFF11_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x130)  // CAN Message Buffer 11 (16 bytes)
    #define MBUFF12_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x140)  // CAN Message Buffer 12 (16 bytes)
    #define MBUFF13_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x150)  // CAN Message Buffer 13 (16 bytes)
    #define MBUFF14_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x160)  // CAN Message Buffer 14 (16 bytes)
    #define MBUFF15_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x170)  // CAN Message Buffer 15 (16 bytes)

    #define CAN1_RXIMR0      *(unsigned long *)(CAN1_BASE_ADD + 0x880)   // CAN Rx Individual Mask Register 0
    #define CAN1_RXIMR1      *(unsigned long *)(CAN1_BASE_ADD + 0x884)   // CAN Rx Individual Mask Register 1
    #define CAN1_RXIMR2      *(unsigned long *)(CAN1_BASE_ADD + 0x888)   // CAN Rx Individual Mask Register 2
    #define CAN1_RXIMR3      *(unsigned long *)(CAN1_BASE_ADD + 0x88c)   // CAN Rx Individual Mask Register 3
    #define CAN1_RXIMR4      *(unsigned long *)(CAN1_BASE_ADD + 0x890)   // CAN Rx Individual Mask Register 4
    #define CAN1_RXIMR5      *(unsigned long *)(CAN1_BASE_ADD + 0x894)   // CAN Rx Individual Mask Register 5
    #define CAN1_RXIMR6      *(unsigned long *)(CAN1_BASE_ADD + 0x898)   // CAN Rx Individual Mask Register 6
    #define CAN1_RXIMR7      *(unsigned long *)(CAN1_BASE_ADD + 0x89c)   // CAN Rx Individual Mask Register 7
    #define CAN1_RXIMR8      *(unsigned long *)(CAN1_BASE_ADD + 0x8a0)   // CAN Rx Individual Mask Register 8
    #define CAN1_RXIMR9      *(unsigned long *)(CAN1_BASE_ADD + 0x8a4)   // CAN Rx Individual Mask Register 9
    #define CAN1_RXIMR10     *(unsigned long *)(CAN1_BASE_ADD + 0x8a8)   // CAN Rx Individual Mask Register 10
    #define CAN1_RXIMR11     *(unsigned long *)(CAN1_BASE_ADD + 0x8ac)   // CAN Rx Individual Mask Register 11
    #define CAN1_RXIMR12     *(unsigned long *)(CAN1_BASE_ADD + 0x8b0)   // CAN Rx Individual Mask Register 12
    #define CAN1_RXIMR13     *(unsigned long *)(CAN1_BASE_ADD + 0x8b4)   // CAN Rx Individual Mask Register 13
    #define CAN1_RXIMR14     *(unsigned long *)(CAN1_BASE_ADD + 0x8b8)   // CAN Rx Individual Mask Register 14
    #define CAN1_RXIMR15     *(unsigned long *)(CAN1_BASE_ADD + 0x8bc)   // CAN Rx Individual Mask Register 15
#endif

#if defined MSCAN_CAN_INTERFACE
    #define MSCAN_CANCTL0    *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x00)   // MSCAN control register 0
      #define MSCAN_CANCTL0_INITRQ    0x01                               // initialisation mode request
      #define MSCAN_CANCTL0_SLPRQ     0x02                               // sleep mode request
      #define MSCAN_CANCTL0_WUPE      0x04                               // wakeup enable
      #define MSCAN_CANCTL0_TIME      0x08                               // timer enable
      #define MSCAN_CANCTL0_SYNCH     0x10                               // synchronised status
      #define MSCAN_CANCTL0_CSWAI     0x20                               // CAN stops in wait mode
      #define MSCAN_CANCTL0_RXACT     0x40                               // receiver active status
      #define MSCAN_CANCTL0_RXFRM     0x80                               // received frame flag
    #define MSCAN_CANCTL1    *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x01) // MSCAN control register 1
      #define MSCAN_CANCTL1_INITAK    0x01                               // initialisation mode acknowledge
      #define MSCAN_CANCTL1_SLPAK     0x02                               // sleep mode acknowledge
      #define MSCAN_CANCTL1_WUPM      0x04                               // wakeup mode
      #define MSCAN_CANCTL1_BORM      0x08                               // bus-off recovery mode
      #define MSCAN_CANCTL1_LISTEN    0x10                               // listen only mode
      #define MSCAN_CANCTL1_LOOPB     0x20                               // loopback self test mode
      #define MSCAN_CANCTL1_CLKSRC    0x40                               // MSCAN clock source
      #define MSCAN_CANCTL1_CANE      0x80                               // MSCAN enable
    #define MSCAN_CANBTR0    *(unsigned char *)(MSCAN_BASE_ADD + 0x02)   // MSCAN bus timing register 0
    #define MSCAN_CANBTR1    *(unsigned char *)(MSCAN_BASE_ADD + 0x03)   // MSCAN bus timing register 1
    #define MSCAN_CANRFLG    *(unsigned char *)(MSCAN_BASE_ADD + 0x04)   // MSCAN receiver flag register
    #define MSCAN_CANRIER    *(unsigned char *)(MSCAN_BASE_ADD + 0x05)   // MSCAN receiver interrupt enable register
    #define MSCAN_CANTFLG    *(unsigned char *)(MSCAN_BASE_ADD + 0x06)   // MSCAN transmitter flag register
      #define MSCAN_CANTFLG_TXE0      0x01                               // transmit buffer 0 empty flag
      #define MSCAN_CANTFLG_TXE1      0x02                               // transmit buffer 0 empty flag
      #define MSCAN_CANTFLG_TXE2      0x04                               // transmit buffer 0 empty flag
    #define MSCAN_CANTIER    *(unsigned char *)(MSCAN_BASE_ADD + 0x07)   // MSCAN transmitter interrupt enable register
    #define MSCAN_CANTARQ    *(unsigned char *)(MSCAN_BASE_ADD + 0x08)   // MSCAN transmitter message abort request register
    #define MSCAN_CANTAAK    *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x09) // MSCAN transmitter message abort acknowledge register (read-only)
    #define MSCAN_CANTBSEL   *(unsigned char *)(MSCAN_BASE_ADD + 0x0a)   // MSCAN transmit buffer select register
    #define MSCAN_CANIDAC    *(unsigned char *)(MSCAN_BASE_ADD + 0x0b)   // MSCAN identifier acceptance control register
    #define MSCAN_CANMISC    *(unsigned char *)(MSCAN_BASE_ADD + 0x0d)   // MSCAN miscellaneous register
    #define MSCAN_CANRXERR   *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x0e) // MSCAN receive error counter (read-only)
    #define MSCAN_CANTXERR   *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x0f) // MSCAN transmit error counter (read-only)
    #define MSCAN_CANIDAR0   *(unsigned char *)(MSCAN_BASE_ADD + 0x10)   // MSCAN identifier acceptance register 0 of first bank
    #define MSCAN_CANIDAR1   *(unsigned char *)(MSCAN_BASE_ADD + 0x11)   // MSCAN identifier acceptance register 1 of first bank
    #define MSCAN_CANIDAR2   *(unsigned char *)(MSCAN_BASE_ADD + 0x12)   // MSCAN identifier acceptance register 2 of first bank
    #define MSCAN_CANIDAR3   *(unsigned char *)(MSCAN_BASE_ADD + 0x13)   // MSCAN identifier acceptance register 3 of first bank
    #define MSCAN_CANIDMR0   *(unsigned char *)(MSCAN_BASE_ADD + 0x14)   // MSCAN identifier mask register 0 or first bank
    #define MSCAN_CANIDMR1   *(unsigned char *)(MSCAN_BASE_ADD + 0x15)   // MSCAN identifier mask register 1 or first bank
    #define MSCAN_CANIDMR2   *(unsigned char *)(MSCAN_BASE_ADD + 0x16)   // MSCAN identifier mask register 2 or first bank
    #define MSCAN_CANIDMR3   *(unsigned char *)(MSCAN_BASE_ADD + 0x17)   // MSCAN identifier mask register 3 or first bank
    #define MSCAN_CANIDAR4   *(unsigned char *)(MSCAN_BASE_ADD + 0x18)   // MSCAN identifier acceptance register 4 of second bank
    #define MSCAN_CANIDAR5   *(unsigned char *)(MSCAN_BASE_ADD + 0x19)   // MSCAN identifier acceptance register 5 of second bank
    #define MSCAN_CANIDAR6   *(unsigned char *)(MSCAN_BASE_ADD + 0x1a)   // MSCAN identifier acceptance register 6 of second bank
    #define MSCAN_CANIDAR7   *(unsigned char *)(MSCAN_BASE_ADD + 0x1b)   // MSCAN identifier acceptance register 7 of second bank
    #define MSCAN_CANIDMR4   *(unsigned char *)(MSCAN_BASE_ADD + 0x1c)   // MSCAN identifier mask register 4 or second bank
    #define MSCAN_CANIDMR5   *(unsigned char *)(MSCAN_BASE_ADD + 0x1d)   // MSCAN identifier mask register 5 or second bank
    #define MSCAN_CANIDMR6   *(unsigned char *)(MSCAN_BASE_ADD + 0x1e)   // MSCAN identifier mask register 6 or second bank
    #define MSCAN_CANIDMR7   *(unsigned char *)(MSCAN_BASE_ADD + 0x1f)   // MSCAN identifier mask register 7 or second bank
    #define MSCAN_REIDR0     *(unsigned char *)(MSCAN_BASE_ADD + 0x20)   // MSCAN receive extended identifier register 0
    #define MSCAN_RSIDR0     *(unsigned char *)(MSCAN_BASE_ADD + 0x20)   // MSCAN receive standard identifier register 0
    #define MSCAN_REIDR1     *(unsigned char *)(MSCAN_BASE_ADD + 0x21)   // MSCAN receive extended identifier register 1
    #define MSCAN_RSIDR1     *(unsigned char *)(MSCAN_BASE_ADD + 0x21)   // MSCAN receive standard identifier register 1
    #define MSCAN_REIDR2     *(unsigned char *)(MSCAN_BASE_ADD + 0x22)   // MSCAN receive extended identifier register 2
    #define MSCAN_REIDR3     *(unsigned char *)(MSCAN_BASE_ADD + 0x23)   // MSCAN receive extended identifier register 3
    #define MSCAN_REDSR0     *(unsigned char *)(MSCAN_BASE_ADD + 0x24)   // MSCAN receive extended data segment register 0
    #define MSCAN_REDSR1     *(unsigned char *)(MSCAN_BASE_ADD + 0x25)   // MSCAN receive extended data segment register 1
    #define MSCAN_REDSR2     *(unsigned char *)(MSCAN_BASE_ADD + 0x26)   // MSCAN receive extended data segment register 2
    #define MSCAN_REDSR3     *(unsigned char *)(MSCAN_BASE_ADD + 0x27)   // MSCAN receive extended data segment register 3
    #define MSCAN_REDSR4     *(unsigned char *)(MSCAN_BASE_ADD + 0x28)   // MSCAN receive extended data segment register 4
    #define MSCAN_REDSR5     *(unsigned char *)(MSCAN_BASE_ADD + 0x29)   // MSCAN receive extended data segment register 5
    #define MSCAN_REDSR6     *(unsigned char *)(MSCAN_BASE_ADD + 0x2a)   // MSCAN receive extended data segment register 6
    #define MSCAN_REDSR7     *(unsigned char *)(MSCAN_BASE_ADD + 0x2b)   // MSCAN receive extended data segment register 7
    #define MSCAN_RDLR       *(unsigned char *)(MSCAN_BASE_ADD + 0x2c)   // MSCAN receive data length register
    #define MSCAN_RTSRH      *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x2e) // MSCAN receive time stamp register high (read-only)
    #define MSCAN_RTSRL      *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x2f) // MSCAN receive time stamp register low (read-only)
    #define MSCAN_TEIDR0     *(unsigned char *)(MSCAN_BASE_ADD + 0x30)   // MSCAN transmit extended identifier register 0
    #define MSCAN_TSIDR0     *(unsigned char *)(MSCAN_BASE_ADD + 0x30)   // MSCAN transmit standard identifier register 0
    #define MSCAN_TEIDR1     *(unsigned char *)(MSCAN_BASE_ADD + 0x31)   // MSCAN transmit extended identifier register 1
    #define MSCAN_TSIDR1     *(unsigned char *)(MSCAN_BASE_ADD + 0x31)   // MSCAN transmit standard identifier register 1
    #define MSCAN_TEIDR2     *(unsigned char *)(MSCAN_BASE_ADD + 0x32)   // MSCAN transmit extended identifier register 2
    #define MSCAN_TEIDR3     *(unsigned char *)(MSCAN_BASE_ADD + 0x33)   // MSCAN transmit extended identifier register 3
    #define MSCAN_TEDSR0     *(unsigned char *)(MSCAN_BASE_ADD + 0x34)   // MSCAN transmit extended data segment register 0
    #define MSCAN_TEDSR1     *(unsigned char *)(MSCAN_BASE_ADD + 0x35)   // MSCAN transmit extended data segment register 1
    #define MSCAN_TEDSR2     *(unsigned char *)(MSCAN_BASE_ADD + 0x36)   // MSCAN transmit extended data segment register 2
    #define MSCAN_TEDSR3     *(unsigned char *)(MSCAN_BASE_ADD + 0x37)   // MSCAN transmit extended data segment register 3
    #define MSCAN_TEDSR4     *(unsigned char *)(MSCAN_BASE_ADD + 0x38)   // MSCAN transmit extended data segment register 4
    #define MSCAN_TEDSR5     *(unsigned char *)(MSCAN_BASE_ADD + 0x39)   // MSCAN transmit extended data segment register 5
    #define MSCAN_TEDSR6     *(unsigned char *)(MSCAN_BASE_ADD + 0x3a)   // MSCAN transmit extended data segment register 6
    #define MSCAN_TEDSR7     *(unsigned char *)(MSCAN_BASE_ADD + 0x3b)   // MSCAN transmit extended data segment register 7
    #define MSCAN_TDLR       *(unsigned char *)(MSCAN_BASE_ADD + 0x3c)   // MSCAN transmit data length register
    #define MSCAN_TBPR       *(unsigned char *)(MSCAN_BASE_ADD + 0x3d)   // MSCAN transmit buffer priority register
    #define MSCAN_TTSRH      *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x3e) // MSCAN transmit time stamp register high (read-only)
    #define MSCAN_TTSRL      *(volatile unsigned char *)(MSCAN_BASE_ADD + 0x3f) // MSCAN transmit time stamp register low (read-only)
#endif

#if defined MSCAN_CAN_INTERFACE
    #define NUMBER_CAN_RX_MESSAGE_BUFFERS  5
    #define NUMBER_CAN_TX_MESSAGE_BUFFERS  3
    #define NUMBER_CAN_MESSAGE_BUFFERS   (NUMBER_CAN_RX_MESSAGE_BUFFERS + NUMBER_CAN_TX_MESSAGE_BUFFERS)
#else
    #define NUMBER_CAN_MESSAGE_BUFFERS 16                                // each CAN controller has 16 message buffers that can be used as either tx or rx mailboxes
#endif


typedef struct stKINETIS_CAN_CONTROL
{
    volatile unsigned long CAN_MCR;
    volatile unsigned long CAN_CTRL1;
    volatile unsigned long CAN_TIMER;
    unsigned long res0;
    unsigned long CAN_RXGMASK;
    unsigned long CAN_RX14MASK;
    unsigned long CAN_RX15MASK;
    volatile unsigned long CAN_ECR;
    volatile unsigned long CAN_ESR1;
    unsigned long CAN_IMASK2;
    unsigned long CAN_IMASK1;
    volatile unsigned long CAN_IFLAG2;
    volatile unsigned long CAN_IFLAG1;
    unsigned long CAN_CTRL2;
    volatile unsigned long CAN_ESR2;
    unsigned long res1[2];
    volatile unsigned long CAN_CRCR;
    unsigned long CAN_RXFGMASK;
    volatile unsigned long CAN_RXFIR;
    unsigned long res2[524];
    unsigned long CAN_RXIMR0;
    unsigned long CAN_RXIMR1;
    unsigned long CAN_RXIMR2;
    unsigned long CAN_RXIMR3;
    unsigned long CAN_RXIMR4;
    unsigned long CAN_RXIMR5;
    unsigned long CAN_RXIMR6;
    unsigned long CAN_RXIMR7;
    unsigned long CAN_RXIMR8;
    unsigned long CAN_RXIMR9;
    unsigned long CAN_RXIMR10;
    unsigned long CAN_RXIMR11;
    unsigned long CAN_RXIMR12;
    unsigned long CAN_RXIMR13;
    unsigned long CAN_RXIMR14;
    unsigned long CAN_RXIMR15;
} KINETIS_CAN_CONTROL;


// UARTs
//
#if LPUARTS_AVAILABLE > 0                                                // {59} low power UART
    #define LPUART0_BAUD                 *(unsigned long *)(LPUART0_BLOCK + 0x00) // LPUART 0 Baud Rate Register
        #define LPUART_BAUD_SBR          0x00001fff                      // baud rate modulo divisor mask
        #define LPUART_BAUD_SBNS_1       0x00000000                      // 1 stop bits
        #define LPUART_BAUD_SBNS_2       0x00002000                      // 2 stop bits
        #define LPUART_BAUD_RXEDGIE      0x00004000                      // RX input active edge interrupt enable
        #define LPUART_BAUD_LBKDIE       0x00008000                      // LIN break detect interrupt enable
        #define LPUART_BAUD_RESYNCDIS    0x00010000                      // resynchronisation disable
        #define LPUART_BAUD_BOTHEDGE     0x00020000                      // both edge sampling
        #define LPUART_BAUD_MATCFG_ADDR  0x00000000
        #define LPUART_BAUD_MATCFG_IDLE  0x00040000
        #define LPUART_BAUD_MATCFG_ON_OFF 0x00080000
        #define LPUART_BAUD_MATCFG_CTS   0x000c0000
        #define LPUART_BAUD_RDMAE        0x00200000                      // receiver DMA enable (not KL03)
        #define LPUART_BAUD_TDMAE        0x00800000                      // transmitter DMA enable (not KL03)
        #define LPUART_BAUD_OSR_4        0x03000000                      // over sampling ratio x4 (change only when rx and tx are disabled)
        #define LPUART_BAUD_OSR_16       0x0f000000                      // over sampling ratio x16
        #define LPUART_BAUD_OSR_32       0x1f000000                      // over sampling ratio x32
        #define LPUART_BAUD_M10          0x20000000                      // 10-bit mode select
        #define LPUART_BAUD_MAEN2        0x40000000                      // match address mode enable 2
        #define LPUART_BAUD_MAEN1        0x80000000                      // match address mode enable 1
    #define LPUART0_STAT                 *(volatile unsigned long *)(LPUART0_BLOCK + 0x04) // LPUART 0 Status Register
        #define LPUART_STAT_MA2F         0x00004000                      // match 2 flag (write '1' to clear)
        #define LPUART_STAT_MA1F         0x00008000                      // match 1 flag (write '1' to clear)
        #define LPUART_STAT_PF           0x00010000                      // parity error flag (write '1' to clear)
        #define LPUART_STAT_FE           0x00020000                      // framing error flag (write '1' to clear)
        #define LPUART_STAT_NF           0x00040000                      // noise flag (write '1' to clear)
        #define LPUART_STAT_OR           0x00080000                      // receiver overrun flag (write '1' to clear)
        #define LPUART_STAT_IDLE         0x00100000                      // idle line flag (write '1' to clear)
        #define LPUART_STAT_RDRF         0x00200000                      // receive data register full flag (read-only)
        #define LPUART_STAT_TC           0x00400000                      // transmission complete flag (read-only)
        #define LPUART_STAT_TDRE         0x00800000                      // transmit data register empty flag (read-only)
        #define LPUART_STAT_RAF          0x01000000                      // receive active flag (read-only)
        #define LPUART_STAT_LBKDE        0x02000000                      // LIN break detection enable
        #define LPUART_STAT_BRK13        0x04000000                      // break character generation length
        #define LPUART_STAT_RWUID        0x08000000                      // receive wakeup idle detect
        #define LPUART_STAT_RXINV        0x10000000                      // receive data inversion
        #define LPUART_STAT_MSBF         0x20000000                      // MSB first
        #define LPUART_STAT_RXEDGIF      0x40000000                      // LPUART_RX pin active edge interrupt flag (write '1' to clear)
        #define LPUART_STAT_LBKDIF       0x80000000                      // LIN break detect interrupt flag (write '1' to clear)
    #define LPUART0_CTRL                 *(volatile unsigned long *)(LPUART0_BLOCK + 0x08) // LPUART 0 Control Register
        #define LPUART_CTRL_PT_EVEN      0x00000000                      // parity even
        #define LPUART_CTRL_PT_ODD       0x00000001                      // parity odd
        #define LPUART_CTRL_PE           0x00000002                      // parity enable
        #define LPUART_CTRL_ILT          0x00000004                      // idle line type select
        #define LPUART_CTRL_WAKE         0x00000008                      // receiver wakeup method select
        #define LPUART_CTRL_M            0x00000010                      // 9 bit mode select
        #define LPUART_CTRL_RSRC         0x00000020                      // receiver source select
        #define LPUART_CTRL_DOZEEN       0x00000040                      // doze enable
        #define LPUART_CTRL_LOOPS        0x00000080                      // loop mode select
        #define LPUART_CTRL_IDLECFG_1    0x00000000                      // idle configuration - 1 idle characters
        #define LPUART_CTRL_IDLECFG_2    0x00000100                      // idle configuration - 2 idle characters
        #define LPUART_CTRL_IDLECFG_4    0x00000200                      // idle configuration - 4 idle characters
        #define LPUART_CTRL_IDLECFG_8    0x00000300                      // idle configuration - 8 idle characters
        #define LPUART_CTRL_IDLECFG_16   0x00000400                      // idle configuration - 16 idle characters
        #define LPUART_CTRL_IDLECFG_32   0x00000500                      // idle configuration - 32 idle characters
        #define LPUART_CTRL_IDLECFG_64   0x00000600                      // idle configuration - 64 idle characters
        #define LPUART_CTRL_IDLECFG_128  0x00000700                      // idle configuration - 128 idle characters
        #define LPUART_CTRL_MA2IE        0x00004000                      // match 2 interrupt enable
        #define LPUART_CTRL_MA1IE        0x00008000                      // match 1 interrupt enable
        #define LPUART_CTRL_SBK          0x00010000                      // send break
        #define LPUART_CTRL_RWU          0x00020000                      // receiver wakeup control
        #define LPUART_CTRL_RE           0x00040000                      // receiver enable
        #define LPUART_CTRL_TE           0x00080000                      // transmitter enable
        #define LPUART_CTRL_ILIE         0x00100000                      // idle line interrupt enable
        #define LPUART_CTRL_RIE          0x00200000                      // receiver interrupt enable
        #define LPUART_CTRL_TCIE         0x00400000                      // transmit complete interrupt enable
        #define LPUART_CTRL_TIE          0x00800000                      // transmit interrupt enable
        #define LPUART_CTRL_PEIE         0x01000000                      // parity error interrupt enable
        #define LPUART_CTRL_FEIE         0x02000000                      // framing error interrupt enable
        #define LPUART_CTRL_NEIE         0x04000000                      // noise error interrupt enable
        #define LPUART_CTRL_ORIE         0x08000000                      // overrun interrupt enable
        #define LPUART_CTRL_TXINV        0x10000000                      // transmit data inversion
        #define LPUART_CTRL_TXDIR        0x20000000                      // LPUART_TX pin direction in single-wire mode
        #define LPUART_CTRL_R9T8         0x40000000                      // receive bit 9 / transmit bit 8
        #define LPUART_CTRL_R8T9         0x80000000                      // receive bit 8 / transmit bit 9
    #define LPUART0_DATA                 *(volatile unsigned long *)(LPUART0_BLOCK + 0x0c) // LPUART 0 Data Register
        #define LPUART_DATA_MASK         0x000003ff                      // data word mask
        #define LPUART_DATA_IDLINE       0x00000800                      // idle line
        #define LPUART_DATA_RXEMPT       0x00001000                      // receive buffer empty
        #define LPUART_DATA_FRETSC       0x00002000                      // frame error / transmit special character
        #define LPUART_DATA_PARITYE      0x00004000                      // the current received data word was received with a parity error
        #define LPUART_DATA_NOISY        0x00008000                      // the current received data word was received with noise
    #define LPUART0_MATCH                *(unsigned long *)(LPUART0_BLOCK + 0x10) // LPUART 0 Match Address Register
        #define LPUART_MATCH_MA1_MASK    0x000003ff                      // match address 1 mask
        #define LPUART_MATCH_MA2_MASK    0x03ff0000                      // match address 2 mask

    #if LPUARTS_AVAILABLE > 1
        #define LPUART1_BAUD             *(unsigned long *)(LPUART1_BLOCK + 0x00) // LPUART 1 Baud Rate Register
        #define LPUART1_STAT             *(volatile unsigned long *)(LPUART1_BLOCK + 0x04) // LPUART 1 Status Register
        #define LPUART1_CTRL             *(volatile unsigned long *)(LPUART1_BLOCK + 0x08) // LPUART 1 Control Register
        #define LPUART1_DATA             *(volatile unsigned long *)(LPUART1_BLOCK + 0x0c) // LPUART 1 Data Register
        #define LPUART1_MATCH            *(unsigned long *)(LPUART1_BLOCK + 0x10) // LPUART 1 Match Address Register
    #endif
    #if LPUARTS_AVAILABLE > 2
        #define LPUART2_BAUD             *(unsigned long *)(LPUART2_BLOCK + 0x00) // LPUART 2 Baud Rate Register
        #define LPUART2_STAT             *(volatile unsigned long *)(LPUART2_BLOCK + 0x04) // LPUART 2 Status Register
        #define LPUART2_CTRL             *(volatile unsigned long *)(LPUART2_BLOCK + 0x08) // LPUART 2 Control Register
        #define LPUART2_DATA             *(volatile unsigned long *)(LPUART2_BLOCK + 0x0c) // LPUART 2 Data Register
        #define LPUART2_MATCH            *(unsigned long *)(LPUART2_BLOCK + 0x10) // LPUART 2 Match Address Register
    #endif
    #if LPUARTS_AVAILABLE > 3
        #define LPUART3_BAUD             *(unsigned long *)(LPUART3_BLOCK + 0x00) // LPUART 3 Baud Rate Register
        #define LPUART3_STAT             *(volatile unsigned long *)(LPUART3_BLOCK + 0x04) // LPUART 3 Status Register
        #define LPUART3_CTRL             *(volatile unsigned long *)(LPUART3_BLOCK + 0x08) // LPUART 3 Control Register
        #define LPUART3_DATA             *(volatile unsigned long *)(LPUART3_BLOCK + 0x0c) // LPUART 3 Data Register
        #define LPUART3_MATCH            *(unsigned long *)(LPUART3_BLOCK + 0x10) // LPUART 3 Match Address Register
    #endif
    #if LPUARTS_AVAILABLE > 4
        #define LPUART4_BAUD             *(unsigned long *)(LPUART4_BLOCK + 0x00) // LPUART 4 Baud Rate Register
        #define LPUART4_STAT             *(volatile unsigned long *)(LPUART4_BLOCK + 0x04) // LPUART 4 Status Register
        #define LPUART4_CTRL             *(volatile unsigned long *)(LPUART4_BLOCK + 0x08) // LPUART 4 Control Register
        #define LPUART4_DATA             *(volatile unsigned long *)(LPUART4_BLOCK + 0x0c) // LPUART 4 Data Register
        #define LPUART4_MATCH            *(unsigned long *)(LPUART4_BLOCK + 0x10) // LPUART 4 Match Address Register
    #endif

    typedef struct stKINETIS_LPUART_CONTROL
    {
        unsigned long LPUART_BAUD;
        volatile unsigned long LPUART_STAT;
        volatile unsigned long LPUART_CTRL;
        volatile unsigned long LPUART_DATA;
        unsigned long LPUART_MATCH;
    } KINETIS_LPUART_CONTROL;
#endif

#define UART0_BDH                        *(volatile unsigned char *)(UART0_BLOCK + 0x00) // UART 0 Baud Rate Register: High (write order BDH followed by BDL)
  #define UART_BDH_RXEDGIE               0x40                            // rxd input active edge interrupt enable
  #define UART_BDH_LBKDIE                0x80                            // lin break detect interrupt enable
#define UART0_BDL                        *(volatile unsigned char *)(UART0_BLOCK + 0x01) // UART 0 Baud Rate Register: Low
#define UART0_C1                         *(unsigned char *)(UART0_BLOCK + 0x02) // UART 0 Control Register 1
  #define UART_C1_PARITY_DISABLED        0x00
  #define UART_C1_PT_EVEN                0x00                            // parity type even
  #define UART_C1_PT_ODD                 0x01                            // parity type odd
  #define UART_C1_PE                     0x02                            // parity enable
  #define UART_C1_ILT                    0x04                            // idle line type select
  #define UART_C1_WAKE                   0x08                            // receiver wakeup method select
  #define UART_C1_M                      0x10                            // 9-bit mode select
  #define UART_C1_RSRC                   0x20                            // receiver source select
  #define UART_C1_UARTSWAI               0x40                            // UART stops in wait mode
  #define UART_C1_LOOPS                  0x80                            // loop mode select
#define UART0_C2                         *(unsigned char *)(UART0_BLOCK + 0x03) // UART 0 Control Register 2
  #define UART_C2_SBK                    0x01                            // send break
  #define UART_C2_RWU                    0x02                            // receiver wakeup control
  #define UART_C2_RE                     0x04                            // receiver enable
  #define UART_C2_TE                     0x08                            // transmitter enable
  #define UART_C2_ILIE                   0x10                            // idle line interrupt enable
  #define UART_C2_RIE                    0x20                            // receiver full interrupt or DMA transfer enable
  #define UART_C2_TCIE                   0x40                            // transmission complete interrupt transmission enable
  #define UART_C2_TIE                    0x80                            // transmit interrupt or DMA transfer enable
#define UART0_S1                         *(volatile unsigned char *)(UART0_BLOCK + 0x04)   // UART 0 Status Register 1 (read-only)
  #define UART_S1_PF                     0x01                            // parity error flag
  #define UART_S1_FE                     0x02                            // framing error flag
  #define UART_S1_NF                     0x04                            // noise flag
  #define UART_S1_OR                     0x08                            // receiver overrun flag
  #define UART_S1_IDLE                   0x10                            // idle line flag
  #define UART_S1_RDRF                   0x20                            // receive data register full flag
  #define UART_S1_TC                     0x40                            // transmit complete flag
  #define UART_S1_TDRE                   0x80                            // transmit data register empty flag
#define UART0_S2                         *(volatile unsigned char *)(UART0_BLOCK + 0x05) // UART 0 Status Register 2
  #define UART_S2_RAF                    0x01                            // receiver active flag
  #define UART_S2_LBKDE                  0x02                            // LIN break detection enable
  #define UART_S2_BRK13                  0x04                            // break transmit character length
  #define UART_S2_RWUID                  0x08                            // receive wakeup idle detect
  #define UART_S2_RXINV                  0x10                            // receive data inversion
  #define UART_S2_MSBF                   0x20                            // most significant bit first
  #define UART_S2_RXEDGIF                0x40                            // RxD pin active edge interrupt flag - cleared by writing a '1'
  #define UART_S2_LBKDIF                 0x80                            // LIN break detect interrupt flag (write '1' to clear)
#define UART0_C3                         *(volatile unsigned char *)(UART0_BLOCK + 0x06) // UART 0 Control Register 3
  #define UART_C3_PEIE                   0x01                            // parity error interrupt enable
  #define UART_C3_FEIE                   0x02                            // framing error interrupt enable
  #define UART_C3_NEIE                   0x04                            // noise error interrupt enable
  #define UART_C3_ORIE                   0x08                            // overrun error interrupt enable
  #define UART_C3_TXINV                  0x10                            // transmit data inversion
  #define UART_C3_TXDIR                  0x20                            // transmitter pin data direction in single-wire mode
  #define UART_C3_T8                     0x40                            // transmit bit 8
  #define UART_C3_R8                     0x80                            // receive bit 8
#define UART0_D                          *(volatile unsigned char *)(UART0_BLOCK + 0x07) // UART 0 Data Register
#if !defined KINETIS_KE
    #define UART0_MA1                    *(unsigned char *)(UART0_BLOCK + 0x08) // UART 0 Match Address Registers 1
    #define UART0_MA2                    *(unsigned char *)(UART0_BLOCK + 0x09) // UART 0 Match Address Registers 2
    #define UART0_C4                     *(unsigned char *)(UART0_BLOCK + 0x0a) // UART 0 Control Register 4
      #define UART_C4_BRFA_MASK          0x1f                            // baud rate fine adjust
      #define UART_C4_M10                0x20                            // 10-bit mode select
      #define UART_C4_MAEN2              0x40                            // match address mode enable 2
      #define UART_C4_MAEN1              0x80                            // match address mode enable 1
    #define UART0_C5                     *(unsigned char *)(UART0_BLOCK + 0x0b) // UART 0 Control Register 5
      #define UART_C5_RDMAS              0x20                            // receive DMA select
      #define UART_C5_TDMAS              0x80                            // transmit DMA select
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    #define UART0_ED                     *(volatile unsigned char *)(UART0_BLOCK + 0x0c) // UART 0 Extended Data Register (read-only)
      #define UART_ED_PARITYE            0x40                            // current received dataword contained in D and C3 was received with a parity error
      #define UART_ED_NOISY              0x80                            // current received dataword contained in D and C3 was received with noise
    #define UART0_MODEM                  *(unsigned char *)(UART0_BLOCK + 0x0d)          // UART 0 Modem Register
      #define UART_MODEM_TXCTSE          0x01                            // transmit clear-to-send enable
      #define UART_MODEM_TXRTSE          0x02                            // transmit request-to-send enable
      #define UART_MODEM_TXRTSPOL        0x04                            // transmit request-to-send polarity
      #define UART_MODEM_RXRTSE          0x08                            // receiver request-to-send enable
    #define UART0_IR                     *(unsigned char *)(UART0_BLOCK + 0x0e)          // UART 0 Infrared Register
      #define UART_IR_TNP_3_16           0x00                            // 3/16 narrow pulse
      #define UART_IR_TNP_1_16           0x01                            // 1/16 narrow pulse
      #define UART_IR_TNP_1_32           0x02                            // 1/32 narrow pulse
      #define UART_IR_TNP_1_4            0x03                            // 1/4 narrow pulse
      #define UART_IR_IREN               0x04                            // infrared enable
    #define UART0_PFIFO                  *(unsigned char *)(UART0_BLOCK + 0x10)           // UART 0 FIFO Parameters
      #define UART_PFIFO_RXFIFOSIZE_1    0x00                            // receive FIFO/buffer depth = 1 dataword
      #define UART_PFIFO_RXFIFOSIZE_4    0x01                            // receive FIFO/buffer depth = 4 datawords
      #define UART_PFIFO_RXFIFOSIZE_8    0x02                            // receive FIFO/buffer depth = 8 datawords
      #define UART_PFIFO_RXFIFOSIZE_16   0x03                            // receive FIFO/buffer depth = 16 datawords
      #define UART_PFIFO_RXFIFOSIZE_32   0x04                            // receive FIFO/buffer depth = 32 datawords
      #define UART_PFIFO_RXFIFOSIZE_64   0x05                            // receive FIFO/buffer depth = 64 datawords
      #define UART_PFIFO_RXFIFOSIZE_128  0x06                            // receive FIFO/buffer depth = 128 datawords
      #define UART_PFIFO_RXFE            0x08                            // receive FIFO enable
      #define UART_PFIFO_TXFIFOSIZE_1    0x00                            // transmit FIFO/buffer depth = 1 dataword
      #define UART_PFIFO_TXFIFOSIZE_4    0x10                            // transmit FIFO/buffer depth = 4 datawords
      #define UART_PFIFO_TXFIFOSIZE_8    0x20                            // transmit FIFO/buffer depth = 8 datawords
      #define UART_PFIFO_TXFIFOSIZE_16   0x30                            // transmit FIFO/buffer depth = 16 datawords
      #define UART_PFIFO_TXFIFOSIZE_32   0x40                            // transmit FIFO/buffer depth = 32 datawords
      #define UART_PFIFO_TXFIFOSIZE_64   0x50                            // transmit FIFO/buffer depth = 64 datawords
      #define UART_PFIFO_TXFIFOSIZE_128  0x60                            // transmit FIFO/buffer depth = 128 datawords
      #define UART_PFIFO_TXFE            0x80                            // transmit FIFO enable
    #define UART0_CFIFO                  *(volatile unsigned char *)(UART0_BLOCK + 0x11)  // UART 0 FIFO Control Register
      #define UART_CFIFO_RXUFE           0x01                            // receive FIFO underrun interrupt enable
      #define UART_CFIFO_TXOFE           0x02                            // transmit FIFO overflow interrupt enable
      #define UART_CFIFO_RXFLUSH         0x40                            // receive FIFO/buffer flush (write-one only)
      #define UART_CFIFO_TXFLUSH         0x80                            // transmit FIFO/buffer flush (write-one only)
    #define UART0_SFIFO                  *(volatile unsigned char *)(UART0_BLOCK + 0x12) // UART 0 FIFO Status Register
      #define UART_SFIFO_RXUF            0x01                            // receive buffer underrun flag
      #define UART_SFIFO_TXOF            0x02                            // transmit buffer overflow flag
      #define UART_SFIFO_RXEMPT          0x40                            // receive FIFO/buffer empty
      #define UART_SFIFO_TXEMPT          0x80                            // transmit FIFO/buffer empty
    #define UART0_TWFIFO                 *(unsigned char *)(UART0_BLOCK + 0x13)           // UART 0 FIFO Transmit Watermark
    #define UART0_TCFIFI                 *(volatile unsigned char *)(UART0_BLOCK + 0x14)  // UART 0 FIFO Transmit Count (read-only)
    #define UART0_RWFIFO                 *(unsigned char *)(UART0_BLOCK + 0x15)           // UART 0 FIFO Receive Watermark
    #define UART0_RCFIFI                 *(volatile unsigned char *)(UART0_BLOCK + 0x16)  // UART 0 FIFO Receive Count (read-only)
    #define UART0_C7816                  *(unsigned char *)(UART0_BLOCK + 0x18)           // UART 0 7816 Control Register
    #define UART0_IE7816                 *(unsigned char *)(UART0_BLOCK + 0x19)           // UART 0 7816 Interrupt Enable Register
    #define UART0_IS7816                 *(volatile unsigned char *)(UART0_BLOCK + 0x1a)  // UART 0 7816 Interrupt Status Register
    #define UART0_WP7816T0               *(unsigned char *)(UART0_BLOCK + 0x1b)           // UART 0 7816 Wait Parameter Register T0/T1
    #define UART0_WP7816T1               *(unsigned char *)(UART0_BLOCK + 0x1b)           // UART 0 7816 Wait Parameter Register T0/T1
    #define UART0_WN7816                 *(unsigned char *)(UART0_BLOCK + 0x1c)           // UART 0 7816 Wait N Register
    #define UART0_WF7816                 *(unsigned char *)(UART0_BLOCK + 0x1d)           // UART 0 7816 Wait FD Register
    #define UART0_ET7816                 *(unsigned char *)(UART0_BLOCK + 0x1e)           // UART 0 7816 Error Threshold Register
    #define UART0_TL7816                 *(unsigned char *)(UART0_BLOCK + 0x1f)           // UART 0 7816 Transmit Length Register
#endif

#define UART1_BDH                        *(volatile unsigned char *)(UART1_BLOCK + 0x00)  // UART 1 Baud Rate Registers: High
#if defined KINETIS_KL
  #define UART_BDH_SBNS                  0x20                            // stop bit number select (set for 2 stop bits)
#endif
#define UART1_BDL                        *(volatile unsigned char *)(UART1_BLOCK + 0x01)  // UART 1 Baud Rate Registers: Low
#define UART1_C1                         *(unsigned char*)(UART1_BLOCK + 0x02)            // UART 1 Control Register 1
#define UART1_C2                         *(unsigned char*)(UART1_BLOCK + 0x03)            // UART 1 Control Register 2
#define UART1_S1                         *(volatile unsigned char*)(UART1_BLOCK + 0x04)   // UART 1 Status Register 1 (read-only)
#define UART1_S2                         *(volatile unsigned char*)(UART1_BLOCK + 0x05)   // UART 1 Status Register 2
#define UART1_C3                         *(unsigned char*)(UART1_BLOCK + 0x06)            // UART 1 Control Register 3
#define UART1_D                          *(volatile unsigned char*)(UART1_BLOCK + 0x07)   // UART 1 Data Register
#if defined KINETIS_KL
    #define UART1_C4                     *(unsigned char*)(UART1_BLOCK + 0x08)            // UART 1 Control Register 4
      #define UART_C4_RDMAS              0x20                                             // receiver full DMA select
      #define UART_C4_TDMAS              0x80                                             // transmitter DMA select
#elif !defined KINETIS_KE
    #define UART1_MA1                    *(unsigned char*)(UART1_BLOCK + 0x08)            // UART 1 Match Address Registers 1
    #define UART1_MA2                    *(unsigned char*)(UART1_BLOCK + 0x09)            // UART 1 Match Address Registers 2
    #define UART1_C4                     *(unsigned char*)(UART1_BLOCK + 0x0a)            // UART 1 Control Register 4
    #define UART1_C5                     *(unsigned char*)(UART1_BLOCK + 0x0b)            // UART 1 Control Register 5
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    #define UART1_ED                     *(volatile unsigned char*)(UART1_BLOCK + 0x0c)   // UART 1 Extended Data Register (read-only)
    #define UART1_MODEM                  *(unsigned char*)(UART1_BLOCK + 0x0d)            // UART 1 Modem Register
    #define UART1_IR                     *(unsigned char*)(UART1_BLOCK + 0x0e)            // UART 1 Infrared Register
    #define UART1_PFIFO                  *(unsigned char*)(UART1_BLOCK + 0x10)            // UART 1 FIFO Parameters
    #define UART1_CFIFO                  *(unsigned char*)(UART1_BLOCK + 0x11)            // UART 1 FIFO Control Register
    #define UART1_SFIFO                  *(volatile unsigned char*)(UART1_BLOCK + 0x12)   // UART 1 FIFO Status Register
    #define UART1_TWFIFO                 *(unsigned char*)(UART1_BLOCK + 0x13)            // UART 1 FIFO Transmit Watermark
    #define UART1_TCFIFI                 *(volatile unsigned char*)(UART1_BLOCK + 0x14)   // UART 1 FIFO Transmit Count (read-only)
    #define UART1_RWFIFO                 *(unsigned char*)(UART1_BLOCK + 0x15)            // UART 1 FIFO Receive Watermark
    #define UART1_RCFIFI                 *(volatile unsigned char*)(UART1_BLOCK + 0x16)   // UART 1 FIFO Receive Count (read-only)
    #define UART1_C7816                  *(unsigned char*)(UART1_BLOCK + 0x18)            // UART 1 7816 Control Register
    #define UART1_IE7816                 *(unsigned char*)(UART1_BLOCK + 0x19)            // UART 1 7816 Interrupt Enable Register
    #define UART1_IS7816                 *(volatile unsigned char*)(UART1_BLOCK + 0x1a)   // UART 1 7816 Interrupt Status Register
    #define UART1_WP7816T0               *(unsigned char*)(UART1_BLOCK + 0x1b)            // UART 1 7816 Wait Parameter Register T0/T1
    #define UART1_WP7816T1               *(unsigned char*)(UART1_BLOCK + 0x1b)            // UART 1 7816 Wait Parameter Register T0/T1
    #define UART1_WN7816                 *(unsigned char*)(UART1_BLOCK + 0x1c)            // UART 1 7816 Wait N Register
    #define UART1_WF7816                 *(unsigned char*)(UART1_BLOCK + 0x1d)            // UART 1 7816 Wait FD Register
    #define UART1_ET7816                 *(unsigned char*)(UART1_BLOCK + 0x1e)            // UART 1 7816 Error Threshold Register
    #define UART1_TL7816                 *(unsigned char*)(UART1_BLOCK + 0x1f)            // UART 1 7816 Transmit Length Register
#endif

#define UART2_BDH                        *(volatile unsigned char *)(UART2_BLOCK + 0x00)  // UART 2 Baud Rate Registers: High
#define UART2_BDL                        *(volatile unsigned char *)(UART2_BLOCK + 0x01)  // UART 2 Baud Rate Registers: Low
#define UART2_C1                         *(unsigned char*)(UART2_BLOCK + 0x02)            // UART 2 Control Register 1
#define UART2_C2                         *(unsigned char*)(UART2_BLOCK + 0x03)            // UART 2 Control Register 2
#define UART2_S1                         *(volatile unsigned char*)(UART2_BLOCK + 0x04)   // UART 2 Status Register 1 (read-only)
#define UART2_S2                         *(volatile unsigned char*)(UART2_BLOCK + 0x05)   // UART 2 Status Register 2
#define UART2_C3                         *(unsigned char*)(UART2_BLOCK + 0x06)            // UART 2 Control Register 3
#define UART2_D                          *(volatile unsigned char*)(UART2_BLOCK + 0x07)   // UART 2 Data Register
#if defined KINETIS_KL && !defined KINETIS_KL43 && !defined KINETIS_KL27
    #define UART2_C4                     *(unsigned char*)(UART2_BLOCK + 0x08)            // UART 2 Control Register 4
#elif !defined KINETIS_KE
    #define UART2_MA1                    *(unsigned char*)(UART2_BLOCK + 0x08)            // UART 2 Match Address Registers 1
    #define UART2_MA2                    *(unsigned char*)(UART2_BLOCK + 0x09)            // UART 2 Match Address Registers 2
    #define UART2_C4                     *(unsigned char*)(UART2_BLOCK + 0x0a)            // UART 2 Control Register 4
    #define UART2_C5                     *(unsigned char*)(UART2_BLOCK + 0x0b)            // UART 2 Control Register 5
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    #define UART2_ED                     *(volatile unsigned char*)(UART2_BLOCK + 0x0c)   // UART 2 Extended Data Register (read-only)
    #define UART2_MODEM                  *(unsigned char*)(UART2_BLOCK + 0x0d)            // UART 2 Modem Register
    #define UART2_IR                     *(unsigned char*)(UART2_BLOCK + 0x0e)            // UART 2 Infrared Register
    #define UART2_PFIFO                  *(unsigned char*)(UART2_BLOCK + 0x10)            // UART 2 FIFO Parameters
    #define UART2_CFIFO                  *(unsigned char*)(UART2_BLOCK + 0x11)            // UART 2 FIFO Control Register
    #define UART2_SFIFO                  *(volatile unsigned char*)(UART2_BLOCK + 0x12)   // UART 2 FIFO Status Register
    #define UART2_TWFIFO                 *(unsigned char*)(UART2_BLOCK + 0x13)            // UART 2 FIFO Transmit Watermark
    #define UART2_TCFIFI                 *(volatile unsigned char*)(UART2_BLOCK + 0x14)   // UART 2 FIFO Transmit Count (read-only)
    #define UART2_RWFIFO                 *(unsigned char*)(UART2_BLOCK + 0x15)            // UART 2 FIFO Receive Watermark
    #define UART2_RCFIFI                 *(volatile unsigned char*)(UART2_BLOCK + 0x16)   // UART 2 FIFO Receive Count (read-only)
#endif
#if (!defined KINETIS_KL && !defined KINETIS_KE) || defined KINETIS_KL43 || defined KINETIS_KL27
    #define UART2_C7816                  *(unsigned char*)(UART2_BLOCK + 0x18)            // UART 2 7816 Control Register
    #define UART2_IE7816                 *(unsigned char*)(UART2_BLOCK + 0x19)            // UART 2 7816 Interrupt Enable Register
    #define UART2_IS7816                 *(volatile unsigned char*)(UART2_BLOCK + 0x1a)   // UART 2 7816 Interrupt Status Register
    #define UART2_WP7816T0               *(unsigned char*)(UART2_BLOCK + 0x1b)            // UART 2 7816 Wait Parameter Register T0/T1
    #define UART2_WP7816T1               *(unsigned char*)(UART2_BLOCK + 0x1b)            // UART 2 7816 Wait Parameter Register T0/T1
    #define UART2_WN7816                 *(unsigned char*)(UART2_BLOCK + 0x1c)            // UART 2 7816 Wait N Register
    #define UART2_WF7816                 *(unsigned char*)(UART2_BLOCK + 0x1d)            // UART 2 7816 Wait FD Register
    #define UART2_ET7816                 *(unsigned char*)(UART2_BLOCK + 0x1e)            // UART 2 7816 Error Threshold Register
    #define UART2_TL7816                 *(unsigned char*)(UART2_BLOCK + 0x1f)            // UART 2 7816 Transmit Length Register
#endif

#define UART3_BDH                        *(volatile unsigned char *)(UART3_BLOCK + 0x00)  // UART 3 Baud Rate Registers: High
#define UART3_BDL                        *(volatile unsigned char *)(UART3_BLOCK + 0x01)  // UART 3 Baud Rate Registers: Low
#define UART3_C1                         *(unsigned char*)(UART3_BLOCK + 0x02)            // UART 3 Control Register 1
#define UART3_C2                         *(unsigned char*)(UART3_BLOCK + 0x03)            // UART 3 Control Register 2
#define UART3_S1                         *(volatile unsigned char*)(UART3_BLOCK + 0x04)   // UART 3 Status Register 1 (read-only)
#define UART3_S2                         *(volatile unsigned char*)(UART3_BLOCK + 0x05)   // UART 3 Status Register 2
#define UART3_C3                         *(unsigned char*)(UART3_BLOCK + 0x06)            // UART 3 Control Register 3
#define UART3_D                          *(volatile unsigned char*)(UART3_BLOCK + 0x07)   // UART 3 Data Register
#if defined KINETIS_KL
    #define UART3_C4                     *(unsigned char*)(UART3_BLOCK + 0x08)            // UART 3 Control Register 4
#elif !defined KINETIS_KE
    #define UART3_MA1                    *(unsigned char*)(UART3_BLOCK + 0x08)            // UART 3 Match Address Registers 1
    #define UART3_MA2                    *(unsigned char*)(UART3_BLOCK + 0x09)            // UART 3 Match Address Registers 2
    #define UART3_C4                     *(unsigned char*)(UART3_BLOCK + 0x0a)            // UART 3 Control Register 4
    #define UART3_C5                     *(unsigned char*)(UART3_BLOCK + 0x0b)            // UART 3 Control Register 5
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    #define UART3_ED                     *(volatile unsigned char*)(UART3_BLOCK + 0x0c)   // UART 3 Extended Data Register (read-only)
    #define UART3_MODEM                  *(unsigned char*)(UART3_BLOCK + 0x0d)            // UART 3 Modem Register
    #define UART3_IR                     *(unsigned char*)(UART3_BLOCK + 0x0e)            // UART 3 Infrared Register
    #define UART3_PFIFO                  *(unsigned char*)(UART3_BLOCK + 0x10)            // UART 3 FIFO Parameters
    #define UART3_CFIFO                  *(unsigned char*)(UART3_BLOCK + 0x11)            // UART 3 FIFO Control Register
    #define UART3_SFIFO                  *(volatile unsigned char*)(UART3_BLOCK + 0x12)   // UART 3 FIFO Status Register
    #define UART3_TWFIFO                 *(unsigned char*)(UART3_BLOCK + 0x13)            // UART 3 FIFO Transmit Watermark
    #define UART3_TCFIFI                 *(volatile unsigned char*)(UART3_BLOCK + 0x14)   // UART 3 FIFO Transmit Count (read-only)
    #define UART3_RWFIFO                 *(unsigned char*)(UART3_BLOCK + 0x15)            // UART 3 FIFO Receive Watermark
    #define UART3_RCFIFI                 *(volatile unsigned char*)(UART3_BLOCK + 0x16)   // UART 3 FIFO Receive Count (read-only)
    #define UART3_C7816                  *(unsigned char*)(UART3_BLOCK + 0x18)            // UART 3 7816 Control Register
    #define UART3_IE7816                 *(unsigned char*)(UART3_BLOCK + 0x19)            // UART 3 7816 Interrupt Enable Register
    #define UART3_IS7816                 *(volatile unsigned char*)(UART3_BLOCK + 0x1a)   // UART 3 7816 Interrupt Status Register
    #define UART3_WP7816T0               *(unsigned char*)(UART3_BLOCK + 0x1b)            // UART 3 7816 Wait Parameter Register T0/T1
    #define UART3_WP7816T1               *(unsigned char*)(UART3_BLOCK + 0x1b)            // UART 3 7816 Wait Parameter Register T0/T1
    #define UART3_WN7816                 *(unsigned char*)(UART3_BLOCK + 0x1c)            // UART 3 7816 Wait N Register
    #define UART3_WF7816                 *(unsigned char*)(UART3_BLOCK + 0x1d)            // UART 3 7816 Wait FD Register
    #define UART3_ET7816                 *(unsigned char*)(UART3_BLOCK + 0x1e)            // UART 3 7816 Error Threshold Register
    #define UART3_TL7816                 *(unsigned char*)(UART3_BLOCK + 0x1f)            // UART 3 7816 Transmit Length Register
#endif

#define UART4_BDH                        *(volatile unsigned char *)(UART4_BLOCK + 0x00)  // UART 4 Baud Rate Registers: High
#define UART4_BDL                        *(volatile unsigned char *)(UART4_BLOCK + 0x01)  // UART 4 Baud Rate Registers: Low
#define UART4_C1                         *(unsigned char*)(UART4_BLOCK + 0x02)            // UART 4 Control Register 1
#define UART4_C2                         *(unsigned char*)(UART4_BLOCK + 0x03)            // UART 4 Control Register 2
#define UART4_S1                         *(volatile unsigned char*)(UART4_BLOCK + 0x04)   // UART 4 Status Register 1 (read-only)
#define UART4_S2                         *(volatile unsigned char*)(UART4_BLOCK + 0x05)   // UART 4 Status Register 2
#define UART4_C3                         *(unsigned char*)(UART4_BLOCK + 0x06)            // UART 4 Control Register 3
#define UART4_D                          *(volatile unsigned char*)(UART4_BLOCK + 0x07)   // UART 4 Data Register
#if defined KINETIS_KL
    #define UART4_C4                     *(unsigned char*)(UART4_BLOCK + 0x08)            // UART 4 Control Register 4
#elif !defined KINETIS_KE
    #define UART4_MA1                    *(unsigned char*)(UART4_BLOCK + 0x08)            // UART 4 Match Address Registers 1
    #define UART4_MA2                    *(unsigned char*)(UART4_BLOCK + 0x09)            // UART 4 Match Address Registers 2
    #define UART4_C4                     *(unsigned char*)(UART4_BLOCK + 0x0a)            // UART 4 Control Register 4
    #define UART4_C5                     *(unsigned char*)(UART4_BLOCK + 0x0b)            // UART 4 Control Register 5
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    #define UART4_ED                     *(volatile unsigned char*)(UART4_BLOCK + 0x0c)   // UART 4 Extended Data Register (read-only)
    #define UART4_MODEM                  *(unsigned char*)(UART4_BLOCK + 0x0d)            // UART 4 Modem Register
    #define UART4_IR                     *(unsigned char*)(UART4_BLOCK + 0x0e)            // UART 4 Infrared Register
    #define UART4_PFIFO                  *(unsigned char*)(UART4_BLOCK + 0x10)            // UART 4 FIFO Parameters
    #define UART4_CFIFO                  *(unsigned char*)(UART4_BLOCK + 0x11)            // UART 4 FIFO Control Register
    #define UART4_SFIFO                  *(volatile unsigned char*)(UART4_BLOCK + 0x12)   // UART 4 FIFO Status Register
    #define UART4_TWFIFO                 *(unsigned char*)(UART4_BLOCK + 0x13)            // UART 4 FIFO Transmit Watermark
    #define UART4_TCFIFI                 *(volatile unsigned char*)(UART4_BLOCK + 0x14)   // UART 4 FIFO Transmit Count (read-only)
    #define UART4_RWFIFO                 *(unsigned char*)(UART4_BLOCK + 0x15)            // UART 4 FIFO Receive Watermark
    #define UART4_RCFIFI                 *(volatile unsigned char*)(UART4_BLOCK + 0x16)   // UART 4 FIFO Receive Count (read-only)
    #define UART4_C7816                  *(unsigned char*)(UART4_BLOCK + 0x18)            // UART 4 7816 Control Register
    #define UART4_IE7816                 *(unsigned char*)(UART4_BLOCK + 0x19)            // UART 4 7816 Interrupt Enable Register
    #define UART4_IS7816                 *(volatile unsigned char*)(UART4_BLOCK + 0x1a)   // UART 4 7816 Interrupt Status Register
    #define UART4_WP7816T0               *(unsigned char*)(UART4_BLOCK + 0x1b)            // UART 4 7816 Wait Parameter Register T0/T1
    #define UART4_WP7816T1               *(unsigned char*)(UART4_BLOCK + 0x1b)            // UART 4 7816 Wait Parameter Register T0/T1
    #define UART4_WN7816                 *(unsigned char*)(UART4_BLOCK + 0x1c)            // UART 4 7816 Wait N Register
    #define UART4_WF7816                 *(unsigned char*)(UART4_BLOCK + 0x1d)            // UART 4 7816 Wait FD Register
    #define UART4_ET7816                 *(unsigned char*)(UART4_BLOCK + 0x1e)            // UART 4 7816 Error Threshold Register
    #define UART4_TL7816                 *(unsigned char*)(UART4_BLOCK + 0x1f)            // UART 4 7816 Transmit Length Register
#endif

#define UART5_BDH                        *(volatile unsigned char *)(UART5_BLOCK + 0x00)  // UART 5 Baud Rate Registers: High
#define UART5_BDL                        *(volatile unsigned char *)(UART5_BLOCK + 0x01)  // UART 5 Baud Rate Registers: Low
#define UART5_C1                         *(unsigned char*)(UART5_BLOCK + 0x02)            // UART 5 Control Register 1
#define UART5_C2                         *(unsigned char*)(UART5_BLOCK + 0x03)            // UART 5 Control Register 2
#define UART5_S1                         *(volatile unsigned char*)(UART5_BLOCK + 0x04)   // UART 5 Status Register 1 (read-only)
#define UART5_S2                         *(volatile unsigned char*)(UART5_BLOCK + 0x05)   // UART 5 Status Register 2
#define UART5_C3                         *(unsigned char*)(UART5_BLOCK + 0x06)            // UART 5 Control Register 3
#define UART5_D                          *(volatile unsigned char*)(UART5_BLOCK + 0x07)   // UART 5 Data Register
#if defined KINETIS_KL
    #define UART5_C4                     *(unsigned char*)(UART5_BLOCK + 0x08)            // UART 5 Control Register 4
#elif !defined KINETIS_KE
    #define UART5_MA1                    *(unsigned char*)(UART5_BLOCK + 0x08)            // UART 5 Match Address Registers 1
    #define UART5_MA2                    *(unsigned char*)(UART5_BLOCK + 0x09)            // UART 5 Match Address Registers 2
    #define UART5_C4                     *(unsigned char*)(UART5_BLOCK + 0x0a)            // UART 5 Control Register 4
    #define UART5_C5                     *(unsigned char*)(UART5_BLOCK + 0x0b)            // UART 5 Control Register 5
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    #define UART5_ED                     *(volatile unsigned char*)(UART5_BLOCK + 0x0c)   // UART 5 Extended Data Register (read-only)
    #define UART5_MODEM                  *(unsigned char*)(UART5_BLOCK + 0x0d)            // UART 5 Modem Register
    #define UART5_IR                     *(unsigned char*)(UART5_BLOCK + 0x0e)            // UART 5 Infrared Register
    #define UART5_PFIFO                  *(unsigned char*)(UART5_BLOCK + 0x10)            // UART 5 FIFO Parameters
    #define UART5_CFIFO                  *(unsigned char*)(UART5_BLOCK + 0x11)            // UART 5 FIFO Control Register
    #define UART5_SFIFO                  *(volatile unsigned char*)(UART5_BLOCK + 0x12)   // UART 5 FIFO Status Register
    #define UART5_TWFIFO                 *(unsigned char*)(UART5_BLOCK + 0x13)            // UART 5 FIFO Transmit Watermark
    #define UART5_TCFIFI                 *(volatile unsigned char*)(UART5_BLOCK + 0x14)   // UART 5 FIFO Transmit Count (read-only)
    #define UART5_RWFIFO                 *(unsigned char*)(UART5_BLOCK + 0x15)            // UART 5 FIFO Receive Watermark
    #define UART5_RCFIFI                 *(volatile unsigned char*)(UART5_BLOCK + 0x16)   // UART 5 FIFO Receive Count (read-only)
    #define UART5_C7816                  *(unsigned char*)(UART5_BLOCK + 0x18)            // UART 5 7816 Control Register
    #define UART5_IE7816                 *(unsigned char*)(UART5_BLOCK + 0x19)            // UART 5 7816 Interrupt Enable Register
    #define UART5_IS7816                 *(volatile unsigned char*)(UART5_BLOCK + 0x1a)   // UART 5 7816 Interrupt Status Register
    #define UART5_WP7816T0               *(unsigned char*)(UART5_BLOCK + 0x1b)            // UART 5 7816 Wait Parameter Register T0/T1
    #define UART5_WP7816T1               *(unsigned char*)(UART5_BLOCK + 0x1b)            // UART 5 7816 Wait Parameter Register T0/T1
    #define UART5_WN7816                 *(unsigned char*)(UART5_BLOCK + 0x1c)            // UART 5 7816 Wait N Register
    #define UART5_WF7816                 *(unsigned char*)(UART5_BLOCK + 0x1d)            // UART 5 7816 Wait FD Register
    #define UART5_ET7816                 *(unsigned char*)(UART5_BLOCK + 0x1e)            // UART 5 7816 Error Threshold Register
    #define UART5_TL7816                 *(unsigned char*)(UART5_BLOCK + 0x1f)            // UART 5 7816 Transmit Length Register
#endif

typedef struct stKINETIS_UART_CONTROL
{
    volatile unsigned char UART_BDH;                                     // this byte is always written first
    volatile unsigned char UART_BDL;                                     // followed by this one
    unsigned char UART_C1;
    unsigned char UART_C2;
    volatile unsigned char UART_S1;
    volatile unsigned char UART_S2;
    volatile unsigned char UART_C3;
    volatile unsigned char UART_D;
#if defined KINETIS_KL
    unsigned char UART_MA1_C4;                                           // UART0 has full set but UARTs 1, 2 etc. have UART_C4 at this location and no futher registers
    unsigned char UART_MA2;
    unsigned char UART_C4;
    unsigned char UART_C5;
#elif !defined KINETIS_KE
    unsigned char UART_MA1;
    unsigned char UART_MA2;
    unsigned char UART_C4;
    unsigned char UART_C5;
    volatile unsigned char UART_ED;
#endif
#if !defined KINETIS_KL && !defined KINETIS_KE
    unsigned char UART_MODEM;
    unsigned char UART_IR;
    unsigned char ucRes0;
    unsigned char UART_PFIFO;
    volatile unsigned char UART_CFIFO;
    volatile unsigned char UART_SFIFO;
    unsigned char UART_TWFIFO;
    volatile unsigned char UART_TCFIFI;
    unsigned char UART_RWFIFO;
    volatile unsigned char UART_RCFIFI;
    unsigned char ucRes1;
    unsigned char UART_C7816;
    unsigned char UART_IE7816;
    volatile unsigned char UART_IS7816;
    unsigned char UART_WP7816T0;
    unsigned char UART_WP7816T1;
    unsigned char UART_WN7816;
    unsigned char UART_WF7816;
    unsigned char UART_ET7816;
    unsigned char UART_TL7816;
#endif
} KINETIS_UART_CONTROL;



// USB Controller
//
#define PER_ID               *(unsigned char *)(USB_BASE_ADD + 0x000)    // Peripheral ID Register (read-only)
#define ID_COMP              *(unsigned char *)(USB_BASE_ADD + 0x004)    // Peripheral ID Compliment Register (read-only)
#define REV                  *(unsigned char *)(USB_BASE_ADD + 0x008)    // Peripheral Revision Register (read-only)
#define ADD_INFO             *(unsigned char *)(USB_BASE_ADD + 0x00c)    // Peripheral Additional Info Register (read-only)
  #define IEHOST             0x01
#define OTG_INT_STAT         *(volatile unsigned char *)(USB_BASE_ADD + 0x010) // OTG Interrupt Status Register
  #define A_VBUS_CHG         0x01
  #define BSESS_CHG          0x04
  #define SESS_VLD_CHG       0x08
  #define LINE_STAT_CHG      0x20
  #define MSEC_1             0x40
  #define ID_CHG             0x80
#define OTG_INT_EN           *(unsigned char *)(USB_BASE_ADD + 0x014)    // OTG Interrupt Control Register
#define OTG_STATUS           *(volatile unsigned char *)(USB_BASE_ADD + 0x018) // OTG Status Register
#define OTG_CTRL             *(unsigned char *)(USB_BASE_ADD + 0x01c)    // OTG Control Register
  #define OTG_EN             0x04                                        // Pull up / down resistors enabled in the module
  #define DP_LOW_DM_LOW      0x30                                        // D+ and D- pull down resistors enabled
//#define DM_HIGH            0x40                                        // D- pull up resistor enabled
  #define DP_HIGH            0x80                                        // D+ pull up resistor enabled
#define INT_STAT             *(volatile unsigned char *)(USB_BASE_ADD + 0x080) // Interrupt Status Register
  #define USB_RST            0x01
  #define USB_ERROR          0x02
  #define SOF_TOK            0x04
  #define TOK_DNE            0x08
  #define SLEEP              0x10
  #define RESUME             0x20
  #define ATTACH             0x40
  #define STALL              0x80
#define INT_ENB              *(volatile unsigned char *)(USB_BASE_ADD + 0x084) // Interrupt Enable Register
  #define USB_RST_EN         0x01
  #define USB_ERROR_EN       0x02
  #define SOF_TOK_EN         0x04
  #define TOK_DNE_EN         0x08
  #define SLEEP_EN           0x10
  #define RESUME_EN          0x20
  #define ATTACH_EN          0x40
  #define STALL_EN           0x80
#define ERR_STAT             *(volatile unsigned char *)(USB_BASE_ADD + 0x088) // Error Interrupt Status Register
  #define PID_ERR            0x01                                        // PIUD check field failed
  #define CRC5_EOF           0x02                                        // data packet rejected due to CRC5 error (device) or end of frame error (host)
  #define CRC16              0x04                                        // data packet rejected due to CRC16 error
  #define DFN8               0x08                                        // data field received was not 8 bits in length (integer number of bytes)
  #define BTO_ERR            0x10                                        // bus turnaround timeout error
  #define USB_DMA_ERR        0x20                                        // USB module requested DAM access to read a new BDT but was not given the bus before it was needed to receie or transmit data
  #define BTS_ERR            0x80                                        // bit stuffing error detected - packet is rejected
#define ERR_ENB              *(unsigned char *)(USB_BASE_ADD + 0x08c)    // Error Interrupt Enable Register
  #define PID_ERR_EN         0x01
  #define CRC5_EOF_EN        0x02
  #define CRC16_EN           0x04
  #define DFN8_EN            0x08
  #define BTO_ERR_EN         0x10
  #define DMA_ERR_EN         0x20
  #define BTS_ERR_EN         0x80
#define STAT                 *(volatile unsigned char *)(USB_BASE_ADD + 0x090) // Status Register
  #define ODD_BANK           0x04
  #define TX_TRANSACTION     0x08
  #define END_POINT_SHIFT    4
#define CTL                  *(volatile unsigned char *)(USB_BASE_ADD + 0x094) // Control Register
  #define USB_EN_SOF_EN      0x01                                        // Enable USB module
  #define ODD_RST            0x02                                        // Reset all Odd BDTs
  #define CTL_RESUME         0x04                                        // Excecute resume signalling
  #define HOST_MODE_EN       0x08                                        // Host mode of operation
  #define USB_RESET          0x10                                        // Enable USB Reset signalling
  #define TXSUSPEND_TOKENBUSY 0x20                                       // 
  #define SE0                0x40                                        // Live USB Single ended Zero signal
  #define JSTATE             0x80                                        // Live USB differential receiver JSTATE signal
#define ADDR                 *(unsigned char *)(USB_BASE_ADD + 0x098)    // Address Register
  #define LS_EN              0x80                                        // Low Speed Enable Bit
#define BDT_PAGE_01          *(unsigned char *)(USB_BASE_ADD + 0x09c)    // BDT Page Register 1
#define FRM_NUML             *(unsigned char *)(USB_BASE_ADD + 0x0a0)    // Frame Number Register Low
#define FRM_NUMH             *(unsigned char *)(USB_BASE_ADD + 0x0a4)    // Frame Number Register High
#define TOKEN                *(volatile unsigned char *)(USB_BASE_ADD + 0x0a8) // Token Register
#define SOF_THLD             *(unsigned char *)(USB_BASE_ADD + 0x0ac)    // SOF Threshold Register
#define BDT_PAGE_02          *(unsigned char *)(USB_BASE_ADD + 0x0b0)    // BDT Page Register 2
#define BDT_PAGE_03          *(unsigned char *)(USB_BASE_ADD + 0x0b4)    // BDT Page Register 3
#define ENDPT0_ADD           (unsigned char *)(USB_BASE_ADD + 0x0c0)     // Endpoint Control Register 0 address
#define ENDPT0               *(volatile unsigned char *)(USB_BASE_ADD + 0x0c0) // Endpoint Control Register 0
  #define EP_HSHK            0x01                                        // Enable Endpoint handshake during transaction
  #define EP_STALL           0x02                                        // Endpoint stalled
  #define EP_TX_ENABLE       0x04                                        // Enable tx transfers in endpoint
  #define EP_RX_ENABLE       0x08                                        // Enable rx transfers in endpoint
  #define EP_CTL_DIS         0x10                                        // Disable control transfers
  #define RETRY_DIS          0x40                                        // Disable retries (only host mode in endpoint 0)
  #define HOST_WO_HUB        0x80                                        // (only host mode in endpoint 0)
#define ENDPT1               *(volatile unsigned char *)(USB_BASE_ADD + 0x0c4) // Endpoint Control Register 1
#define ENDPT2               *(volatile unsigned char *)(USB_BASE_ADD + 0x0c8) // Endpoint Control Register 2
#define ENDPT3               *(volatile unsigned char *)(USB_BASE_ADD + 0x0cc) // Endpoint Control Register 3
#define ENDPT4               *(volatile unsigned char *)(USB_BASE_ADD + 0x0d0) // Endpoint Control Register 4
#define ENDPT5               *(volatile unsigned char *)(USB_BASE_ADD + 0x0d4) // Endpoint Control Register 5
#define ENDPT6               *(volatile unsigned char *)(USB_BASE_ADD + 0x0d8) // Endpoint Control Register 6
#define ENDPT7               *(volatile unsigned char *)(USB_BASE_ADD + 0x0dc) // Endpoint Control Register 7
#define ENDPT8               *(volatile unsigned char *)(USB_BASE_ADD + 0x0e0) // Endpoint Control Register 8
#define ENDPT9               *(volatile unsigned char *)(USB_BASE_ADD + 0x0e4) // Endpoint Control Register 9
#define ENDPT10              *(volatile unsigned char *)(USB_BASE_ADD + 0x0e8) // Endpoint Control Register 10
#define ENDPT11              *(volatile unsigned char *)(USB_BASE_ADD + 0x0ec) // Endpoint Control Register 11
#define ENDPT12              *(volatile unsigned char *)(USB_BASE_ADD + 0x0f0) // Endpoint Control Register 12
#define ENDPT13              *(volatile unsigned char *)(USB_BASE_ADD + 0x0f4) // Endpoint Control Register 13
#define ENDPT14              *(volatile unsigned char *)(USB_BASE_ADD + 0x0f8) // Endpoint Control Register 14
#define ENDPT15              *(volatile unsigned char *)(USB_BASE_ADD + 0x0fc) // Endpoint Control Register 15
#define USB_CTRL             *(volatile unsigned char *)(USB_BASE_ADD + 0x100) // USB Control Register
  #if defined KINETIS_KL82
    #define USB_CTRL_UARTSET   0x10                                      // USB DP/DM signals used as UART signals
    #define USB_CTRL_UARTCHLS  0x20                                      // USB DP/DM signals used as UART RX/TX (rather than TX/RX)
  #endif
  #define PDE                  0x40                                      // enable weak pull down resistors
  #define SUSP                 0x80                                      // place the USB transceiver into the suspend state
#define USB_OTG_OBSERVE      *(unsigned char *)(USB_BASE_ADD + 0x104)    // USB OTG Observe Register
#define USB_OTG_CONTROL      *(unsigned char *)(USB_BASE_ADD + 0x108)    // USB OTG Control Register
  #define USB_OTG_CONTROL_DPPULLUPNONOTG 0x10
#define USB_USBTRC0          *(volatile unsigned char *)(USB_BASE_ADD + 0x10c) // USB OTG Tranceiver Control Register
  #define USB_USBTRC0_USBRESET 0x80
  #define USB_USBTRC0_RES    0x40                                        // this is a reserved bit but is required that it is written with '1'
#if defined KINETIS_HAS_IRC48M                                           // {58}
    #define USB_USBFRMADJUST           *(volatile unsigned char *)(USB_BASE_ADD + 0x114) // Frame Adjust Register for host mode
    #define USB_CLK_RECOVER_CTRL       *(volatile unsigned char *)(USB_BASE_ADD + 0x140) // USB Clock Recovery Control
      #define USB_CLK_RECOVER_CTRL_RESTART          0x20                // restart for IFR trim value
      #define USB_CLK_RECOVER_CTRL_RESET            0x40                // reset/resume to rough phase enable
      #define USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN 0x80                // enable clock recovery block - never set for host or OTG modes
    #define USB_CLK_RECOVER_IRC_EN     *(volatile unsigned char *)(USB_BASE_ADD + 0x144) // IRC48M Oscillator Enable Register
      #define USB_CLK_RECOVER_IRC_EN_REG_EN 0x01                        // IRC48M regulator enable
      #define USB_CLK_RECOVER_IRC_EN_IRC_EN 0x02                        // IRC48M module enable
    #define USB_CLK_RECOVER_INT_STATUS *(volatile unsigned char *)(USB_BASE_ADD + 0x15c) // Clock Recovery Separeted Interrupt Status (write '1' to clear)
      #define USB_CLK_RECOVER_INT_STATUS_OVF_ERROR 0x10
#endif

#define NUMBER_OF_USB_ENDPOINTS 16                                       // Kinetis support 16 end points

//#define _SUPRESS_REPEAT_DATA                                           // repeated data not supressed due to problems when flashing memory at the same time

typedef struct stKINETIS_USB_BD
{
    unsigned long  ulUSB_BDControl;                                      // this is saved in little-endian format
    unsigned char *ptrUSB_BD_Data;                                       // this is saved in little-endian format
} KINETIS_USB_BD;

#define TOK_PID_0             0x00000004                                 // big-endian long word defines
#define BDT_STALL             0x00000004                                 // issue STALL handshake
#define TOK_PID_1             0x00000008
#define DTS                   0x00000008                                 // Data Toggle Synchronisation
#define TOK_PID_2             0x00000010
#define NINC                  0x00000010                                 // No INCrement bit - DMA engine doesn't increment address after each byte transfer
#define TOK_PID_3             0x00000020
#define KEEP_OWNERSHIP        0x00000020                                 // KEEP ownership at USB-FS
#define DATA_1                0x00000040
#define OWN                   0x00000080                                 // USB-FS has exclusive ownership of the buffer descriptor
#define USB_BYTE_CNT_MASK     0x03ff0000    
#define USB_CNT_SHIFT         16
#define RX_PID_MASK           (TOK_PID_3 | TOK_PID_2 | TOK_PID_1 | TOK_PID_0)
#define RX_PID_SHIFT          2
#define USB_USER_FLAG_1       0x10000000                                 // these are not used by the USB controller and may be allocated for driver use
#define USB_USER_FLAG_2       0x20000000
#define USB_USER_FLAG_3       0x30000000
#define USB_USER_FLAG_4       0x80000000

#define CONTROL_DATA_TOGGLE_REVERSED   USB_USER_FLAG_1                   // {71} used to signal that a control endpoint is presently receivng DATA1 OUT frames in the even receiver buffer


// BDT construction
// 4 BDs per endpoint
// Rx - even
// Rx - odd
// Tx - even
// Tx - odd
#define USB_BD_SIZE          sizeof(KINETIS_USB_BD)                      // size in bytes of a single USB buffer descriptor
#define ENDPOINT_BD_SIZE     (4 * USB_BD_SIZE)
#define OFFSET_RX_EVEN       0                                           // offset in long word steps
#define OFFSET_RX_ODD        1
#define OFFSET_TX_EVEN       2
#define OFFSET_TX_ODD        3

typedef struct stKINETIS_USB_ENDPOINT_BD
{
    KINETIS_USB_BD usb_bd_rx_even;
    KINETIS_USB_BD usb_bd_rx_odd;
    KINETIS_USB_BD usb_bd_tx_even;
    KINETIS_USB_BD usb_bd_tx_odd;
} KINETIS_USB_ENDPOINT_BD;

typedef struct stUSB_END_POINT
{
    unsigned long ulNextRxData0;
    unsigned long ulNextTxData0;
    unsigned long ulEndpointSize;                                        // contains size of endpoint plus some control flags
} USB_END_POINT;

#define ALTERNATE_TX_BUFFER    DATA_1                                    // any bit not clashing with the length in the buffer descriptor control word (used as SW flag)
#define RX_DATA_TOGGLE         OWN                                       // any bit not clashing with DATA_1 in the buffer descriptor control word (used as SW flag)

#define USB_FIFO_BUFFER_DEPTH  2                                         // Kinetis has two rx and tx buffers per endpoint

#if defined HS_USB_AVAILABLE                                             // {25}

#define NUMBER_OF_USBHS_ENDPOINTS 4                                      // Kinetis support 4 high speed end points

typedef struct stUSB_HS_TRANSFER_OVERLAY
{
    unsigned long ulNextdTD_pointer;                                     // next dTD in the linked list - this is the only field that software may modify when the dTD is active
    volatile unsigned long ul_dtToken;                                   // number of bytes to be transfered (maximum of 16k is recommended due to complications with larger sizes)
    volatile unsigned long ulBufferPointerPage[5];                       // individual pages of a data buffer
    unsigned char *ptrBufferStart;                                       // this location is defined by software and used to keep a pointer to the start of the first page buffer
} USB_HS_TRANSFER_OVERLAY;


// Endpoint queue header is 64 bytes in size (including padding at the end)
//
typedef struct stKINETIS_USBHS_ENDPOINT_QUEUE_HEADER
{
    volatile unsigned long ulCapabilities;                               // should not be written when the endpoint is active
    volatile USB_HS_TRANSFER_OVERLAY *CurrentdTD_pointer;                // this is used and modified by the controller
    USB_HS_TRANSFER_OVERLAY dTD;                                         // the transfer overlay is is copied to the queue header overlay by the controller and software shoudl not write this area again until a transfer expires
    unsigned char ucSetupBuffer[8];                                      // dedicated storage area for fixed length 8 byte setup token content (only used by rx queue head)
    USB_HS_TRANSFER_OVERLAY *my_dTD;                                     // this location is defined by software and used to keep track of the transfer block belonging to the queue header
    unsigned long ulEndpointLength;                                      // this location is defined by software and used to store the endpoint's buffer length
    unsigned long ulBufferLength;                                        // this location is defined by software and used to store the length of the endpoint's buffer
    unsigned long ulRes2[1];
} KINETIS_USBHS_ENDPOINT_QUEUE_HEADER;

#define ENDPOINT_QUEUE_HEADER_CTL_IOS                 0x00008000         // (ulCapabilities) interrupt on setup reception
#define ENDPOINT_QUEUE_HEADER_ZLT                     0x20000000         // (ulCapabilities) disable zero length packet
#define ENDPOINT_QUEUE_HEADER_MAX_PACKET_LEN_MASK     0x07ff0000         // (ulCapabilities) max length mask - maximum value that may be used is 1024
#define ENDPOINT_QUEUE_HEADER_NEXT_ADD_MASK           0xffffffe0         // (ulNextdTD_pointer) next dTD pointer mask
#define ENDPOINT_QUEUE_HEADER_NEXT_INVALID            0x00000001         // (ulNextdTD_pointer) next is invalid - no more entries
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_MASK       0x000000ff         // (ul_dtToken)
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_TR_ERROR   0x00000008         // (ul_dtToken) transaction error - set by device
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_DB_ERROR   0x00000020         // (ul_dtToken) data buffer error - set by device
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_HALTED     0x00000040         // (ul_dtToken) halted - set by device (also active is cleared by device)
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_ACTIVE     0x00000080         // (ul_dtToken) active - set by processor
#define ENDPOINT_QUEUE_HEADER_TOKEN_MULTO             0x00000c00         // (ul_dtToken) multiplier override - only potentially used by isochronous IN endpoints
#define ENDPOINT_QUEUE_HEADER_TOKEN_IOC               0x00008000         // (ul_dtToken) interrupt on complete
#define ENDPOINT_QUEUE_HEADER_TOKEN_TOTAL_BYTES_SHIFT 16                 // (ul_dtToken)
#define ENDPOINT_QUEUE_HEADER_BUFFER_POINTER_MASK     0xfffff000         // (ulBufferPointerPage) pointer to 4k page offset in memory
#define ENDPOINT_QUEUE_HEADER_BUFFER_FRAME_MASK       0x000007ff         // (ulBufferPointerPage) frame buffer number mask when packet finishes
#define ENDPOINT_QUEUE_HEADER_BUFFER_OFFSET_MASK      0x00000fff         // (ulBufferPointerPage) current offset into the 4k buffer where the packet begins
#endif

// This hardware specific structure allows generic USB routines to control specific hardware using macros
//
typedef struct stUSB_HW
{
    unsigned long  ulRxControl;
    volatile unsigned long *ptr_ulUSB_BDControl;                         // pointer to the presently valid tx buffer descriptor control entry
    USB_END_POINT *ptrEndpoint;
    unsigned char **ptrTxDatBuffer;                                      // pointer to the next transmission buffer pointer
    unsigned char **ptrRxDatBuffer;                                      // pointer to the next reception buffer pointer
    unsigned short usLength;                                             // length information
    unsigned char  ucUSBAddress;                                         // our USB address
#if defined HS_USB_AVAILABLE                                             // {25}
    unsigned char  ucDeviceType;                                         // used to distinguish between LS, FS and HS device operation
    KINETIS_USBHS_ENDPOINT_QUEUE_HEADER *ptrQueueHeader;
#endif
#if defined USB_HOST_SUPPORT
    unsigned long *ptr_ulUSB_Rx_BDControl;                               // pointer to the presently valid rx buffer descriptor control entry
    unsigned long *ptr_ulUSB_Alt_Rx_BDControl;                           // pointer to the alternative rx buffer descriptor control entry
    unsigned char **ptrUSB_BD_EvenData;                                  // pointer to the even buffer pointer
    unsigned char  ucModeType;                                           // used to distinguish between device and host mode
    unsigned char  ucDeviceSpeed;                                        // the speed of the device attached to the host
    unsigned char  ucBufferUsage;                                        // used by host to follow receive buffer usage
    unsigned char  ucHostEndpointActive;                                 // used by host to follow the device endpoint being used
#endif
} USB_HW;


#if defined USB_HS_INTERFACE && defined HS_USB_AVAILABLE                 // {25}
    #define USB_AUTO_TX                                                  // enable multiple frame transmission controlled by the high speed controller
    #define USB_DEVICE_FS    0
    #define USB_DEVICE_HS    1

    // MACRO for setting frame length to buffer descriptor
    //
    #define SET_FRAME_LENGTH(x)     ((x << USB_CNT_SHIFT) & USB_BYTE_CNT_MASK)

    // MACRO for transmitting USB data from generic USB routines
    //
    #define FNSEND_USB_DATA(pData, Len, iEndpoint, ptrUSB_HW) \
    if (ptrUSB_HW->ucDeviceType == USB_DEVICE_HS) { \
        fnTxUSBHS(pData, Len, iEndpoint, ptrUSB_HW); \
    } \
    else { \
        *ptrUSB_HW->ptrTxDatBuffer = (unsigned char *)pData; \
        *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(SET_FRAME_LENGTH(Len) | (OWN | ptrUSB_HW->ptrEndpoint->ulNextTxData0)); _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER; \
    }

    // MACRO for transmitting zero data packet to control endpoints from generic USB routines
    //
    #define FNSEND_ZERO_DATA(ptrUSB_HW, iEndpoint) \
    if (ptrUSB_HW->ucDeviceType == USB_DEVICE_HS) { \
        fnTxUSBHS(0, 0, iEndpoint, ptrUSB_HW); \
    } \
    else { \
        *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(OWN | DTS | ptrUSB_HW->ptrEndpoint->ulNextTxData0); \
        _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
        ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
        ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER; \
    }

    // MACRO for extracting frame length from a buffer descriptor
    //
    #define GET_FRAME_LENGTH()      (unsigned short)((ptUSB_BD->ulUSB_BDControl & USB_BYTE_CNT_MASK) >> USB_CNT_SHIFT)

#else
    // MACRO for setting frame length to buffer descriptor
    //
    #define SET_FRAME_LENGTH(x)     ((x << USB_CNT_SHIFT) & USB_BYTE_CNT_MASK)

    // MACRO for transmitting USB data from generic USB routines
    //
    #if defined USB_HOST_SUPPORT
        #if defined USB_DEVICE_SUPPORT                                   // host and device
            #define FNSEND_USB_DATA(pData, Len, iEndpoint, ptrUSB_HW) *ptrUSB_HW->ptrTxDatBuffer = (unsigned char *)pData; \
                    *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(SET_FRAME_LENGTH(Len) | (OWN | ptrUSB_HW->ptrEndpoint->ulNextTxData0)); \
                    _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
                    ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
                    if ((CTL & HOST_MODE_EN) != 0) {ptrUSB_HW->ucBufferUsage ^= TX_TRANSACTION;} else {ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER;}
        #else                                                            // host only
            #define FNSEND_USB_DATA(pData, Len, iEndpoint, ptrUSB_HW) *ptrUSB_HW->ptrTxDatBuffer = (unsigned char *)pData; \
                    *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(SET_FRAME_LENGTH(Len) | (OWN | ptrUSB_HW->ptrEndpoint->ulNextTxData0)); \
                    _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
                    ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
                    ptrUSB_HW->ucBufferUsage ^= TX_TRANSACTION
        #endif
    #else                                                                // device only
        #define FNSEND_USB_DATA(pData, Len, iEndpoint, ptrUSB_HW) *ptrUSB_HW->ptrTxDatBuffer = (unsigned char *)pData; \
                *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(SET_FRAME_LENGTH(Len) | (OWN | ptrUSB_HW->ptrEndpoint->ulNextTxData0)); \
                _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
                ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
                ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER
    #endif

    // MACRO for transmitting zero data packet to control endpoints from generic USB routines
    //
    #if defined USB_HOST_SUPPORT
        #if defined USB_DEVICE_SUPPORT                                   // host and device
            #define FNSEND_ZERO_DATA(ptrUSB_HW, iEndpoint) *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(OWN | DTS | ptrUSB_HW->ptrEndpoint->ulNextTxData0); \
                    _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
                    ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
                    if ((CTL & HOST_MODE_EN) != 0) {ptrUSB_HW->ucBufferUsage ^= TX_TRANSACTION;} else {ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER;}
        #else
            #define FNSEND_ZERO_DATA(ptrUSB_HW, iEndpoint) *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(OWN | DTS | ptrUSB_HW->ptrEndpoint->ulNextTxData0); \
                    _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
                    ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
                    ptrUSB_HW->ucBufferUsage ^= TX_TRANSACTION;
        #endif
    #else                                                                // device only
        #define FNSEND_ZERO_DATA(ptrUSB_HW, iEndpoint) *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(OWN | DTS | ptrUSB_HW->ptrEndpoint->ulNextTxData0); \
                _SIM_USB(USB_SIM_TX, iEndpoint, ptrUSB_HW); \
                ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
                ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER;
    #endif

    // MACRO for extracting frame length from a buffer descriptor
    //
    #define GET_FRAME_LENGTH()  (unsigned short)((ptUSB_BD->ulUSB_BDControl & USB_BYTE_CNT_MASK) >> USB_CNT_SHIFT)
#endif

#if defined USB_HOST_SUPPORT
    #if defined _WINDOWS
        extern void fnAddToken(unsigned char ucToken);
        extern void fnResetUSB_buffers(void);                            // simulator function
        #define _RESET_USB_BUFFERS() fnResetUSB_buffers()
    #else
        #define _RESET_USB_BUFFERS()
    #endif
    extern void fnHostReleaseBuffer(int iEndpoint, unsigned char ucTransferType, USB_HW *ptrUSB_HW);
    // Reset the buffer use and toggle before sending
    //
    #define fnPrepareSetup(ptrUSB_HW) ptrUSB_HW->ptrEndpoint->ulNextTxData0 &= ~(ALTERNATE_TX_BUFFER);\
                                        *ptrUSB_HW->ptr_ulUSB_Rx_BDControl |= ALTERNATE_TX_BUFFER;\
                                        *ptrUSB_HW->ptr_ulUSB_Alt_Rx_BDControl &= ~ALTERNATE_TX_BUFFER;\
                                        _RESET_USB_BUFFERS()
    #define fnSetUSB_device_address(address) ptrUSB_HW->ucUSBAddress = address; ADDR = ((ADDR & 0x80) | address) // set the device address
    #define _USB_HOST_MODE()          ((ptrUSB_HW->ucModeType & USB_HOST_MODE) != 0)
#else
    #define _USB_HOST_MODE()          (0)
#endif

#define SET_CONTROL_DIRECTION(a,b)                                       // direction control not needed by Kinetis
#define CLEAR_SETUP(a)                                                   // for compatibility with generic driver
#define VALIDATE_NEW_CONFIGURATION()



#if defined HS_USB_AVAILABLE                                             // {25}
// USBHS
//
#define USBHS_ID             *(unsigned long *)(USBHS_BASE_ADD + 0x000)  // Peripheral ID Register (read-only)
#define USBHS_HWGENERAL      *(unsigned long *)(USBHS_BASE_ADD + 0x004)  // General Hardware Parameters Register (read-only)
#define USBHS_HWHOST         *(unsigned long *)(USBHS_BASE_ADD + 0x008)  // Host Hardware Parameters Register (read-only)
#define USBHS_HWDEVICE       *(unsigned long *)(USBHS_BASE_ADD + 0x00c)  // Device Hardware Parameters Register (read-only)
#define USBHS_HWTXBUF        *(unsigned long *)(USBHS_BASE_ADD + 0x010)  // Transmit Buffer Hardware Parameters Register (read-only)
#define USBHS_HWRXBUF        *(unsigned long *)(USBHS_BASE_ADD + 0x014)  // Receive Buffer Hardware Parameters Register (read-only) - reads zero

#define USBHS_GPTIMER0LD     *(volatile unsigned long *)(USBHS_BASE_ADD + 0x080)  // General Purpose Timer 0 Load Register
#define USBHS_GPTIMER0CTL    *(volatile unsigned long *)(USBHS_BASE_ADD + 0x084)  // General Purpose Timer 0 Control Register
#define USBHS_GPTIMER1LD     *(volatile unsigned long *)(USBHS_BASE_ADD + 0x088)  // General Purpose Timer 1 Load Register
#define USBHS_GPTIMER1CTL    *(volatile unsigned long *)(USBHS_BASE_ADD + 0x08c)  // General Purpose Timer 1 Control Register
#define USBHS_USB_SBUSCFG    *(volatile unsigned long *)(USBHS_BASE_ADD + 0x090)  // System Bus Interface Configuration Register

#define USBHS_HCIVERSION     *(unsigned long *)(USBHS_BASE_ADD + 0x100)  // Host Controller Version and Capabilities Register (read-only)
  #define USBHS_HCIVERSION_CAPLENGTH_MASK   0x000000ff
  #define USBHS_HCIVERSION_HCIVERSION_SHIFT 16
#define USBHS_HCSPARAMS      *(unsigned long *)(USBHS_BASE_ADD + 0x104)  // Host Controller Structural Parameters Register (read-only)
#define USBHS_HCCPARAMS      *(unsigned long *)(USBHS_BASE_ADD + 0x108)  // Host Controller Capability Parameters Register (read-only)

#define USBHS_DCIVERSION     *(unsigned short *)(USBHS_BASE_ADD + 0x122) // Device Controller Interface Version (read-only)
#define USBHS_DCCPARAMS      *(unsigned long *)(USBHS_BASE_ADD + 0x124)  // Device Controller Capability Parameters (read-only)
  #define USBHS_DCCPARAMS_DEN_MASK 0x0000001f                            // device endpoint number
  #define USBHS_DCCPARAMS_DC       0x00000080                            // device capable of USB2.0 device
  #define USBHS_DCCPARAMS_HC       0x00000100                            // device capable of EHCI compatible USB2.0 host

#define USBHS_USBCMD         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x140) // USB Command Register
  #define USBHS_USBCMD_RS        0x00000001                              // run/stop
  #define USBHS_USBCMD_RST       0x00000002                              // controller reset
  #define USBHS_USBCMD_FS_1024   0x00000000                              // frame list size 1024 elements (64 when FS2 is set)
  #define USBHS_USBCMD_FS_512    0x00000004                              // frame list size 512 elements (32 when FS2 is set)
  #define USBHS_USBCMD_FS_256    0x00000008                              // frame list size 256 elements (16 when FS2 is set)
  #define USBHS_USBCMD_FS_128    0x0000000c                              // frame list size 128 elements (8 when FS2 is set)
  #define USBHS_USBCMD_PSE       0x00000010                              // periodic schedule enable
  #define USBHS_USBCMD_ASE       0x00000020                              // asynchronous schedule enable
  #define USBHS_USBCMD_IAA       0x00000040                              // interrupt on asynch advance doorbell
  #define USBHS_USBCMD_ASP1      0x00000100                              // asynchronous schedule park mode count - 1 (zero is not allowed when park mode is enabled)
  #define USBHS_USBCMD_ASP2      0x00000200                              // asynchronous schedule park mode count - 2
  #define USBHS_USBCMD_ASP3      0x00000300                              // asynchronous schedule park mode count - 3
  #define USBHS_USBCMD_ASPE      0x00000800                              // asynchronous schedule park mode enabled
  #define USBHS_USBCMD_SUTW      0x00002000                              // setup TripWire
  #define USBHS_USBCMD_ATDTW     0x00004000                              // add dTD TripWire
  #define USBHS_USBCMD_FS2       0x00008000                              // frame list size 2
  #define USBHS_USBCMD_ITC_IMM   0x00000000                              // interrupt threshold control - immediate
  #define USBHS_USBCMD_ITC_1_MF  0x00010000                              // interrupt threshold control - maximum rate 1 microframe
  #define USBHS_USBCMD_ITC_2_MF  0x00020000                              // interrupt threshold control - maximum rate 2 microframes
  #define USBHS_USBCMD_ITC_4_MF  0x00040000                              // interrupt threshold control - maximum rate 4 microframes
  #define USBHS_USBCMD_ITC_8_MF  0x00080000                              // interrupt threshold control - maximum rate 8 microframes
  #define USBHS_USBCMD_ITC_16_MF 0x00100000                              // interrupt threshold control - maximum rate 16 microframes
  #define USBHS_USBCMD_ITC_32_MF 0x00200000                              // interrupt threshold control - maximum rate 32 microframes
  #define USBHS_USBCMD_ITC_64_MF 0x00400000                              // interrupt threshold control - maximum rate 64 microframes
#define USBHS_USBSTS         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x144) // USB Status Register
#define USBHS_USBINTR        *(volatile unsigned long *)(USBHS_BASE_ADD + 0x148) // USB Interrupt Enable Register
  #define USBHS_USBINTR_UE    0x00000001                                 // USB interrupt enable
  #define USBHS_USBINTR_UEE   0x00000002                                 // USB error interrupt enable
  #define USBHS_USBINTR_PCE   0x00000004                                 // port change detect interrupt enable
  #define USBHS_USBINTR_FRE   0x00000008                                 // frame list rollover interrupt enable
  #define USBHS_USBINTR_SEE   0x00000010                                 // system error interrupt enable
  #define USBHS_USBINTR_AAE   0x00000020                                 // async advance interrupt enable
  #define USBHS_USBINTR_URE   0x00000040                                 // USB reset interrupt enable
  #define USBHS_USBINTR_SRE   0x00000080                                 // SOF-received interrupt enable
  #define USBHS_USBINTR_SLE   0x00000100                                 // sleep (DC suspend) interrupt enable
  #define USBHS_USBINTR_ULPIE 0x00000400                                 // ULPI interrupt enable
  #define USBHS_USBINTR_NAKE  0x00010000                                 // nak interrupt enable
  #define USBHS_USBINTR_UAIE  0x00040000                                 // USH host asychronous interrupt enable
  #define USBHS_USBINTR_UPIE  0x00080000                                 // USB host periodic interrupt enable
  #define USBHS_USBINTR_TIE0  0x01000000                                 // general purpose timer 0 interrupt enable
  #define USBHS_USBINTR_TIE1  0x02000000                                 // general purpose timer 1 interrupt enable
#define USBHS_FRINDEX        *(volatile unsigned long *)(USBHS_BASE_ADD + 0x14c) // Frame Index Register

#define USBHS_PERIODICLISTBASE *(volatile unsigned long *)(USBHS_BASE_ADD + 0x154) // Periodic Frame List Base Address Register
#define USBHS_DEVICEADDR     USBHS_PERIODICLISTBASE                      // Device Address Register
  #define USBHS_DEVICEADDR_USBADRA      0x01000000                       // device address advance
  #define USBHS_DEVICEADDR_USBADR_MASK  0xfe000000                       // device address mask
  #define USBHS_DEVICEADDR_USBADR_SHIFT 25                               // device address shift
#define USBHS_ASYNCLISTADDR  *(unsigned long *)(USBHS_BASE_ADD + 0x158)  // Current Asynchronous List Address Register
#define USBHS_EPLISTADDR     USBHS_ASYNCLISTADDR                         // Endpoint List Address Register
#define USBHS_TTCTRL         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x15c) // Host TT Asynchronous Buffer Control
#define USBHS_BURSTSIZE      *(volatile unsigned long *)(USBHS_BASE_ADD + 0x160) // Master Interface Data Burst Size Register
#define USBHS_TXFILLTUNING   *(volatile unsigned long *)(USBHS_BASE_ADD + 0x164) // Transmit FIFO Tuning Control Register

#define USBHS_ULPI_VIEWPORT  *(volatile unsigned long *)(USBHS_BASE_ADD + 0x170) // ULPI Register Access

#define USBHS_ENDPTNAK       *(volatile unsigned long *)(USBHS_BASE_ADD + 0x178) // Endpoint NAK Register
#define USBHS_ENDPTNAKEN     *(volatile unsigned long *)(USBHS_BASE_ADD + 0x17c) // Endpoint NAK Enable Register
#define USBHS_CONFIGFLAG     *(unsigned long *)(USBHS_BASE_ADD + 0x180)  // Configure Flag Register (read-only)
#define USBHS_PORTSC1        *(volatile unsigned long *)(USBHS_BASE_ADD + 0x184) // Port Status and Control Register
  #define USBHS_PORTSC1_CCS      0x00000001                              // current connect status
  #define USBHS_PORTSC1_CSC      0x00000002                              // connect status changed
  #define USBHS_PORTSC1_PE       0x00000004                              // port enabled
  #define USBHS_PORTSC1_PEC      0x00000008                              // port disabled
  #define USBHS_PORTSC1_OCA      0x00000010                              // over current active
  #define USBHS_PORTSC1_OCC      0x00000020                              // over current change detected (write '1' to clear)
  #define USBHS_PORTSC1_FPR      0x00000040                              // force port resume
  #define USBHS_PORTSC1_SUSP     0x00000080                              // port in suspend mode (read-only in device mode)
  #define USBHS_PORTSC1_PR       0x00000100                              // port reset
  #define USBHS_PORTSC1_HSP      0x00000200                              // high speed port (read-only)
  #define USBHS_PORTSC1_LS_SE0   0x00000000                              // line-state - SE0 (read-only
  #define USBHS_PORTSC1_LS_J     0x00000400                              // line-state - J-state (read-only
  #define USBHS_PORTSC1_LS_K     0x00000800                              // line-state - K-state (read-only
  #define USBHS_PORTSC1_PP       0x00001000                              // port power
  #define USBHS_PORTSC1_PO       0x00000000                              // port owner - not supported
  #define USBHS_PORTSC1_PIC      0x00000000                              // port indicator control - not supported
  #define USBHS_PORTSC1_PTC_OFF  0x00000000                              // port test control - off
  #define USBHS_PORTSC1_PTC_J    0x00010000                              // port test control - J_STATE
  #define USBHS_PORTSC1_PTC_K    0x00020000                              // port test control - K_STATE
  #define USBHS_PORTSC1_PTC_NAK  0x00030000                              // port test control - SEQ_NAK
  #define USBHS_PORTSC1_PTC_PAC  0x00040000                              // port test control - packet
  #define USBHS_PORTSC1_PTC_HS   0x00050000                              // port test control - force enable high speed
  #define USBHS_PORTSC1_PTC_FS   0x00060000                              // port test control - force enable full speed
  #define USBHS_PORTSC1_PTC_LS   0x00070000                              // port test control - force enable low speed
  #define USBHS_PORTSC1_WKCN     0x00100000                              // wake on connect enable
  #define USBHS_PORTSC1_WKDS     0x00200000                              // wake on disconnect enable
  #define USBHS_PORTSC1_WKOC     0x00400000                              // wake on over-current enable
  #define USBHS_PORTSC1_PHCD     0x00800000                              // phy low power suspend
  #define USBHS_PORTSC1_PFSC     0x01000000                              // port force full-speed contact
  #define USBHS_PORTSC1_PSPD_FS  0x04000000                              // port speed - full speed (read-only
  #define USBHS_PORTSC1_PSPD_LS  0x08000000                              // port speed - low speed (read-only
  #define USBHS_PORTSC1_PSPD_HS  0x0c000000                              // port speed - high speed (read-only
  #define USBHS_PORTSC1_PTS_ULPI 0x80000000                              // port transceiver select ULPI
#define USBHS_OTGSC          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1a4) // On-the-Go Status and Control Register
#define USBHS_USBMODE        *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1a8) // USB Mode Register
  #define USBHS_USBMODE_CM_IDLE    0x00000000                            // idle mode
  #define USBHS_USBMODE_CM_DEVICE  0x00000002                            // device mode
  #define USBHS_USBMODE_CM_HOST    0x00000003                            // host mode
  #define USBHS_USBMODE_ES_LITTLE  0x00000000                            // endian select - little-endian
  #define USBHS_USBMODE_ES_BIG     0x00000004                            // endian select - big-endian
  #define USBHS_USBMODE_SLOM       0x00000008                            // setup lock-out mode
  #define USBHS_USBMODE_SDIS       0x00000010                            // stream disable
  #define USBHS_USBMODE_TXHSD_MASK 0x00007000                            // Tx to Tx HS delay
  #define USBHS_USBMODE_TXHSD_10   0x00000000                            // 10 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_11   0x00001000                            // 11 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_12   0x00002000                            // 12 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_13   0x00003000                            // 13 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_14   0x00004000                            // 14 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_15   0x00005000                            // 15 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_16   0x00006000                            // 16 PHY clock cycles
  #define USBHS_USBMODE_TXHSD_17   0x00007000                            // 17 PHY clock cycles
#define USBHS_EPSETUPSR      *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1ac) // Endpoint Setup Status Register (device mode only) (write '1' to clear)
  #define USBHS_EPSETUPSR_SETUP0   0x00000001
  #define USBHS_EPSETUPSR_SETUP1   0x00000002
  #define USBHS_EPSETUPSR_SETUP2   0x00000004
  #define USBHS_EPSETUPSR_SETUP3   0x00000008
  #define USBHS_EPSETUPSR_SETUP4   0x00000010
  #define USBHS_EPSETUPSR_SETUP5   0x00000020
  #define USBHS_EPSETUPSR_SETUP6   0x00000040
  #define USBHS_EPSETUPSR_SETUP7   0x00000080
  #define USBHS_EPSETUPSR_SETUP8   0x00000100
  #define USBHS_EPSETUPSR_SETUP9   0x00000200
  #define USBHS_EPSETUPSR_SETUP10  0x00000400
  #define USBHS_EPSETUPSR_SETUP11  0x00000800
  #define USBHS_EPSETUPSR_SETUP12  0x00100000
  #define USBHS_EPSETUPSR_SETUP13  0x00200000
  #define USBHS_EPSETUPSR_SETUP14  0x00400000
  #define USBHS_EPSETUPSR_SETUP15  0x00800000
#define USBHS_EPPRIME        *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1b0) // Endpoint Initialisation Register
  #define USBHS_EPPRIME_PERB0      0x00000001                            // prime endpoint receive buffers
  #define USBHS_EPPRIME_PERB1      0x00000002
  #define USBHS_EPPRIME_PERB2      0x00000004
  #define USBHS_EPPRIME_PERB3      0x00000008
  #define USBHS_EPPRIME_PERB4      0x00000010
  #define USBHS_EPPRIME_PERB5      0x00000020
  #define USBHS_EPPRIME_PERB6      0x00000040
  #define USBHS_EPPRIME_PERB7      0x00000080
  #define USBHS_EPPRIME_PERB8      0x00000100
  #define USBHS_EPPRIME_PERB9      0x00000200
  #define USBHS_EPPRIME_PERB10     0x00000400
  #define USBHS_EPPRIME_PERB11     0x00000800
  #define USBHS_EPPRIME_PERB12     0x00001000
  #define USBHS_EPPRIME_PERB13     0x00002000
  #define USBHS_EPPRIME_PERB14     0x00004000
  #define USBHS_EPPRIME_PERB15     0x00008000
  #define USBHS_EPPRIME_PETB0      0x00010000                            // prime endpoint transmit buffers
  #define USBHS_EPPRIME_PETB1      0x00020000
  #define USBHS_EPPRIME_PETB2      0x00040000
  #define USBHS_EPPRIME_PETB3      0x00080000
  #define USBHS_EPPRIME_PETB4      0x00100000
  #define USBHS_EPPRIME_PETB5      0x00200000
  #define USBHS_EPPRIME_PETB6      0x00400000
  #define USBHS_EPPRIME_PETB7      0x00800000
  #define USBHS_EPPRIME_PETB8      0x01000000
  #define USBHS_EPPRIME_PETB9      0x02000000
  #define USBHS_EPPRIME_PETB10     0x04000000
  #define USBHS_EPPRIME_PETB11     0x08000000
  #define USBHS_EPPRIME_PETB12     0x10000000
  #define USBHS_EPPRIME_PETB13     0x20000000
  #define USBHS_EPPRIME_PETB14     0x40000000
  #define USBHS_EPPRIME_PETB15     0x80000000
#define USBHS_EPFLUSH        *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1b4) // Endpoint Flush Register
  #define USBHS_EPFLUSH_FERB0      0x00000001                            // flush endpoint receive buffers
  #define USBHS_EPFLUSH_FERB1      0x00000002
  #define USBHS_EPFLUSH_FERB2      0x00000004
  #define USBHS_EPFLUSH_FERB3      0x00000008
  #define USBHS_EPFLUSH_FERB4      0x00000010
  #define USBHS_EPFLUSH_FERB5      0x00000020
  #define USBHS_EPFLUSH_FERB6      0x00000040
  #define USBHS_EPFLUSH_FERB7      0x00000080
  #define USBHS_EPFLUSH_FERB8      0x00000100
  #define USBHS_EPFLUSH_FERB9      0x00000200
  #define USBHS_EPFLUSH_FERB10     0x00000400
  #define USBHS_EPFLUSH_FERB11     0x00000800
  #define USBHS_EPFLUSH_FERB12     0x00001000
  #define USBHS_EPFLUSH_FERB13     0x00002000
  #define USBHS_EPFLUSH_FERB14     0x00004000
  #define USBHS_EPFLUSH_FERB15     0x00008000
  #define USBHS_EPFLUSH_FETB0      0x00010000                            // flush endpoint transmit buffers
  #define USBHS_EPFLUSH_FETB1      0x00020000
  #define USBHS_EPFLUSH_FETB2      0x00040000
  #define USBHS_EPFLUSH_FETB3      0x00080000
  #define USBHS_EPFLUSH_FETB4      0x00100000
  #define USBHS_EPFLUSH_FETB5      0x00200000
  #define USBHS_EPFLUSH_FETB6      0x00400000
  #define USBHS_EPFLUSH_FETB7      0x00800000
  #define USBHS_EPFLUSH_FETB8      0x01000000
  #define USBHS_EPFLUSH_FETB9      0x02000000
  #define USBHS_EPFLUSH_FETB10     0x04000000
  #define USBHS_EPFLUSH_FETB11     0x08000000
  #define USBHS_EPFLUSH_FETB12     0x10000000
  #define USBHS_EPFLUSH_FETB13     0x20000000
  #define USBHS_EPFLUSH_FETB14     0x40000000
  #define USBHS_EPFLUSH_FETB15     0x80000000
#define USBHS_EPSR           *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1b8) // Endpoint Status Register (read-only)
#define USBHS_EPCOMPLETE     *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1bc) // Endpoint Complete Register (device mode only) (write '1' to clear)
  #define USBHS_EPCOMPLETE_ERCE0   0x00000001                            // flush endpoint receive buffers
  #define USBHS_EPCOMPLETE_ERCE1   0x00000002
  #define USBHS_EPCOMPLETE_ERCE2   0x00000004
  #define USBHS_EPCOMPLETE_ERCE3   0x00000008
  #define USBHS_EPCOMPLETE_ERCE4   0x00000010
  #define USBHS_EPCOMPLETE_ERCE5   0x00000020
  #define USBHS_EPCOMPLETE_ERCE6   0x00000040
  #define USBHS_EPCOMPLETE_ERCE7   0x00000080
  #define USBHS_EPCOMPLETE_ERCE8   0x00000100
  #define USBHS_EPCOMPLETE_ERCE9   0x00000200
  #define USBHS_EPCOMPLETE_ERCE10  0x00000400
  #define USBHS_EPCOMPLETE_ERCE11  0x00000800
  #define USBHS_EPCOMPLETE_ERCE12  0x00001000
  #define USBHS_EPCOMPLETE_ERCE13  0x00002000
  #define USBHS_EPCOMPLETE_ERCE14  0x00004000
  #define USBHS_EPCOMPLETE_ERCE15  0x00008000
  #define USBHS_EPCOMPLETE_ETCE0   0x00010000                            // flush endpoint transmit buffers
  #define USBHS_EPCOMPLETE_ETCE1   0x00020000
  #define USBHS_EPCOMPLETE_ETCE2   0x00040000
  #define USBHS_EPCOMPLETE_ETCE3   0x00080000
  #define USBHS_EPCOMPLETE_ETCE4   0x00100000
  #define USBHS_EPCOMPLETE_ETCE5   0x00200000
  #define USBHS_EPCOMPLETE_ETCE6   0x00400000
  #define USBHS_EPCOMPLETE_ETCE7   0x00800000
  #define USBHS_EPCOMPLETE_ETCE8   0x01000000
  #define USBHS_EPCOMPLETE_ETCE9   0x02000000
  #define USBHS_EPCOMPLETE_ETCE10  0x04000000
  #define USBHS_EPCOMPLETE_ETCE11  0x08000000
  #define USBHS_EPCOMPLETE_ETCE12  0x10000000
  #define USBHS_EPCOMPLETE_ETCE13  0x20000000
  #define USBHS_EPCOMPLETE_ETCE14  0x40000000
  #define USBHS_EPCOMPLETE_ETCE15  0x80000000
#define USBHS_EPCR0_ADDR      (volatile unsigned long *)(USBHS_BASE_ADD + 0x1c0) // endpoint 0 is fixed in control mode and is always enabled
#define USBHS_EPCR0          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1c0) // Endpoint Control Register 0
  #define USBHS_EPCR_RXS      0x00000001                                 // rx endpoint stall (read-write)
  #define USBHS_EPCR_RXD      0x00000002                                 // rx endpoint data source (should never be set)
  #define USBHS_EPCR_RXT_CON  0x00000000                                 // rx endpoint type control
  #define USBHS_EPCR_RXT_ISO  0x00000004                                 // rx endpoint type isochronous (not endpoint 0)
  #define USBHS_EPCR_RXT_BULK 0x00000008                                 // rx endpoint type bulk (not endpoint 0)
  #define USBHS_EPCR_RXT_INT  0x0000000c                                 // rx endpoint type interrupt (not endpoint 0)
  #define USBHS_EPCR_RXI      0x00000020                                 // rx data toggle inhibit (used only for test purposes)
  #define USBHS_EPCR_RXR      0x00000040                                 // rx data toggle reset (write '1' to synchronise - self-clearing)
  #define USBHS_EPCR_RXE      0x00000080                                 // rx endpoint enable
  #define USBHS_EPCR_TXS      0x00010000                                 // tx endpoint stall
  #define USBHS_EPCR_TXD      0x00020000                                 // tx endpoint data source (should never be set)
  #define USBHS_EPCR_TXT_CON  0x00000000                                 // tx endpoint type control
  #define USBHS_EPCR_TXT_ISO  0x00040000                                 // tx endpoint type isochronous (not endpoint 0)
  #define USBHS_EPCR_TXT_BULK 0x00080000                                 // tx endpoint type bulk (not endpoint 0)
  #define USBHS_EPCR_TXT_INT  0x000c0000                                 // tx endpoint type interrupt (not endpoint 0)
  #define USBHS_EPCR_TXI      0x00200000                                 // tx data toggle inhibit (used only for test purposes - not endpoint 0)
  #define USBHS_EPCR_TXR      0x00400000                                 // tx data toggle reset (write '1' to synchronise - self-clearing - not endpoint 0)
  #define USBHS_EPCR_TXE      0x00800000                                 // tx endpoint enable (read-only on endpoint 0)
#define USBHS_EPCR1          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1c4) // Endpoint Control Register 1
#define USBHS_EPCR2          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1c8) // Endpoint Control Register 2
#define USBHS_EPCR3          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1cc) // Endpoint Control Register 3
#define USBHS_EPCR4          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1d0) // Endpoint Control Register 4
#define USBHS_EPCR5          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1d4) // Endpoint Control Register 5
#define USBHS_EPCR6          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1d8) // Endpoint Control Register 6
#define USBHS_EPCR7          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1dc) // Endpoint Control Register 7
#define USBHS_EPCR8          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1e0) // Endpoint Control Register 8
#define USBHS_EPCR9          *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1e4) // Endpoint Control Register 9
#define USBHS_EPCR10         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1e8) // Endpoint Control Register 10
#define USBHS_EPCR11         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1ec) // Endpoint Control Register 11
#define USBHS_EPCR12         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1f0) // Endpoint Control Register 12
#define USBHS_EPCR13         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1f4) // Endpoint Control Register 13
#define USBHS_EPCR14         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1f8) // Endpoint Control Register 14
#define USBHS_EPCR15         *(volatile unsigned long *)(USBHS_BASE_ADD + 0x1fc) // Endpoint Control Register 15
#define USBHS_USBGENCTRL     *(volatile unsigned long *)(USBHS_BASE_ADD + 0x200) // USB General Control Register
#endif

#if defined KINETIS_WITH_USBPHY                                          // {77}
    #define USBPHY_PWD       *(volatile unsigned long *)(USBHS_PHY_ADD + 0x000) // USB PHY power down register
    #define USBPHY_PWD_SET   *(volatile unsigned long *)(USBHS_PHY_ADD + 0x004) // USB PHY power down set register
    #define USBPHY_PWD_CLR   *(volatile unsigned long *)(USBHS_PHY_ADD + 0x008) // USB PHY power down clear register
    #define USBPHY_PWD_TOG   *(volatile unsigned long *)(USBHS_PHY_ADD + 0x00c) // USB PHY power down toggle register
    #define USBPHY_TX        *(volatile unsigned long *)(USBHS_PHY_ADD + 0x010) // USB PHY transmit control register
    #define USBPHY_TX_SET    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x014) // USB PHY transmit control set register
    #define USBPHY_TX_CLR    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x018) // USB PHY transmit control clear register
    #define USBPHY_TX_TOG    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x01c) // USB PHY transmit control toggle register
    #define USBPHY_RX        *(volatile unsigned long *)(USBHS_PHY_ADD + 0x020) // USB PHY receive control register
    #define USBPHY_RX_SET    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x024) // USB PHY receive control set register
    #define USBPHY_RX_CLR    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x028) // USB PHY receive control clear register
    #define USBPHY_RX_TOG    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x02c) // USB PHY receive control toggle register
    #define USBPHY_CTRL      *(volatile unsigned long *)(USBHS_PHY_ADD + 0x030) // USB PHY general control register
      #define USBPHY_CTRL_ENHOSTDISCONDETECT   0x00000002                //
      #define USBPHY_CTRL_HOSTDISCONDETECT_IRQ 0x00000008                //
      #define USBPHY_CTRL_ENDEVPLUGINDET    0x00000010                   //
      #define USBPHY_CTRL_DEVPLUGIN_IRQ     0x00001000                   //
      #define USBPHY_CTRL_ENUTMILEVEL2      0x00004000                   //
      #define USBPHY_CTRL_ENUTMILEVEL3      0x00008000                   //
      #define USBPHY_CTRL_AUTORESUME_EN     0x00040000                   //
      #define USBPHY_CTRL_ENAUTOCLR_CLKGATE 0x00080000                   //
      #define USBPHY_CTRL_ENAUTOCLR_PHY_PWD 0x00100000                   //
      #define USBPHY_CTRL_FSDLL_RST_EN      0x01000000                   //
      #define USBPHY_CTRL_OTG_ID_VALUE      0x08000000                   // (read-only)
      #define USBPHY_CTRL_HOST_FORCE_LS_SE0 0x10000000                   //
      #define USBPHY_CTRL_UTMI_SUSPENDM     0x20000000                   // (read-only)
      #define USBPHY_CTRL_CLKGATE           0x40000000                   //
      #define USBPHY_CTRL_SFTRST            0x80000000                   // 
    #define USBPHY_CTRL_SET  *(volatile unsigned long *)(USBHS_PHY_ADD + 0x034) // USB PHY general control set register
    #define USBPHY_CTRL_CLR  *(volatile unsigned long *)(USBHS_PHY_ADD + 0x038) // USB PHY general control clear register
    #define USBPHY_CTRL_TOG  *(volatile unsigned long *)(USBHS_PHY_ADD + 0x03c) // USB PHY general control toggle register
    #define USBPHY_STATUS    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x040) // USB PHY status register
    #define USBPHY_DEBUG     *(volatile unsigned long *)(USBHS_PHY_ADD + 0x050) // USB PHY debug register
    #define USBPHY_DEBUG_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x054) // USB PHY debug set register
    #define USBPHY_DEBUG_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x058) // USB PHY debug clear register
    #define USBPHY_DEBUG_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x05c) // USB PHY debug toggle register
    #define USBPHY_DEBUG0_STATUS *(volatile unsigned long *)(USBHS_PHY_ADD + 0x060) // UTMI debug 0 status register
    #define USBPHY_DEBUG1    *(volatile unsigned long *)(USBHS_PHY_ADD + 0x070) // UTMI debug 1 status register
    #define USBPHY_DEBUG1_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x074) // UTMI debug 1 status set register
    #define USBPHY_DEBUG1_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x078) // UTMI debug 1 status clear register
    #define USBPHY_DEBUG1_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x07c) // UTMI debug 1 status toggle register
    #define USBPHY_VERSION   *(volatile unsigned long *)(USBHS_PHY_ADD + 0x080) // UTMI RTL version register (read-only)
    #define USBPHY_PLL_SIC   *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0a0) // USB PHY PLL control/status register
      #define USBPHY_PLL_SIC_PLL_DIV_SEL_24MHz 0x00000000                // PLL reference is 24MHz
      #define USBPHY_PLL_SIC_PLL_DIV_SEL_16MHz 0x00000001                // PLL reference is 16MHz
      #define USBPHY_PLL_SIC_PLL_DIV_SEL_12MHz 0x00000002                // PLL reference is 12MHz
      #define USBPHY_PLL_SIC_PLL_EN_USB_CLKS   0x00000040                // enable the USB clock output from the USB PHY PLL
      #define USBPHY_PLL_SIC_PLL_HOLD_RING_OFF 0x00000800                // analogue debug bit (not for customer use) - it should always remain off
      #define USBPHY_PLL_SIC_PLL_POWER         0x00001000                // power up the USB PLL
      #define USBPHY_PLL_SIC_PLL_ENABLE        0x00002000                // enable the clock output from the USB PLL
      #define USBPHY_PLL_SIC_PLL_BYPASS        0x00010000                // bypass the USB PLL
      #define USBPHY_PLL_SIC_PLL_LOCK          0x80000000                // PLL locked (read-only)
    #define USBPHY_PLL_SIC_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0a4) // USB PHY PLL control/status set register
    #define USBPHY_PLL_SIC_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0a8) // USB PHY PLL control/status clear register
    #define USBPHY_PLL_SIC_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0ac) // USB PHY PLL control/status toggle register
    #define USBPHY_USB1_VBUS_DETECT *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0c0) // USB PHY VBUS detect control register
    #define USBPHY_USB1_VBUS_DETECT_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0c4) // USB PHY VBUS detect control set register
    #define USBPHY_USB1_VBUS_DETECT_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0c8) // USB PHY VBUS detect control clear register
    #define USBPHY_USB1_VBUS_DETECT_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0cc) // USB PHY VBUS detect control toggle register
    #define USBPHY_USB1_VBUS_DET_STAT *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0d0) // USB PHY VBUS detector status register (read-only)
    #define USBPHY_USB1_VBUS_CHRG_DET_STAT *(volatile unsigned long *)(USBHS_PHY_ADD + 0x0f0) // USB PHY charger detect status register (read-only)
    #define USBPHY_ANACTRL   *(volatile unsigned long *)(USBHS_PHY_ADD + 0x100) // USB PHY analog control register
    #define USBPHY_ANACTRL_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x104) // USB PHY analog control set register
    #define USBPHY_ANACTRL_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x108) // USB PHY analog control clear register
    #define USBPHY_ANACTRL_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x10c) // USB PHY analog control toggle register
    #define USBPHY_USB1_LOOPBACK *(volatile unsigned long *)(USBHS_PHY_ADD + 0x110) // USB PHY loopback control/status register
    #define USBPHY_USB1_LOOPBACK_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x114) // USB PHY loopback control/status set register
    #define USBPHY_USB1_LOOPBACK_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x118) // USB PHY loopback control/status clear register
    #define USBPHY_USB1_LOOPBACK_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x11c) // USB PHY loopback control/status toggle register
    #define USBPHY_USB1_LOOPBACK_HSFSCNT *(volatile unsigned long *)(USBHS_PHY_ADD + 0x120) // USB PHY loopback packet number select register
    #define USBPHY_USB1_LOOPBACK_HSFSCNT_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x124) // USB PHY loopback packet number set register
    #define USBPHY_USB1_LOOPBACK_HSFSCNT_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x128) // USB PHY loopback packet number clear register
    #define USBPHY_USB1_LOOPBACK_HSFSCNT_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x12c) // USB PHY loopback packet number toggle register
    #define USBPHY_TRIM_OVERRIDE_EN *(volatile unsigned long *)(USBHS_PHY_ADD + 0x130) // USB PHY trim override enable register
    #define USBPHY_TRIM_OVERRIDE_EN_SET *(volatile unsigned long *)(USBHS_PHY_ADD + 0x134) // USB trim override enable set register
    #define USBPHY_TRIM_OVERRIDE_EN_CLR *(volatile unsigned long *)(USBHS_PHY_ADD + 0x138) // USB trim override enable clear register
    #define USBPHY_TRIM_OVERRIDE_EN_TOG *(volatile unsigned long *)(USBHS_PHY_ADD + 0x13c) // USB trim override enable toggle register
#endif

// Comparator
//
#if defined KINETIS_KE                                                   // {85}
    #define ACMP0_CS             *(volatile unsigned char *)(ACMP0_BLOCK + 0x0) // ACMP 0 control and status register
    #define ACMP0_C0             *(unsigned char *)(ACMP0_BLOCK + 0x1)   // ACMP 0 control register 0
    #define ACMP0_C1             *(unsigned char *)(ACMP0_BLOCK + 0x2)   // ACMP 0 control register 1
    #define ACMP0_C2             *(unsigned char *)(ACMP0_BLOCK + 0x3)   // ACMP 0 control register 2

    #define ACMP1_CS             *(volatile unsigned char *)(ACMP1_BLOCK + 0x0) // ACMP 1 control and status register
    #define ACMP1_C0             *(unsigned char *)(ACMP1_BLOCK + 0x1)   // ACMP 1 control register 0
    #define ACMP1_C1             *(unsigned char *)(ACMP1_BLOCK + 0x2)   // ACMP 1 control register 1
    #define ACMP1_C2             *(unsigned char *)(ACMP1_BLOCK + 0x3)   // ACMP 1 control register 2
#else
    #define CMP0_CR0             *(unsigned char *)(CMP0_BLOCK + 0x0)    // CMP 0 control register 0
    #define CMP0_CR1             *(unsigned char *)(CMP0_BLOCK + 0x1)    // CMP 0 control register 1
    #define CMP0_FPR             *(unsigned char *)(CMP0_BLOCK + 0x2)    // CMP 0 filter period register
    #define CMP0_SCR             *(volatile unsigned char *)(CMP0_BLOCK + 0x3) // CMP 0 status and control register
    #define CMP0_DACCR           *(unsigned char *)(CMP0_BLOCK + 0x4)    // CMP 0 DAC control register
    #define CMP0_MUXCR           *(unsigned char *)(CMP0_BLOCK + 0x5)    // CMP 0 MUX control register

    #define CMP1_CR0             *(unsigned char *)(CMP1_BLOCK + 0x0)    // CMP 1 control register 0
    #define CMP1_CR1             *(unsigned char *)(CMP1_BLOCK + 0x1)    // CMP 1 control register 1
    #define CMP1_FPR             *(unsigned char *)(CMP1_BLOCK + 0x2)    // CMP 1 filter period register
    #define CMP1_SCR             *(volatile unsigned char *)(CMP1_BLOCK + 0x3) // CMP 1 status and control register
    #define CMP1_DACCR           *(unsigned char *)(CMP1_BLOCK + 0x4)    // CMP 1 DAC control register
    #define CMP1_MUXCR           *(unsigned char *)(CMP1_BLOCK + 0x5)    // CMP 1 MUX control register

    #define CMP2_CR0             *(unsigned char *)(CMP2_BLOCK + 0x0)    // CMP 2 control register 0
    #define CMP2_CR1             *(unsigned char *)(CMP2_BLOCK + 0x1)    // CMP 2 control register 1
    #define CMP2_FPR             *(unsigned char *)(CMP2_BLOCK + 0x2)    // CMP 2 filter period register
    #define CMP2_SCR             *(volatile unsigned char *)(CMP2_BLOCK + 0x3) // CMP 2 status and control register
    #define CMP2_DACCR           *(unsigned char *)(CMP2_BLOCK + 0x4)    // CMP 2 DAC control register
    #define CMP2_MUXCR           *(unsigned char *)(CMP2_BLOCK + 0x5)    // CMP 2 MUX control register

    #define CMP3_CR0             *(unsigned char *)(CMP3_BLOCK + 0x0)    // CMP 3 control register 0
    #define CMP3_CR1             *(unsigned char *)(CMP3_BLOCK + 0x1)    // CMP 3 control register 1
    #define CMP3_FPR             *(unsigned char *)(CMP3_BLOCK + 0x2)    // CMP 3 filter period register
    #define CMP3_SCR             *(volatile unsigned char *)(CMP3_BLOCK + 0x3) // CMP 3 status and control register
    #define CMP3_DACCR           *(unsigned char *)(CMP3_BLOCK + 0x4)    // CMP 3 DAC control register
    #define CMP3_MUXCR           *(unsigned char *)(CMP3_BLOCK + 0x5)    // CMP 3 MUX control register
#endif

// VREF
//
#define VREF_TRM             *(unsigned char *)(VREF_ADD + 0x0)          // VREF Trim Register
  #define VREF_TRM_TRIP_MASK 0x3f
#define VREF_SC              *(volatile unsigned char *)(VREF_ADD + 0x1) // VREF Status and Control Register
  #define VREF_SC_MODE_LV_BG 0x00                                        // bandgap on only
  #define VREF_SC_MODE_LV_LP 0x01                                        // low-power buffer enabled
  #define VREF_SC_MODE_LV_TR 0x02                                        // tight-regulation buffer enabled
  #define VREF_SC_VREFST     0x04                                        // internal voltage reference stable (read-only)
  #define VREF_SC_REGEN      0x40                                        // enable internal 1.75V regulator
  #define VREF_SC_VREFEN     0x80                                        // enable module



#if defined KINETIS_K_FPU || defined KINETIS_KL || defined KINETIS_REVISION_2 || (KINETIS_MAX_SPEED > 100000000) // {43}
    // System Mode Controller
    //
    #define SMC_PMPROT       *(volatile unsigned char *)(SMC_BASE_ADD + 0x0) // Power Mode Protection Register (write-once)
      #define SMC_PMPROT_AVLLS 0x02                                      // allow very low-leakage stop mode (VLLSx)
      #define SMC_PMPROT_ALLS  0x08                                      // allow low-leakage stop mode (LLS)
      #define SMC_PMPROT_AVLP  0x20                                      // allow very low power modes (VLPR, VLPW and VLPS are allowed)
      #if defined HIGH_SPEED_RUN_MODE_AVAILABLE
        #define SMC_PMPROT_AHSRUN  0x80                                  // allow high speed run mode (HSRUN)
      #endif
    #define SMC_PMCTRL       *(volatile unsigned char *)(SMC_BASE_ADD + 0x1) // Power Mode Control Register
      #define SMC_PMCTRL_STOPM_NORMAL 0x00                               // stop mode control - normal stop
      #define SMC_PMCTRL_STOPM_VLPS   0x02                               // stop mode control - very low power stop (VLPS)
      #define SMC_PMCTRL_STOPM_LLS    0x03                               // stop mode control - low-leakage stop (LLS)
      #define SMC_PMCTRL_STOPM_VLLSx  0x04                               // stop mode control - very-low-leakage stop (VLLSx)
      #define SMC_PMCTRL_STOPA        0x08                               // previous stop mode entry was aborted (read-only)
      #define SMC_PMCTRL_RUNM_NORMAL  0x00                               // normal run mode
      #define SMC_PMCTRL_RUNM_VLPR    0x40                               // very low power run mode
      #if defined HIGH_SPEED_RUN_MODE_AVAILABLE
        #define SMC_PMCTRL_RUNM_HSRUN 0x60                               // high speed run mode
      #endif
      #define SMC_PMCTRL_LPWUI        0x80                               // (not KL) the system exits from VLP mode (VLPR, VLPW or VLPS) on an interrupt
    #if defined KINETIS_KL || defined KINETIS_K22
        #define SMC_STOPCTRL     *(unsigned char *)(SMC_BASE_ADD + 0x2)  // Stop Control Register
          #define SMC_STOPCTRL_VLLSM_VLLS0   0x00                        // VLLS mode control - VLLS0
          #define SMC_STOPCTRL_VLLSM_VLLS1   0x01                        // VLLS mode control - VLLS1
        #if defined KINETIS_K22
          #define SMC_STOPCTRL_VLLSM_VLLS2   0x02                        // VLLS mode control - VLLS2
        #endif
          #define SMC_STOPCTRL_VLLSM_VLLS3   0x03                        // VLLS mode control - VLLS3
          #define SMC_STOPCTRL_PORPO         0x20                        // disable POR detect circuit in VLLS0 mode
          #define SMC_STOPCTRL_PSTOPO_STOP   0x00                        // partial stop option - normal stop mode
          #define SMC_STOPCTRL_PSTOPO_PSTOP1 0x40                        // partial stop option - partial stop with both system and bus clocks disabled
          #define SMC_STOPCTRL_PSTOPO_PSTOP2 0x80                        // partial stop option - partial stop with system clock disabled but bus clock enabled
    #else
        #define SMC_VLLSCTRL     *(unsigned char *)(SMC_BASE_ADD + 0x2)  // VLLS Control Register
          #define SMC_VLLSCTRL_VLLSM_VLLS0 0x00                          // VLLS mode control - VLLS0
          #define SMC_VLLSCTRL_VLLSM_VLLS1 0x01                          // VLLS mode control - VLLS1
          #define SMC_VLLSCTRL_VLLSM_VLLS2 0x02                          // VLLS mode control - VLLS2
          #define SMC_VLLSCTRL_VLLSM_VLLS3 0x03                          // VLLS mode control - VLLS3
          #define SMC_VLLSCTRL_PORPO       0x20                          // disable POR detect circuit in VLLS0 mode
    #endif
    #define SMC_PMSTAT       *(volatile unsigned char *)(SMC_BASE_ADD + 0x3) // Power Mode Status Register (read-only)
      #define SMC_PMSTAT_RUN  0x01                                       // current power mode is RUN
      #define SMC_PMSTAT_STOP 0x02                                       // current power mode is STOP
      #define SMC_PMSTAT_VLPR 0x04                                       // current power mode is VLPR
      #define SMC_PMSTAT_VLPW 0x08                                       // current power mode is VLPW
      #define SMC_PMSTAT_VLPS 0x10                                       // current power mode is VLPS
      #define SMC_PMSTAT_LLS  0x20                                       // current power mode is LLS
      #define SMC_PMSTAT_VLLS 0x40                                       // current power mode is VLLS

    // Reset Control Module
    //
    #define RCM_SRS0         *(volatile unsigned char *)(RCM_BASE_ADD + 0x00) // System Reset Status Register 0 (read-only)
      #define RCM_SRS0_WAKEUP 0x01                                       // reset caused by LLWU wakeup source
      #define RCM_SRS0_LVD    0x02                                       // reset caused by low voltage trip or power on reset
      #define RCM_SRS0_LOC    0x04                                       // reset caused by loss of external clock
      #define RCM_SRS0_WDOG   0x20                                       // reset caused by watchdog timeout
      #define RCM_SRS0_PIN    0x40                                       // reset caused by external reset pin
      #define RCM_SRS0_POR    0x80                                       // power on reset
    #define RCM_SRS1         *(volatile unsigned char *)(RCM_BASE_ADD + 0x01) // system reset status register 1 (read-only)
      #define RCM_SRS1_JTAG  0x01                                        // reset caused by JTAG
      #define RCM_SRS1_LOCKUP 0x02                                       // reset caused by core lockup
      #define RCM_SRS1_SW    0x04                                        // reset caused by software
      #define RCM_SRS1_MDM_AP 0x08                                       // reset caused by host debugger reset
      #define RCM_SRS1_EZPT  0x10                                        // reset caused by EZPORT reset command
      #define RCM_SRS1_SACKERR 0x20                                      // reset caused by peripheral failure to acknowledge attempt to enter stop mode
      #define RCM_SRS1_TAMPER 0x80                                       // reset caused by tamper detect
    #define RCM_RPFC         *(unsigned char *)(RCM_BASE_ADD + 0x04)     // system pin filter control register
    #define RCM_RPFW         *(unsigned char *)(RCM_BASE_ADD + 0x05)     // reset pin filter width register
#if defined ROM_BOOTLOADER
    #define RCM_FM           *(unsigned char *)(RCM_BASE_ADD + 0x06)     // force mode register (only reset by power cycle)
      #define RCM_FM_ROM_RCM_MR1  0x02                                   // force boot form ROM with RCM_MR[1] set for subseqeunt resets
      #define RCM_FM_ROM_RCM_MR2  0x04                                   // force boot form ROM with RCM_MR[2] set for subseqeunt resets
#endif
    #define RCM_MR           *(volatile unsigned char *)(RCM_BASE_ADD + 0x07) // mode register (read-only)
      #if defined ROM_BOOTLOADER
          #define RCM_MR_BOOTROM_BOOT_FROM_FLASH               0x00      // the last reset was a boot from flash
          #define RCM_MR_BOOTROM_BOOT_FROM_ROM_BOOTCFG0        0x02      // the last reset was a boot from ROM due to BOOTCFG0 assertion
          #define RCM_MR_BOOTROM_BOOT_FROM_ROM_FOPT7           0x04      // the last reset was a boot from ROM due to FOPT[7] configuration
      #endif
#elif !defined KINETIS_KE && !defined KINETIS_KEA
    // Mode Control
    //
    #define MC_SRSH              *(volatile unsigned char *)(MC_BASE_ADD + 0x0) // System Reset Status Register High
      #define MC_SRSH_JTAG       0x01
      #define MC_SRSH_LOCKUP     0x02
      #define MC_SRSH_SW         0x04
    #define MC_SRSL              *(volatile unsigned char *)(MC_BASE_ADD + 0x1) // System Reset Status Register Low
      #define MC_SRSL_WAKEUP     0x01
      #define MC_SRSL_LVD        0x02
      #define MC_SRSL_LOC        0x04
      #define MC_SRSL_COP        0x20
      #define MC_SRSL_PIN        0x40
      #define MC_SRSL_POR        0x80
    #define MC_PMPROT            *(volatile unsigned char *)(MC_BASE_ADD + 0x2) // Power Mode Protection Register (write once register)
      #define MC_PMPROT_AVLLS1   0x01
      #define MC_PMPROT_AVLLS2   0x02
      #define MC_PMPROT_AVLLS3   0x04
      #define MC_PMPROT_ALLS     0x10
      #define MC_PMPROT_AVLP     0x20
    #define MC_PMCTRL            *(unsigned char *)(MC_BASE_ADD + 0x3)   // Power Mode Control Register
      #define MC_PMCTRL_LPLLSM_NORMAL_STOP 0x00
      #define MC_PMCTRL_LPLLSM_VLPS        0x02
      #define MC_PMCTRL_LPLLSM_LLS         0x03
      #define MC_PMCTRL_LPLLSM_VLLS3       0x05
      #define MC_PMCTRL_LPLLSM_VLLS2       0x06
      #define MC_PMCTRL_LPLLSM_VLLS1       0x07
      #define MC_PMCTRL_RUNM_NORMAL_RUN    0x00
      #define MC_PMCTRL_RUNM_VLP_RUN       0x20
      #define MC_PMCTRL_LPWUI              0x80
#endif


// Low Power Options and modes
//
#define LP_DISABLE_POR_IN_VLLS0   0x20                                   // not KE devices
#define LP_PARTIAL_STOP_1         0x40                                   // both system and bus clocks disabled in stop mode (KL devices only)
#define LP_PARTIAL_STOP_2         0x80                                   // system clock disabled in stop mode but bus clock enabled (KL devices only)

#define LOW_POWER_OPTIONS         (LP_DISABLE_POR_IN_VLLS0 | LP_PARTIAL_STOP_1 | LP_PARTIAL_STOP_2)

#define RUN_MODE                      0                                  // no low power operation (normal run)
#define WAIT_MODE                     1                                  // automatic wait mode operation (normal wait)
#define STOP_MODE                     2                                  // automatic stop mode operation (normal stop)
#if defined KINETIS_KE
    #define MAX_LP_MODES          STOP_MODE                              // lowest power mode for KE devices
#else
    #if defined KINETIS_K22
        #define VLPR_MODE             3                                  // very low power run
        #define VLPW_MODE             4                                  // very low power wait
        #define VLPS_MODE             5                                  // very low power stop
        #define LLS2_MODE             6                                  // low leakage stop 2
        #define LLS3_MODE             7                                  // low leakage stop 2
        #define VLLS0_MODE            8                                  // very low leakage stop 0
        #define VLLS1_MODE            9                                  // very low leakage stop 1
        #define VLLS2_MODE            10                                 // very low leakage stop 1
        #define VLLS3_MODE            11                                 // very low leakage stop 3
        #define LOW_LEAKAGE_MODES     LLS2_MODE
    #elif defined KINETIS_KL27
        #define VLPR_MODE             3                                  // very low power run
        #define VLPW_MODE             4                                  // very low power wait
        #define VLPS_MODE             5                                  // very low power stop
        #define LLS_MODE              6                                  // low leakage stop
        #define VLLS0_MODE            7                                  // very low leakage stop 0
        #define VLLS1_MODE            8                                  // very low leakage stop 1
        #define VLLS3_MODE            9                                  // very low leakage stop 3
        #define LOW_LEAKAGE_MODES     LLS_MODE
    #elif defined KINETIS_KL03
        #define PSTOP1_MODE           3                                  // additional low power modes for KL3 devices (partial stop 1)
        #define PSTOP2_MODE           4                                  // partial stop 2
        #define VLPR_MODE             5                                  // very low power run
        #define VLPW_MODE             6                                  // very low power wait
        #define VLPS_MODE             7                                  // very low power stop
        #define VLLS0_MODE            8                                  // very low leakage stop 0
        #define VLLS1_MODE            9                                  // very low leakage stop 1
        #define VLLS3_MODE            10                                 // very low leakage stop 3
        #define LOW_LEAKAGE_MODES     VLLS0_MODE
    #else
        #define VLPR_MODE             3                                  // additional low power modes for K and KL devices (very low power run)
        #define VLPS_MODE             4                                  // very low power stop
        #define LLS_MODE              5                                  // low leakage stop
        #define VLLS0_MODE            6                                  // very low leakage stop 0
        #define VLLS1_MODE            7                                  // very low leakage stop 1
        #if defined KINETIS_KL
            #define VLLS3_MODE        8                                  // very low leakage stop 3
        #else
            #define VLLS2_MODE        8                                  // very low leakage stop 2
            #define VLLS3_MODE        9                                  // very low leakage stop 3
        #endif
        #define LOW_LEAKAGE_MODES     LLS_MODE
    #endif
    #define MAX_LP_MODES              VLLS3_MODE                         // lowest power mode for KL and K devices
#endif


// Random number generator
//
#if !defined RANDOM_NUMBER_GENERATOR_B                                   // {41}{43}
    #define RNG_CR               *(volatile unsigned long *)(RNGA_BASE_ADD + 0x00) // RNGA Control Register
      #define RNG_CR_GO          0x00000001                              // output register is loaded with random data
      #define RNG_CR_HA          0x00000002                              // high assurance
      #define RNG_CR_INTM        0x00000004                              // interrupt mask
      #define RNG_CR_CLRI        0x00000008                              // clear interrupt - reads 0
      #define RNG_CR_SLP         0x00000010                              // sleep
    #define RNG_SR               *(volatile unsigned long *)(RNGA_BASE_ADD + 0x04) // RNGA Status Register (read-only)
      #define RNG_SR_SECV        0x00000001                              // security violation
      #define RNG_SR_LRS         0x00000002                              // lasr read status
      #define RNG_SR_ORU         0x00000004                              // output register underflow
      #define RNG_SR_ERRI        0x00000008                              // error interrupt
      #define RNG_SR_SLP         0x00000010                              // RNGA is in sleep mode
      #define RNG_SR_OREG_LVL    0x00000100                              // output register level
      #define RNG_SR_OREG_SIZE   0x00010000                              // output register size
    #define RNG_ER               *(volatile unsigned long *)(RNGA_BASE_ADD + 0x08) // RNGA Entropy Register (always reads 0)
    #define RNG_OR               *(volatile unsigned long *)(RNGA_BASE_ADD + 0x0c) // RNGA Output Register (read-only)
#else
    #define RNG_VER              *(volatile unsigned long *)(RNGB_BASE_ADD + 0x00) // RNGB Version ID Register (read-only)
      #define RNG_VER_RNGB       0x10000000
    #define RNG_CMD              *(volatile unsigned long *)(RNGB_BASE_ADD + 0x04) // RNGB Command Register
      #define RNG_CMD_ST         0x00000001                              // self-test mode (self-clearing)
      #define RNG_CMD_GS         0x00000002                              // generate seed mode (self-clearing)
      #define RNG_CMD_CI         0x00000010                              // clear interrupt (self-clearing)
      #define RNG_CMD_CE         0x00000020                              // clear error (self-clearing)
      #define RNG_CMD_SR         0x00000040                              // software reset (self-clearing)
    #define RNG_CR               *(volatile unsigned long *)(RNGB_BASE_ADD + 0x08) // RNGB Control Register
      #define RNG_CR_FUFMODE_ZEROS 0x00000000                            // return all zeros and set FUFE in RNG_ESR on FIFO underflow
      #define RNG_CR_FUFMODE_TE  0x00000002                              // generate bus transfer error on FIFO underflow
      #define RNG_CR_FUFMODE_INT 0x00000003                              // generate interrupt and return all zeros on FIFO underflow (override MASKERR in RNG_CR)
      #define RNG_CR_AR          0x00000010                              // enable automatic re-seeding
      #define RNG_CR_MASKDONE    0x00000020                              // mask done interrupt
      #define RNG_CR_MASKERR     0x00000040                              // mask applied to error interrupt
    #define RNG_SR               *(volatile unsigned long *)(RNGB_BASE_ADD + 0x0c) // RNGB Status Register (read-only)
      #define RNG_SR_STATPF_LONG_RUN 0x80000000
      #define RNG_SR_STATPF_RUN_6    0x40000000
      #define RNG_SR_STATPF_RUN_5    0x20000000
      #define RNG_SR_STATPF_RUN_4    0x10000000
      #define RNG_SR_STATPF_RUN_3    0x08000000
      #define RNG_SR_STATPF_RUN_2    0x04000000
      #define RNG_SR_STATPF_RUN_1    0x02000000
      #define RNG_SR_STATPF_MONO_BIT 0x01000000
      #define RNG_SR_PF_TRNG     0x00800000
      #define RNG_SR_PF_PRNG     0x00400000
      #define RNG_SR_ERR         0x00010000
      #define RNG_SR_FIFO_SIZE_5 0x00005000
      #define RNG_SR_FIFO_LVL_MASK   0x00000f00
      #define RNG_SR_NSDN        0x00000040                              // new seed done
      #define RNG_SR_SDN         0x00000020                              // seed done
      #define RNG_SR_TSDN        0x00000010                              // self test done
      #define RNG_SR_RS          0x00000008                              // reseed needed
      #define RNG_SR_SLP         0x00000004                              // RNGB is in sleep mode
      #define RNG_SR_BUSY        0x00000002                              // RNGB is busy
    #define RNG_ESR              *(volatile unsigned long *)(RNGB_BASE_ADD + 0x10) // RNGB Error Status Register (read-only)
      #define RNG_ESR_FUFE       0x00000010                              // FIFO underflow has occurred
      #define RNG_ESR_SATE       0x00000008                              // statistical test error
      #define RNG_ESR_STE        0x00000004                              // self test error
      #define RNG_ESR_OSCE       0x00000002                              // RNG oscillator error
      #define RNG_ESR_LFE        0x00000001                              // LFSR (linear feedback shioft register) failure
    #define RNG_OUT              *(volatile unsigned long *)(RNGB_BASE_ADD + 0x14) // RNGB Output FIFO Register (read-only)
#endif

// Segment LCD Controller
//
#define LCD_GCR              *(volatile unsigned long *)(SLCD_BASE_ADD + 0x00) // LCD General Control Register
  #define LCD_GCR_DUTY_1BP   0x00000000                                  // LCD duty 1/1 duty cycle
  #define LCD_GCR_DUTY_2BP   0x00000001                                  // LCD duty 1/2 duty cycle
  #define LCD_GCR_DUTY_3BP   0x00000002                                  // LCD duty 1/3 duty cycle
  #define LCD_GCR_DUTY_4BP   0x00000003                                  // LCD duty 1/4 duty cycle
  #define LCD_GCR_DUTY_5BP   0x00000004                                  // LCD duty 1/5 duty cycle
  #define LCD_GCR_DUTY_6BP   0x00000005                                  // LCD duty 1/6 duty cycle
  #define LCD_GCR_DUTY_7BP   0x00000006                                  // LCD duty 1/7 duty cycle
  #define LCD_GCR_DUTY_8BP   0x00000007                                  // LCD duty 1/8 duty cycle
  #define LCD_GCR_LCLK_0     0x00000000                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_1     0x00000008                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_2     0x00000010                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_3     0x00000018                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_4     0x00000020                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_5     0x00000028                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_6     0x00000030                                  // LCD clock prescaler - factor
  #define LCD_GCR_LCLK_7     0x00000038                                  // LCD clock prescaler - factor
  #define LCD_GCR_SOURCE     0x00000040                                  // select alternative clock source rather than default source
  #define LCD_GCR_LCDEN      0x00000080                                  // enable SLCD operation
  #define LCD_GCR_LCDSTP     0x00000100                                  // disable SLCD operation when CPU is in stop mode
  #define LCD_GCR_LCDWAIT    0x00000200                                  // disable SLCD operation when CPU is in wait mode
  #define LCD_GCR_ALTDIV_NONE 0x00000000                                 // LCD alternative clock divider - no divide
  #if defined KINETIS_KL43
    #define LCD_GCR_ALTDIV_64  0x00001000                                // LCD alternative clock divider factor 64
    #define LCD_GCR_ALTDIV_256 0x00002000                                // LCD alternative clock divider factor 256
  #else
    #define LCD_GCR_ALTDIV_8   0x00001000                                // LCD alternative clock divider factor 8
    #define LCD_GCR_ALTDIV_64  0x00002000                                // LCD alternative clock divider factor 64
  #endif
  #define LCD_GCR_ALTDIV_512 0x00003000                                  // LCD alternative clock divider factor 512
  #define LCD_GCR_FDCIEN     0x00004000                                  // LCD fault detect complete interrupt enable
  #define LCD_GCR_LCDIEN     0x00008000                                  // LCD frame frequency interrupt enable (LCDIF bit causes interrupt)
  #if defined KINETIS_KL
      #define LCD_GCR_VSUPPLY  0x00020000
  #else
      #define LCD_GCR_VSUPPLY_VLL2 0x00000000                            // drive VLL2 internally from VDD
      #define LCD_GCR_VSUPPLY_VLL3 0x00010000                            // drive VLL3 internally from VDD
      #define LCD_GCR_VSUPPLY_VLL3_EXT 0x00030000                        // drive VLL3 externally from VDD or drive VLL1 internally from VIREG
  #endif
  #define LCD_GCR_LADJ_MASK  0x00300000
  #define LCD_GCR_HREFSEL    0x00400000                                  // high reference select VIREG 1.67V for 5V glass (other than 1.0V for 3V glass)
  #define LCD_GCR_CPSEL      0x00800000                                  // select charge pump rather than resistor network
  #define LCD_GCR_RVTRIM_MASK 0x0f000000                                 // regulated voltage trim - regulated input is changed by 1.5% for each count
  #define LCD_GCR_RVEN       0x80000000                                  // regulated voltage enable (must have charge pump enabled)
#define LCD_AR               *(volatile unsigned long *)(SLCD_BASE_ADD + 0x04) // LCD Auxilliary Register
  #define LCD_AR_BRATE_MASK  0x00000007                                  // blink rate configuration mask
  #define LCD_AR_BMODE       0x00000008                                  // blink mode
  #define LCD_AR_BLANK       0x00000020                                  // blank display mode
  #define LCD_AR_ALT         0x00000040                                  // alternate display mode
  #define LCD_AR_BLINK       0x00000080                                  // blink at blinking frequency specified by LCD blink rate calculation
 #if !defined KINETIS_KL
  #define LCD_AR_LCDIF       0x00008000                                  // frame frequency interrupt flag - write '1' to clear
 #endif
#define LCD_FDCR             *(unsigned long *)(SLCD_BASE_ADD + 0x08)    // LCD Fault Detect Control Register
#define LCD_FDSR             *(volatile unsigned long *)(SLCD_BASE_ADD + 0x0c) // LCD Fault Detect Status Register
#define LCD_PENL             *(unsigned long *)(SLCD_BASE_ADD + 0x10)    // LCD Pin Enable Register - low
#define LCD_PENH             *(unsigned long *)(SLCD_BASE_ADD + 0x14)    // LCD Pin Enable Register - high
#define LCD_BPENL            *(unsigned long *)(SLCD_BASE_ADD + 0x18)    // LCD Backplane Enable Register - low
#define LCD_BPENH            *(unsigned long *)(SLCD_BASE_ADD + 0x1c)    // LCD Backplane Enable Register - high
#define LCD_WF3TO0_ADDR      (unsigned long *)(SLCD_BASE_ADD + 0x20)     // LCD Waveform Register (3 to 0) address
#define LCD_WF3TO0           *(volatile unsigned long *)(SLCD_BASE_ADD + 0x20) // LCD Waveform Register (3 to 0)
    #define LCD_WF0          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x20) // LCD Waveform Register 0 (for byte accesses)
    #define LCD_WF1          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x21) // LCD Waveform Register 1 (for byte accesses)
    #define LCD_WF2          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x22) // LCD Waveform Register 2 (for byte accesses)
    #define LCD_WF3          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x23) // LCD Waveform Register 3 (for byte accesses)
#define LCD_WF7TO4           *(volatile unsigned long *)(SLCD_BASE_ADD + 0x24) // LCD Waveform Register (7 to 4)
    #define LCD_WF4          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x24) // LCD Waveform Register 4 (for byte accesses)
    #define LCD_WF5          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x25) // LCD Waveform Register 5 (for byte accesses)
    #define LCD_WF6          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x26) // LCD Waveform Register 6 (for byte accesses)
    #define LCD_WF7          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x27) // LCD Waveform Register 7 (for byte accesses)
#define LCD_WF11TO8          *(volatile unsigned long *)(SLCD_BASE_ADD + 0x28) // LCD Waveform Register (11 to 8)
    #define LCD_WF8          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x28) // LCD Waveform Register 8 (for byte accesses)
    #define LCD_WF9          *(volatile unsigned char *)(SLCD_BASE_ADD + 0x29) // LCD Waveform Register 9 (for byte accesses)
    #define LCD_WF10         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x2a) // LCD Waveform Register 10 (for byte accesses)
    #define LCD_WF11         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x2b) // LCD Waveform Register 11 (for byte accesses)
#define LCD_WF15TO12         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x2c) // LCD Waveform Register (15 to 12)
    #define LCD_WF12         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x2c) // LCD Waveform Register 12 (for byte accesses)
    #define LCD_WF13         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x2d) // LCD Waveform Register 13 (for byte accesses)
    #define LCD_WF14         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x2e) // LCD Waveform Register 14 (for byte accesses)
    #define LCD_WF15         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x2f) // LCD Waveform Register 15 (for byte accesses)
#define LCD_WF19TO16         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x30) // LCD Waveform Register (19 to 16)
    #define LCD_WF16         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x30) // LCD Waveform Register 16 (for byte accesses)
    #define LCD_WF17         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x31) // LCD Waveform Register 17 (for byte accesses)
    #define LCD_WF18         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x32) // LCD Waveform Register 18 (for byte accesses)
    #define LCD_WF19         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x33) // LCD Waveform Register 19 (for byte accesses)
#define LCD_WF23TO20         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x34) // LCD Waveform Register (23 to 20)
    #define LCD_WF20         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x34) // LCD Waveform Register 20 (for byte accesses)
    #define LCD_WF21         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x35) // LCD Waveform Register 21 (for byte accesses)
    #define LCD_WF22         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x36) // LCD Waveform Register 22 (for byte accesses)
    #define LCD_WF23         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x37) // LCD Waveform Register 23 (for byte accesses)
#define LCD_WF27TO24         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x38) // LCD Waveform Register (27 to 24)
    #define LCD_WF24         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x38) // LCD Waveform Register 24 (for byte accesses)
    #define LCD_WF25         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x39) // LCD Waveform Register 25 (for byte accesses)
    #define LCD_WF26         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x3a) // LCD Waveform Register 26 (for byte accesses)
    #define LCD_WF27         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x3b) // LCD Waveform Register 27 (for byte accesses)
#define LCD_WF31TO28         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x3c) // LCD Waveform Register (31 to 28)
    #define LCD_WF28         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x3c) // LCD Waveform Register 28 (for byte accesses)
    #define LCD_WF29         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x3d) // LCD Waveform Register 29 (for byte accesses)
    #define LCD_WF30         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x3e) // LCD Waveform Register 30 (for byte accesses)
    #define LCD_WF31         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x3f) // LCD Waveform Register 31 (for byte accesses)
#define LCD_WF35TO32         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x40) // LCD Waveform Register (35 to 32)
    #define LCD_WF32         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x40) // LCD Waveform Register 32 (for byte accesses)
    #define LCD_WF33         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x41) // LCD Waveform Register 33 (for byte accesses)
    #define LCD_WF34         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x42) // LCD Waveform Register 34 (for byte accesses)
    #define LCD_WF35         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x43) // LCD Waveform Register 35 (for byte accesses)
#define LCD_WF39TO36         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x44) // LCD Waveform Register (39 to 36)
    #define LCD_WF36         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x44) // LCD Waveform Register 36 (for byte accesses)
    #define LCD_WF37         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x45) // LCD Waveform Register 37 (for byte accesses)
    #define LCD_WF38         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x46) // LCD Waveform Register 38 (for byte accesses)
    #define LCD_WF39         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x47) // LCD Waveform Register 39 (for byte accesses)
#define LCD_WF43TO40         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x48) // LCD Waveform Register (43 to 40)
    #define LCD_WF40         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x48) // LCD Waveform Register 40 (for byte accesses)
    #define LCD_WF41         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x49) // LCD Waveform Register 41 (for byte accesses)
    #define LCD_WF42         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x4a) // LCD Waveform Register 42 (for byte accesses)
    #define LCD_WF43         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x4b) // LCD Waveform Register 43 (for byte accesses)
#define LCD_WF47TO44         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x4c) // LCD Waveform Register (47 to 44)
    #define LCD_WF44         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x4c) // LCD Waveform Register 44 (for byte accesses)
    #define LCD_WF45         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x4d) // LCD Waveform Register 45 (for byte accesses)
    #define LCD_WF46         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x4e) // LCD Waveform Register 46 (for byte accesses)
    #define LCD_WF47         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x4f) // LCD Waveform Register 47 (for byte accesses)
#define LCD_WF51TO48         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x50) // LCD Waveform Register (51 to 48)
    #define LCD_WF48         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x50) // LCD Waveform Register 48 (for byte accesses)
    #define LCD_WF49         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x51) // LCD Waveform Register 49 (for byte accesses)
    #define LCD_WF50         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x52) // LCD Waveform Register 50 (for byte accesses)
    #define LCD_WF51         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x53) // LCD Waveform Register 51 (for byte accesses)
#define LCD_WF55TO52         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x54) // LCD Waveform Register (55 to 52)
    #define LCD_WF52         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x54) // LCD Waveform Register 52 (for byte accesses)
    #define LCD_WF53         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x55) // LCD Waveform Register 53 (for byte accesses)
    #define LCD_WF54         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x56) // LCD Waveform Register 54 (for byte accesses)
    #define LCD_WF55         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x57) // LCD Waveform Register 55 (for byte accesses)
#define LCD_WF59TO56         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x58) // LCD Waveform Register (59 to 56)
    #define LCD_WF56         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x58) // LCD Waveform Register 56 (for byte accesses)
    #define LCD_WF57         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x59) // LCD Waveform Register 57 (for byte accesses)
    #define LCD_WF58         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x5a) // LCD Waveform Register 58 (for byte accesses)
    #define LCD_WF59         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x5b) // LCD Waveform Register 59 (for byte accesses)
#define LCD_WF63TO60         *(volatile unsigned long *)(SLCD_BASE_ADD + 0x5c) // LCD Waveform Register (63 to 60)
    #define LCD_WF60         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x5c) // LCD Waveform Register 60 (for byte accesses)
    #define LCD_WF61         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x5d) // LCD Waveform Register 61 (for byte accesses)
    #define LCD_WF62         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x5e) // LCD Waveform Register 62 (for byte accesses)
    #define LCD_WF63         *(volatile unsigned char *)(SLCD_BASE_ADD + 0x5f) // LCD Waveform Register 63 (for byte accesses)

#define SLCD_PIN_0           0x00000001
#define SLCD_PIN_1           0x00000002
#define SLCD_PIN_2           0x00000004
#define SLCD_PIN_3           0x00000008
#define SLCD_PIN_4           0x00000010
#define SLCD_PIN_5           0x00000020
#define SLCD_PIN_6           0x00000040
#define SLCD_PIN_7           0x00000080
#define SLCD_PIN_8           0x00000100
#define SLCD_PIN_9           0x00000200
#define SLCD_PIN_10          0x00000400
#define SLCD_PIN_11          0x00000800
#define SLCD_PIN_12          0x00001000
#define SLCD_PIN_13          0x00002000
#define SLCD_PIN_14          0x00004000
#define SLCD_PIN_15          0x00008000
#define SLCD_PIN_16          0x00010000
#define SLCD_PIN_17          0x00020000
#define SLCD_PIN_18          0x00040000
#define SLCD_PIN_19          0x00080000
#define SLCD_PIN_20          0x00100000
#define SLCD_PIN_21          0x00200000
#define SLCD_PIN_22          0x00400000
#define SLCD_PIN_23          0x00800000
#define SLCD_PIN_24          0x01000000
#define SLCD_PIN_25          0x02000000
#define SLCD_PIN_26          0x04000000
#define SLCD_PIN_27          0x08000000
#define SLCD_PIN_28          0x10000000
#define SLCD_PIN_29          0x20000000
#define SLCD_PIN_30          0x40000000
#define SLCD_PIN_31          0x80000000

#define SLCD_PIN_H_32        0x00000001
#define SLCD_PIN_H_33        0x00000002
#define SLCD_PIN_H_34        0x00000004
#define SLCD_PIN_H_35        0x00000008
#define SLCD_PIN_H_36        0x00000010
#define SLCD_PIN_H_37        0x00000020
#define SLCD_PIN_H_38        0x00000040
#define SLCD_PIN_H_39        0x00000080
#define SLCD_PIN_H_40        0x00000100
#define SLCD_PIN_H_41        0x00000200
#define SLCD_PIN_H_42        0x00000400
#define SLCD_PIN_H_43        0x00000800
#define SLCD_PIN_H_44        0x00001000
#define SLCD_PIN_H_45        0x00002000
#define SLCD_PIN_H_46        0x00004000
#define SLCD_PIN_H_47        0x00008000
#define SLCD_PIN_H_48        0x00010000
#define SLCD_PIN_H_49        0x00020000
#define SLCD_PIN_H_50        0x00040000
#define SLCD_PIN_H_51        0x00080000
#define SLCD_PIN_H_52        0x00100000
#define SLCD_PIN_H_53        0x00200000
#define SLCD_PIN_H_54        0x00400000
#define SLCD_PIN_H_55        0x00800000
#define SLCD_PIN_H_56        0x01000000
#define SLCD_PIN_H_57        0x02000000
#define SLCD_PIN_H_58        0x04000000
#define SLCD_PIN_H_59        0x08000000
#define SLCD_PIN_H_60        0x10000000
#define SLCD_PIN_H_61        0x20000000
#define SLCD_PIN_H_62        0x40000000
#define SLCD_PIN_H_63        0x80000000


#define SEGMENT_REGISTER_COUNT 16

#if defined _WINDOWS
    #define WRITE_SLCD(reg, val)   LCD_WF##reg = (val);         fnSimulateSLCD()
    #define SET_SLCD(reg, val)     LCD_WF##reg |= (val);        fnSimulateSLCD()
    #define CLEAR_SLCD(reg, val)   LCD_WF##reg &= ~(val);       fnSimulateSLCD()
    #define TOGGLE_SLCD(reg, val)  LCD_WF##reg ^= (val);        fnSimulateSLCD()
#else
    #define WRITE_SLCD(reg, val)   LCD_WF##reg = (val)
    #define SET_SLCD(reg, val)     LCD_WF##reg |= (val)
    #define CLEAR_SLCD(reg, val)   LCD_WF##reg &= ~(val)
    #define TOGGLE_SLCD(reg, val)  LCD_WF##reg ^= (val)
#endif

// Fast Ethernet Controller
//
#define EIR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0x4) // Ethernet Interrupt Event Register
#define EIMR                 *(unsigned long *)(EMAC_BASE_ADD + 0x8)     // Ethernet Interrupt Mask Register
  #define HBERR              0x80000000                                  // Heart beat error interrupt/mask
  #define BABR               0x40000000                                  // Babbling receive error interrupt/mask
  #define BABT               0x20000000                                  // Babbling transmit error interrupt/mask
  #define GRA                0x10000000                                  // Graceful Stop Complete interrupt/mask
  #define TXF                0x08000000                                  // Transmit Frame interrupt/mask
  #define TXB                0x04000000                                  // Transmit Buffer interrupt/mask
  #define RXF                0x02000000                                  // Receive Frame interrupt/mask
  #define RXB                0x01000000                                  // Receive Buffer interrupt/mask
  #define MII                0x00800000                                  // MII interrupt/mask
  #define EBERR              0x00400000                                  // Ethernet Bus Error interrupt/mask
  #define LC                 0x00200000                                  // Late Collision interrupt/mask
  #define RL                 0x00100000                                  // Collision Retry Limit interrupt/mask
  #define UN                 0x00080000                                  // Transmit FIFO Underrun
  #define EIMR_PLR           0x00040000                                  // payload receive error
  #define EIMR_WAKEUP        0x00020000                                  // node wakeup request indication
  #define EIMR_TS_AVAIL      0x00010000                                  // transmit timestamp available
  #define EIMR_TS_TIMER      0x00008000                                  // timestamp timer
#define RDAR                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x10) // Receive Descriptor Active Register
#define TDAR                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x14) // Transmit Descriptor Active Register
  #define TDAR_TDAR          0x00000000                                  // 0x01000000 but any value written is adequate
#define ECR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0x24) // Ethernet Control Register
  #define RESET_FEC          0x00000001                                  // issue MAC reset (self-clearing)
  #define ETHER_EN           0x00000002                                  // enable Ethernet operation
  #define ETHER_MAGICEN      0x00000004                                  // enable magic package detection
  #define ETHER_SLEEP        0x00000008                                  // enable sleep mode
  #define ETHER_EN1588       0x00000010                                  // enable enhanced functionality
  #define ETHER_DBGEN        0x00000040                                  // enter freeze mode when debugging
  #define ETHER_STOPEN       0x00000080                                  // enabled in doze mode
#if defined KINETIS_K61 || defined KINETIS_K64 || defined KINETIS_K65 || defined KINETIS_K66 || defined KINETIS_K70 // {15}{78}
  #define ETHER_DBSWP        0x00000100                                  // enable descriptor byte swapping to support little-endian devices
#endif
#define MMFR                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x40) // MII Data Register
  #define MII_TA             0x00020000
  #define MII_ST             0x40000000
  #define WRITE_OP           0x10000000
  #define READ_OP            0x20000000

  #define MII_WRITE (MII_TA | MII_ST | WRITE_OP)
  #define MII_READ  (MII_TA | MII_ST | READ_OP)
#define MSCR                 *(unsigned long *)(EMAC_BASE_ADD + 0x44)    // MII Speed Control Register
  #define DIS_PREAMBLE       0x00000080
  #define MII_SPEED_60MHZ    (0xd  << 1)                                 // Correct setting for 60MHz system
#define MIBC                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x64) // MII Control/Status Register
  #define MIB_DISABLE        0x80000000
  #define MIB_IDLE           0x40000000
  #define MIB_CLEAR          0x20000000
#define RCR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0x84) // Receive Control Register
  #define RCR_GRS            0x80000000                                  // graceful receive stopped (read-only)
  #define RCR_NLC            0x40000000                                  // payload length check
  #define MAX_FRAME_LENGTH   0x05ee0000                                  // 1518 bytes
  #define RCR_CFEN           0x00008000                                  // mac control frames enable
  #define CRCFWD             0x00004000                                  // {9} strip CRC from frame and don't pass to user
  #define PAUFWD             0x00004000                                  // {9} forward pause frames to application
  #define PADEN              0x00001000                                  // {9} remove padding from received frames (disables CRCFWD)
  #define RMII_10T           0x00000200                                  // 10 base T in RMII 
  #define RMII_MODE          0x00000100                                  // RMII mode
  #define FCE                0x00000020                                  // Pause flow control
  #define BC_REJ             0x00000010                                  // Reject Broadcast
  #define PROM               0x00000008                                  // Promiscuous
  #define FEC_MII_MODE       0x00000004                                  // MII mode
  #define DRT                0x00000002                                  // Half duplex
  #define LOOP               0x00000001                                  // Loopback  
#define TCR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0xc4) // {10} Transmit Control Register
  #define FDEN               0x00000004                                  // Full duplex
#define PALR                 *(unsigned long *)(EMAC_BASE_ADD + 0xe4)    // Physical Address Low Register
#define PAUR                 *(unsigned long *)(EMAC_BASE_ADD + 0xe8)    // Physical Address High and Type Field Register
#define OPD                  *(unsigned long *)(EMAC_BASE_ADD + 0xec)    // Op-code and Pause Duration
  #define PAUSE_DURATION     0x00000001
#define IAUR                 *(unsigned long *)(EMAC_BASE_ADD + 0x118)   // Hash table upper 32 bits
#define IALR                 *(unsigned long *)(EMAC_BASE_ADD + 0x11c)   // Hash table lower 32 bits
#define GAUR                 *(unsigned long *)(EMAC_BASE_ADD + 0x120)   // Group Hash table upper 32 bits
#define GALR                 *(unsigned long *)(EMAC_BASE_ADD + 0x124)   // Group Hash table lower 32 bits
#define ENET_TFWR            *(unsigned long *)(EMAC_BASE_ADD + 0x144)   // Transmit FIFO Watermark
  #define TFWR_TFWR_64       0x00000000                                  // transmission starts when 64 bytes have been written
  #define TFWR_TFWR_128      0x00000002                                  // transmission starts when 128 bytes have been written (or frame complete)
  #define TFWR_TFWR_192      0x00000003                                  // transmission starts when 192 bytes have been written (or frame complete)
  #define TFWR_TFWR_4032     0x0000003f                                  // transmission starts when 4032 bytes have been written (or frame complete)
  #define TFWR_STRFWD        0x00000100                                  // store and forward enable
#define ERDSR                *(unsigned long *)(EMAC_BASE_ADD + 0x180)   // Pointer to Receive Descriptor Ring
#define ETDSR                *(unsigned long *)(EMAC_BASE_ADD + 0x184)   // Pointer to Transmit Descriptor Ring
#define EMRBR                *(unsigned long *)(EMAC_BASE_ADD + 0x188)   // Maximum Receive Buffer Size

#define ENET_RSFL            *(unsigned long *)(EMAC_BASE_ADD + 0x190)   // Receive FIFO Section Full Threshold
#define ENET_RSEM            *(unsigned long *)(EMAC_BASE_ADD + 0x194)   // Receive FIFO Section Empty Threshold
#define ENET_RAEM            *(unsigned long *)(EMAC_BASE_ADD + 0x198)   // Receive FIFO Almost Empty Threshold
#define ENET_RAFL            *(unsigned long *)(EMAC_BASE_ADD + 0x19c)   // Receive FIFO Almost Full Threshold
#define ENET_TSEM            *(unsigned long *)(EMAC_BASE_ADD + 0x1a0)   // Transmit FIFO Section Empty Threshold
#define ENET_TAEM            *(unsigned long *)(EMAC_BASE_ADD + 0x1a4)   // Transmit FIFO Almost Empty Threshold
#define ENET_TAFL            *(unsigned long *)(EMAC_BASE_ADD + 0x1a8)   // Transmit FIFO Almost Full Threshold
#define ENET_TIPG            *(unsigned long *)(EMAC_BASE_ADD + 0x1ac)   // Transmit Inter-Packet Gap
#define ENET_FTRL            *(unsigned long *)(EMAC_BASE_ADD + 0x1b0)   // Transmit Truncation Length

#define ENET_TACC            *(unsigned long *)(EMAC_BASE_ADD + 0x1c0)   // Transmit Accelerator Function Configuration
  #define TACC_SHIFT16       0x00000001                                  // insert 16 bit shift to align frames to 32 bit boundaries
  #define TACC_IPCHK         0x00000008                                  // enables insertion of IP header checksum
  #define TACC_PROCHK        0x00000010                                  // enables insertion of protocol checksum
#define ENET_RACC            *(unsigned long *)(EMAC_BASE_ADD + 0x1c4)   // Receive Accelerator Function Configuration
  #define RACC_PADREM        0x00000001                                  // enable padding removal for short reception frames
  #define RACC_IPDIS         0x00000002                                  // enable discard of received frames with bad IP checksums
  #define RACC_PRODIS        0x00000004                                  // enable discard of received frames with bad protocol checksums
  #define RACC_LINEDIS       0x00000040                                  // enable discard of received frames with MAC errors
  #define RACC_SHIFT16       0x00000080                                  // insert 16 bit shift to align frames to 32 bit boundaries

#define MIBRAM_ADD           (unsigned long *)(EMAC_BASE_ADD + 0x200)
#define MIB_RAM_SIZE         512

#define RMON_T_DROP          MIBRAM_ADD                                  // count of frames not counted correctly
#define RMON_T_PACKETS       *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x04) // count of TX packets
#define RMON_T_BC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x08) // count of TX broadcast packets
#define RMON_T_MC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x0c) // count of TX multicast packets
#define RMON_T_CRC_ALIGN     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x10) // count of TX packets with CRC Align error
#define RMON_T_UNDERSIZE     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x14) // count of TX packets < 64 bytes with good CRC
#define RMON_T_OVERSIZE      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x18) // count of TX packets > MAX_FL bytes with good CRC
#define RMON_T_FRAG          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x1c) // count of TX packets < 64 bytes with bad CRC
#define RMON_T_JAB           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x20) // count of TX packets > MAX_FL bytes with bad CRC
#define RMON_T_COL           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x24) // count of TX collisions
#define RMON_T_P64           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x28) // count of TX 64 byte packets
#define RMON_T_P65TO127      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x2c) // count of TX 65 to 127 byte packets
#define RMON_T_P128TO255     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x30) // count of TX 128 to 255 byte packets
#define RMON_T_P256TO511     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x34) // count of TX 256 to 511 byte packets
#define RMON_T_P512TO1023    *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x38) // count of TX 512 to 1023 byte packets
#define RMON_T_P1024TO2047   *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x3c) // count of TX 1024 to 2047 byte packets
#define RMON_T_P_GTE2048     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x40) // count of TX >2048 byte packets
#define RMON_T_OCTETS        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x44) // count of TX octets
#define IEEE_T_DROP          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x48) // count of TX frame not counted correctly
#define IEEE_T_FRAME_OK      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x4c) // count of TX frames transmitted OK
#define IEEE_T_1COL          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x50) // count of TX frames transmitted with single collision
#define IEEE_T_MCOL          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x54) // count of TX frames transmitted with multiple collision
#define IEEE_T_DEF           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x58) // count of TX frames transmitted after deferral delay
#define IEEE_T_LCOL          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x5c) // count of TX frames transmitted with late collision
#define IEEE_T_EXCOL         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x60) // count of TX frames transmitted with excessive collisions
#define IEEE_T_MACERR        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x64) // count of TX frames transmitted with TX FIFO underrun
#define IEEE_T_CSERR         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x68) // count of TX frames transmitted with carrier sense error
#define IEEE_T_SQE           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x6c) // count of TX frames transmitted with SQE error
#define IEEE_T_FDFXC         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x70) // count of TX flow control pause frames transmitted
#define IEEE_T_OCTETS_OK     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x74) // count of TX octets transmitted without error

#define RMON_R_PACKETS       *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x84) // count of RX packets
#define RMON_R_BC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x88) // count of RX broadcast packets
#define RMON_R_MC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x8c) // count of RX multicast packets
#define RMON_R_CRC_ALIGN     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x90) // count of RX packets with CRC Align error
#define RMON_R_UNDERSIZE     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x94) // count of RX packets < 64 bytes with good CRC
#define RMON_R_OVERSIZE      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x98) // count of RX packets > MAX_FL bytes with good CRC
#define RMON_R_FRAG          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x9c) // count of RX packets < 64 bytes with bad CRC
#define RMON_R_JAB           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xa0) // count of RX packets > MAX_FL bytes with bad CRC
#define RMON_R_P64           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xa8) // count of RX 64 byte packets
#define RMON_R_P65TO127      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xac) // count of RX 65 to 127 byte packets
#define RMON_R_P128TO255     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xb0) // count of RX 128 to 255 byte packets
#define RMON_R_P256TO511     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xb4) // count of RX 256 to 511 byte packets
#define RMON_R_P512TO1023    *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xb8) // count of RX 512 to 1023 byte packets
#define RMON_R_P1024TO2047   *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xbc) // count of RX 1024 to 2047 byte packets
#define RMON_R_P_GTE2048     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xc0) // count of RX >2048 byte packets
#define RMON_R_OCTETS        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xc4) // count of RX octets
#define IEEE_R_DROP          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xc8) // count of RX frame not counted correctly
#define IEEE_R_FRAME_OK      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xcc) // count of RX frames received OK
#define IEEE_R_CRC           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xd0) // count of RX frames received with CRC error
#define IEEE_R_ALIGN         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xd4) // count of RX frames received with alignment error
#define IEEE_R_MACERR        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xd8) // count of RX receive FIFO overflows
#define IEEE_R_FDFXC         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xdc) // count of RX flow control pause frames received
#define IEEE_R_OCTETS_OK     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xe0) // count of RX octets received without error

#define ENET_ATCR            *(unsigned long *)(EMAC_BASE_ADD + 0x400)   // Timer Control Register
#define ENET_ATVR            *(unsigned long *)(EMAC_BASE_ADD + 0x404)   // Timer Value Register
#define ENET_ATOFF           *(unsigned long *)(EMAC_BASE_ADD + 0x408)   // Timer Offset Register
#define ENET_ATPER           *(unsigned long *)(EMAC_BASE_ADD + 0x40c)   // Timer Period Register
#define ENET_ATCOR           *(unsigned long *)(EMAC_BASE_ADD + 0x410)   // Timer Correction Register
#define ENET_ATINC           *(unsigned long *)(EMAC_BASE_ADD + 0x414)   // Time-Stamping Clock Period Register
#define ENET_ATSTMP          *(volatile unsigned long *)(EMAC_BASE_ADD + 0x418) // Timestamp of Last Transmitted Frame (read-only)

#define ENET_TGSR            *(volatile unsigned long *)(EMAC_BASE_ADD + 0x604) // Timer Global Status Register
#define ENET_TCSR0           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x608) // Timer Control Status Register 0
#define ENET_TCCR0           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x60c) // Timer Compare Capture Register 0
#define ENET_TCSR1           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x610) // Timer Control Status Register 1
#define ENET_TCCR1           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x614) // Timer Compare Capture Register 1
#define ENET_TCSR2           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x618) // Timer Control Status Register 2
#define ENET_TCCR2           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x61c) // Timer Compare Capture Register 2
#define ENET_TCSR3           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x620) // Timer Control Status Register 3
#define ENET_TCCR3           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x624) // Timer Compare Capture Register 3


#if defined ETHER_DBSWP                                                  // {15} natural little-endian
    typedef struct stKINETIS_FEC_BD
    {
        volatile unsigned short usBDLength;
        volatile unsigned short usBDControl;
        unsigned char *ptrBD_Data;
    #if defined EMAC_ENHANCED                                            // additional fields available in enhanced mode
        volatile unsigned long  ulBDControlEnhanced;
        volatile unsigned short usPayloadCS;                             // only receiver
        volatile unsigned short usRxInfoHeaderProt;                      // only receiver
        volatile unsigned long  ulBDU;
        volatile unsigned long  ul1588_timestamp;
        unsigned long  ulRes[2];
    #endif
    } KINETIS_FEC_BD;

    #define EMPTY_BUFFER         0x8000                                  // RX BD Control bits
    #define RECEIVE_OWNERSHIP_1  0x4000                                  // can be optionally used by software
    #define WRAP_BIT_RX          0x2000
    #define RECEIVE_OWNERSHIP_2  0x1000                                  // can be optionally used by software
    #define LAST_IN_FRAME_RX     0x0800
    #define RECEIVE_MISS         0x0100                                  // received due to promiscuouse mode only
    #define RECEIVE_BROADCAST    0x0080                                  // received due to broadcast address
    #define RECEIVE_MULTICAST    0x0040                                  // received due to multicast address
    #define RECEIVE_LENGTH_VIOL  0x0020                                  // receive frame length violation
    #define RECEIVE_NON_OCTET_AL 0x0010                                  // non-octet aligned frame
    #define RECEIVE_CRC_ERROR    0x0004                                  // receive CRC or frame error
    #define OVERRUN_FRAME        0x0002
    #define TRUNCATED_FRAME      0x0001

    // Enhanced
    //
    #define RX_MAC_ERROR         0x80000000
    #define RX_PHY_ERROR         0x04000000
    #define RX_COLLISION         0x02000000
    #define RX_UNICAST           0x01000000
    #define RX_GEN_INTERRUPT     0x00800000
    #define RX_IP_CS_ERROR       0x00000020
    #define RX_PROT_CS_ERROR     0x00000010
    #define RX_VLAN              0x00000004
    #define RX_IPV6              0x00000002
    #define RX_IPV4_FRAG         0x00000001

    #define RX_HEADER_LEN_MASK   0xf800
    #define RX_PROT_TYPE_MASK    0x00ff


    #define READY_TX             0x8000                                  // TX BD Control bits
    #define TRANSMIT_OWNERSHIP_1 0x4000                                  // can be optionally used by software
    #define WRAP_BIT_TX          0x2000
    #define TRANSMIT_OWNERSHIP_2 0x1000                                  // can be optionally used by software
    #define LAST_IN_FRAME_TX     0x0800
    #define TX_CRC               0x0400
    #define TX_ABC               0x0200                                  // append bad CRC - not supported in enhanced mode

    // Enhanced
    //
    #define TX_GENERATE_INT      0x40000000
    #define TX_ADD_TIMESTAMP     0x20000000
    #define TX_INSERT_PROT_CS    0x10000000
    #define TX_INSERT_IP_CS      0x08000000
    #define TX_ERROR_OCCURRED    0x00008000
    #define TX_UNDERFLOW_ERROR   0x00002000
    #define TX_EXCESS_COLLISIONS 0x00001000
    #define TX_FRAME_ERROR       0x00000800
    #define TX_LATE_COLLISION    0x00000400
    #define TX_OVERFLOW_ERROR    0x00000200
    #define TX_TIMESTAMP_ERROR   0x00000100

    #define BD_UPDATE_DONE       0x80000000                              // rx and tx
#else                                                                    // big-endian representation
    typedef struct stKINETIS_FEC_BD
    {
        volatile unsigned short usBDControl;
        volatile unsigned short usBDLength;
        unsigned char *ptrBD_Data;
    #if defined EMAC_ENHANCED                                            // additional fields available in enhanced mode
        volatile unsigned long  ulBDControlEnhanced;
        volatile unsigned short usRxInfoHeaderProt;                      // only receiver
        volatile unsigned short usPayloadCS;                             // only receiver
        volatile unsigned long  ulBDU;
        volatile unsigned long  ul1588_timestamp;
        unsigned long  ulRes[2];
    #endif
    } KINETIS_FEC_BD;

    #define EMPTY_BUFFER         0x0080                                  // RX BD Control bits
    #define RECEIVE_OWNERSHIP_1  0x0040                                  // can be optionally used by software
    #define WRAP_BIT_RX          0x0020
    #define RECEIVE_OWNERSHIP_2  0x0010                                  // can be optionally used by software
    #define LAST_IN_FRAME_RX     0x0008
    #define RECEIVE_MISS         0x0001                                  // received due to promiscuouse mode only
    #define RECEIVE_BROADCAST    0x8000                                  // received due to broadcast address
    #define RECEIVE_MULTICAST    0x4000                                  // received due to multicast address
    #define RECEIVE_LENGTH_VIOL  0x2000                                  // receive frame length violation
    #define RECEIVE_NON_OCTET_AL 0x1000                                  // non-octet aligned frame
    #define RECEIVE_CRC_ERROR    0x0400                                  // receive CRC or frame error
    #define OVERRUN_FRAME        0x0200
    #define TRUNCATED_FRAME      0x0100

    // Enhanced
    //
    #define RX_MAC_ERROR         0x00000080
    #define RX_PHY_ERROR         0x00000004
    #define RX_COLLISION         0x00000002
    #define RX_UNICAST           0x00000001
    #define RX_GEN_INTERRUPT     0x00008000
    #define RX_IP_CS_ERROR       0x20000000
    #define RX_PROT_CS_ERROR     0x10000000
    #define RX_VLAN              0x04000000
    #define RX_IPV6              0x02000000
    #define RX_IPV4_FRAG         0x01000000

    #define RX_HEADER_LEN_MASK   0x00f8
    #define RX_PROT_TYPE_MASK    0xff00


    #define READY_TX             0x0080                                  // TX BD Control bits
    #define TRANSMIT_OWNERSHIP_1 0x0040                                  // can be optionally used by software
    #define WRAP_BIT_TX          0x0020
    #define TRANSMIT_OWNERSHIP_2 0x0010                                  // can be optionally used by software
    #define LAST_IN_FRAME_TX     0x0008
    #define TX_CRC               0x0004
    #define TX_ABC               0x0002                                  // append bad CRC - not supported in enhanced mode

    // Enhanced
    //
    #define TX_GENERATE_INT      0x00000040
    #define TX_ADD_TIMESTAMP     0x00000020
    #define TX_INSERT_PROT_CS    0x00000010
    #define TX_INSERT_IP_CS      0x00000008
    #define TX_ERROR_OCCURRED    0x00800000
    #define TX_UNDERFLOW_ERROR   0x00200000
    #define TX_EXCESS_COLLISIONS 0x00100000
    #define TX_FRAME_ERROR       0x00080000
    #define TX_LATE_COLLISION    0x00040000
    #define TX_OVERFLOW_ERROR    0x00020000
    #define TX_TIMESTAMP_ERROR   0x00010000

    #define BD_UPDATE_DONE       0x00000080                              // rx and tx
#endif


// PHY registers symbolic names
// (located in MII memory map, accessible through MDIO)
//
#define PHY_REG_CR      0x00                                             // Control Register 
#define PHY_REG_SR      0x01                                             // Status Register
#define PHY_REG_ID1     0x02                                             // PHY Identification Register 1 
#define PHY_REG_ID2     0x03                                             // PHY Identification Register 2
#define PHY_REG_ANAR    0x04                                             // Auto-Negotiation Advertisement Register 
#define PHY_REG_ANLPAR  0x05                                             // Auto-Negotiation Link Partner Ability Register 
#define PHY_REG_ER      0x06                                             // Auto-Negotiation Expansion Register 
#define PHY_REG_NPTR    0x07                                             // Auto-Negotiation Next Page Transfer Register
#define PHY_REG_ICR     0x10                                             // Interrupt Control Register 
  #define PHY_ACKIE 0x4000                                               // acknowledge bit received interrupt enable
  #define PHY_PRIE  0x2000                                               // Page received interrupt enable
  #define PHY_LCIE  0x1000                                               // Link changed interrupt enable
  #define PHY_ANIE  0x0800                                               // Auto negotiate changed interrupt enable
  #define PHY_PDFIE 0x0400                                               // Parallel detect fault interrupt enable
  #define PHY_RFIE  0x0200                                               // Remote fault interrupt enable
  #define PHY_JABIE 0x0100                                               // Jabber interrupt enable

  #define PHY_ACKR  0x0040                                               // acknowledge bit received
  #define PHY_PGR   0x0020                                               // Page received 
  #define PHY_LKC   0x0010                                               // Link changed
  #define PHY_ANC   0x0008                                               // Auto negotiate changed
  #define PHY_PDF   0x0004                                               // Parallel detect fault 
  #define PHY_RMTF  0x0002                                               // Remote fault 
  #define PHY_JABI  0x0001                                               // Jabber interrupt 

#define PHY_REG_PSR     0x11                                             // Proprietary Status Register
#define PHY_REG_PCR     0x12                                             // Proprietary Control Register 
#define PHY_REG_10BTBC  0x13                                             // 10Base-T Bypass Control Register 
#define PHY_REG_100BXBC 0x14                                             // 100Base-X Bypass Control Register 
#define PHY_REG_ADDR    0x15                                             // Test & Trim Control Register 
#define PHY_REG_DSPRC   0x17                                             // DSP Reset Control 
#define PHY_REG_DSPRR1  0x18                                             // 100Base-X DSP Read Registers 
#define PHY_REG_DSPRR2  0x19
#define PHY_REG_DSPRR3  0x1a
#define PHY_REG_DSPWR1  0x1b                                             // 100Base-X DSP Write Registers 
#define PHY_REG_DSPWR2  0x1c                              
#define PHY_REG_DSPWR3  0x1d
#define PHY_REG_CTRL1   0x1e
#define PHY_REG_CTRL2   0x1f

#define KSZ8051_CTRL2_RMII_50MHZ_CLK                 0x0080

// External PHY specific registers (Micrel)
//
#define KS8041_BASIC_STATUS_REGISTER                  0x1
  #define PHY_SUPPORT_EXTENDED_CAPABILITIES           0x0001
  #define PHY_JABBER_DETECTED                         0x0002
  #define PHY_LINK_IS_UP                              0x0004
  #define PHY_AUTO_NEGOTIATION_CAPABLE                0x0008
  #define PHY_REMOTE_FAULT_DETECTED                   0x0010
  #define PHY_AUTO_NEGOTIATION_COMPLETE               0x0020
  #define PHY_NO_PREAMBLE                             0x0040
  #define PHY_10MEG_HALF_DUPLEX                       0x0800
  #define PHY_10MEG_FULL_DUPLEX                       0x1000
  #define PHY_100MEG_HALF_DUPLEX                      0x2000
  #define PHY_100MEG_FULL_DUPLEX                      0x4000
  #define PHY_100MEG_T4_CAPABLE                       0x8000

#define KS8041_RXER_COUNTER_REGISTER                  0x15
#define KS8041_INTERRUPT_CONTROL_STATUS_REGISTER      0x1b
  #define PHY_LINK_UP_INT_ENABLE                      0x0100
  #define PHY_REMOTE_FAULT_INT_ENABLE                 0x0200
  #define PHY_LINK_DOWN_INT_ENABLE                    0x0400
  #define PHY_LINK_PARTNER_ACK_INT_ENABLE             0x0800
  #define PHY_PARALLEL_DETECT_FAULT_INT_ENABLE        0x1000
  #define PHY_PAGE_RECEIVED_INT_ENABLE                0x2000
  #define PHY_RECEIVE_ERROR_INT_ENABLE                0x4000
  #define PHY_JABBER_INT_ENABLE                       0x8000
  #define PHY_LINK_UP_INT                             0x0001
  #define PHY_REMOTE_FAULT_INT                        0x0002
  #define PHY_LINK_DOWN_INT                           0x0004
  #define PHY_LINK_PARTNER_ACK_INT                    0x0008
  #define PHY_PARALLEL_DETECT_FAULT_INT               0x0010
  #define PHY_PAGE_RECEIVED_INT                       0x0020
  #define PHY_RECEIVE_ERROR_INT                       0x0040
  #define PHY_JABBER_INT                              0x0080
#if defined PHY_KSZ8031                                                  // {21}
    #define KS8041_100BASETX_PHY_CONTROL_REGISTER     0x1e
      #define PHY_PHY_IS_ISOLATED                     0x0008
      #define PHY_MODE_MASK                           0x0007
      #define PHY_MODE_AUTONEGOTIATING                0x0000
      #define PHY_MODE_10BASE_T_HALF_DUPLEX           0x0001
      #define PHY_MODE_100BASE_TX_HALF_DUPLEX         0x0002
      #define PHY_MODE_10BASE_T_FULL_DUPLEX           0x0005
      #define PHY_MODE_100BASE_TX_FULL_DUPLEX         0x0006
#else
    #define KS8041_100BASETX_PHY_CONTROL_REGISTER     0x1f
      #define PHY_HP_MDIX                             0x8000
      #define PHY_MDIX_SELECT                         0x4000
      #define PHY_PAIRSWAP_DISABLE                    0x2000
      #define PHY_ENERGY_DETECT                       0x1000
      #define PHY_FORCE_LINK                          0x0800
      #define PHY_POWER_SAVING                        0x0400
      #define PHY_INTERRUPT_ACTIVE_HIGH               0x0200
      #define PHY_ENABLE_JABBER                       0x0100
      #define PHY_AUTONEG_COMPLETE                    0x0080
      #define PHY_ENABLE_FLOW_CONTROL_CAPABLE         0x0040
      #define PHY_PHY_IS_ISOLATED                     0x0020
      #define PHY_MODE_MASK                           0x001c
      #define PHY_MODE_AUTONEGOTIATING                0x0000
      #define PHY_MODE_10BASE_T_HALF_DUPLEX           0x0004
      #define PHY_MODE_100BASE_TX_HALF_DUPLEX         0x0008
      #define PHY_MODE_10BASE_T_FULL_DUPLEX           0x0014
      #define PHY_MODE_100BASE_TX_FULL_DUPLEX         0x0018
      #define PHY_ENABLE_SQE_TEST                     0x0002
      #define PHY_DISABLE_SCRAMBLER                   0x0001
#endif


// 0 - Control Register
//
#define PHY_R0_RESET    0x8000                                           // Reset
#define PHY_R0_LB       0x4000                                           // Loop Back
#define PHY_R0_DR       0x2000                                           // Data Rate (100Mb/s)
#define PHY_R0_ANE      0x1000                                           // Auto-Negotiation Enable
#define PHY_R0_PD       0x0800                                           // Power Down
#define PHY_R0_ISOLATE  0x0400                                           // Isolate (MII is disconnected)
#define PHY_R0_RAN      0x0200                                           // Restart Auto-Negotiation
#define PHY_R0_DPLX     0x0100                                           // Duplex (Full duplex)
#define PHY_R0_CT       0x0080                                           // Collision Test (Enable)

// 4 - Auto Negotiation Advertisement Register
//
#define PHY_R4_NP       0x8000                                           // Next Page (capable of sending next pages)
#define PHY_R4_RF       0x2000                                           // Remote Fault
#define PHY_R4_FC       0x0400                                           // Flow Control
#define PHY_R4_100F     0x0100                                           // 100Base-TX Full Duplex Capable 
#define PHY_R4_100H     0x0080                                           // 100Base-TX Half Duplex Capable
#define PHY_R4_10F      0x0040                                           // 10Base-T Full Duplex Capable 
#define PHY_R4_10H      0x0020                                           // 10Base-T Half Duplex Capable 

// Proprietary Status Register
//
#define PHY_R17_LNK   0x4000    
#define PHY_R17_DPM   0x2000                                             // Duplex Mode
#define PHY_R17_SPD   0x1000                                             // Speed
#define PHY_R17_ANNC  0x0400                                             // Auto-Negotiation Complete
#define PHY_R17_PRCVD 0x0200
#define PHY_R17_ANCM  0x0100                                             // Auto-Negotiation (A-N) Common Operating Mode
#define PHY_R17_PLR   0x0020


#if defined PHY_MULTI_PORT                                               // {19}
    extern unsigned short _fnMIIread(unsigned char ucPort, unsigned char _mradr);
    extern void _fnMIIwrite(unsigned char ucPort, unsigned char _mradr, unsigned short _mwdata);
#else
    extern unsigned short _fnMIIread(unsigned char _mradr);
    extern void _fnMIIwrite(unsigned char _mradr, unsigned short _mwdata);
#endif

// DAC                                                                   {23}
//
#if DAC_CONTROLLERS > 0
    #define DAC0_DAT0L                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x00) // Data Low Register
    #define DAC0_DAT0H                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x01) // Data High Register
    #define DAC0_DAT1L                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x02) // Data Low Register
    #define DAC0_DAT1H                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x03) // Data High Register
    #if !defined KINETIS_KL                                              // {52}
        #define DAC0_DAT2L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x04) // Data Low Register
        #define DAC0_DAT2H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x05) // Data High Register
        #define DAC0_DAT3L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x06) // Data Low Register
        #define DAC0_DAT3H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x07) // Data High Register
        #define DAC0_DAT4L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x08) // Data Low Register
        #define DAC0_DAT4H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x09) // Data High Register
        #define DAC0_DAT5L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0a) // Data Low Register
        #define DAC0_DAT5H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0b) // Data High Register
        #define DAC0_DAT6L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0c) // Data Low Register
        #define DAC0_DAT6H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0d) // Data High Register
        #define DAC0_DAT7L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0e) // Data Low Register
        #define DAC0_DAT7H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0f) // Data High Register
        #define DAC0_DAT8L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x10) // Data Low Register
        #define DAC0_DAT8H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x11) // Data High Register
        #define DAC0_DAT9L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x12) // Data Low Register
        #define DAC0_DAT9H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x13) // Data High Register
        #define DAC0_DAT10L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x14) // Data Low Register
        #define DAC0_DAT10H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x15) // Data High Register
        #define DAC0_DAT11L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x16) // Data Low Register
        #define DAC0_DAT11H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x17) // Data High Register
        #define DAC0_DAT12L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x18) // Data Low Register
        #define DAC0_DAT12H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x19) // Data High Register
        #define DAC0_DAT13L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1a) // Data Low Register
        #define DAC0_DAT13H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1b) // Data High Register
        #define DAC0_DAT14L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1c) // Data Low Register
        #define DAC0_DAT14H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1d) // Data High Register
        #define DAC0_DAT15L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1e) // Data Low Register
        #define DAC0_DAT15H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1f) // Data High Register
    #endif
    #define DAC0_SR                      *(volatile unsigned char*)(DAC0_BASE_ADD + 0x20) // DAC0 Status Register
      #define DAC_SR_DACBFPBF            0x01                            // DAC buffer read pointer is equal to the DACBFUP
      #define DAC_SR_DACBFRPTF           0x02                            // DAC buffer read pointer is zero
     #if !defined KINETIS_KL
      #define DAC_SR_DACBFWMF            0x04                            // DAC buffer read pointer has reached the watermark level
     #endif
    #define DAC0_C0                      *(unsigned char*)(DAC0_BASE_ADD + 0x21) // DAC0 Control Register
      #define DAC_C0_DACBBIEN            0x01                            // DAC buffer read pointer bottom flag interrupt enable
      #define DAC_C0_DACBTIEN            0x02                            // DAC buffer read pointer top flag interrupt enable
     #if !defined KINETIS_KL
      #define DAC_C0_DACBWIEN            0x04                            // DAC watermark interrupt enable
     #endif
      #define DAC_C0_LPEN_HIGH_POWER     0x00                            // DAC high power mode
      #define DAC_C0_LPEN_LOW_POWER      0x08                            // DAC low power mode
      #define DAC_C0_DACSWTRG            0x10                            // (write-only) DAC software trigger valid
      #define DAC_C0_DACTRGSET_HW        0x00                            // DAC hardware trigger select
      #define DAC_C0_DACTRGSET_SW        0x20                            // DAC software trigger select
     #if defined KINETIS_KL
      #define DAC_C0_DACRFS_VREF         0x00                            // DAC reference voltage select - DACREF_1
      #define DAC_C0_DACRFS_VREF2        0x40                            // DAC reference voltage select - DACREF_2
     #else
      #define DAC_C0_DACRFS_VREF         0x00                            // DAC reference voltage select - VREF
      #define DAC_C0_DACRFS_VDDA         0x40                            // DAC reference voltage select - VDDA
     #endif
      #define DAC_C0_DACEN               0x80                            // DAC enable
    #define DAC0_C1                      *(unsigned char*)(DAC0_BASE_ADD + 0x22) // DAC0 Control Register 1
      #define DAC_C1_DACBFEN             0x01                            // DAC buffer enable
      #define DAC_C1_DACBFMD_NORMAL      0x00                            // DAC buffer work mode select - normal mode
     #if !defined KINETIS_KL
      #define DAC_C1_DACBFMD_SWING       0x02                            // DAC buffer work mode select - swing mode
     #endif
      #define DAC_C1_DACBFMD_ONE_TIME_SCAN  0x04                         // DAC buffer work mode select - one-time scan mode
     #if !defined KINETIS_KL
      #define DAC_C1_DACBFWM_1_WORD      0x00                            // DAC watermark select - 1 word
      #define DAC_C1_DACBFWM_2_WORDS     0x08                            // DAC watermark select - 2 words
      #define DAC_C1_DACBFWM_3_WORDS     0x10                            // DAC watermark select - 3 words
      #define DAC_C1_DACBFWM_4_WORDS     0x18                            // DAC watermark select - 4 words
     #endif
      #define DAC_C1_DMAEN               0x80                            // DMA enable select
    #define DAC0_C2                      *(volatile unsigned char*)(DAC0_BASE_ADD + 0x23) // DAC0 Control Register 2
#endif
#if DAC_CONTROLLERS > 1
    #define DAC1_DAT0L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x00) // Data Low Register
    #define DAC1_DAT0H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x01) // Data High Register
    #define DAC1_DAT1L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x02) // Data Low Register
    #define DAC1_DAT1H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x03) // Data High Register
    #define DAC1_DAT2L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x04) // Data Low Register
    #define DAC1_DAT2H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x05) // Data High Register
    #define DAC1_DAT3L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x06) // Data Low Register
    #define DAC1_DAT3H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x07) // Data High Register
    #define DAC1_DAT4L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x08) // Data Low Register
    #define DAC1_DAT4H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x09) // Data High Register
    #define DAC1_DAT5L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0a) // Data Low Register
    #define DAC1_DAT5H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0b) // Data High Register
    #define DAC1_DAT6L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0c) // Data Low Register
    #define DAC1_DAT6H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0d) // Data High Register
    #define DAC1_DAT7L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0e) // Data Low Register
    #define DAC1_DAT7H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0f) // Data High Register
    #define DAC1_DAT8L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x10) // Data Low Register
    #define DAC1_DAT8H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x11) // Data High Register
    #define DAC1_DAT9L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x12) // Data Low Register
    #define DAC1_DAT9H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x13) // Data High Register
    #define DAC1_DAT10L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x14) // Data Low Register
    #define DAC1_DAT10H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x15) // Data High Register
    #define DAC1_DAT11L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x16) // Data Low Register
    #define DAC1_DAT11H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x17) // Data High Register
    #define DAC1_DAT12L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x18) // Data Low Register
    #define DAC1_DAT12H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x19) // Data High Register
    #define DAC1_DAT13L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1a) // Data Low Register
    #define DAC1_DAT13H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1b) // Data High Register
    #define DAC1_DAT14L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1c) // Data Low Register
    #define DAC1_DAT14H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1d) // Data High Register
    #define DAC1_DAT15L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1e) // Data Low Register
    #define DAC1_DAT15H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1f) // Data High Register
    #define DAC1_SR                      *(volatile unsigned char*)(DAC1_BASE_ADD + 0x20) // DAC1 Status Register
    #define DAC1_C0                      *(unsigned char*)(DAC1_BASE_ADD + 0x21) // DAC1 Control Register
    #define DAC1_C1                      *(unsigned char*)(DAC1_BASE_ADD + 0x22) // DAC1 Control Register 1
    #define DAC1_C2                      *(volatile unsigned char*)(DAC1_BASE_ADD + 0x23) // DAC1 Control Register 2
#endif

// Macros to enable and disable DAC operation
//
#define ENABLE_DAC(DACref)               DAC##DACref##_C0 |= (DAC_C0_DACEN)
#define DISABLE_DAC(DACref)              DAC##DACref##_C0 &= ~(DAC_C0_DACEN)

typedef struct stDAC_REGS                                                // {23}
{
    volatile unsigned short DAC_DAT[16];
    volatile unsigned char DAC_SR;
    unsigned char DAC_C0;
    unsigned char DAC_C1;
    unsigned char DAC_C2;
} DAC_REGS;


// GPIOs
//
#define GPIOA_ADD                        (volatile unsigned long*)(GPIO_BLOCK + 0x000)
#define GPIOA_PDOR                       *(volatile unsigned long*)(GPIO_BLOCK + 0x000)   // Port A Data Output Register
#define GPIOA_PSOR                       *(volatile unsigned long*)(GPIO_BLOCK + 0x004)   // Port A Set Output Register (write-only - always reads 0)
#define GPIOA_PCOR                       *(volatile unsigned long*)(GPIO_BLOCK + 0x008)   // Port A Clear Output Register (write-only - always reads 0)
#define GPIOA_PTOR                       *(volatile unsigned long*)(GPIO_BLOCK + 0x00c)   // Port A Toggle Output Register (write-only - always reads 0)
#define GPIOA_PDIR                       *(volatile unsigned long*)(GPIO_BLOCK + 0x010)   // Port A Data Input Register (read-only)
#define GPIOA_PDDR                       *(volatile unsigned long*)(GPIO_BLOCK + 0x014)   // Port A Data Direction Register
#if defined KINETIS_KE
    #define GPIOA_PIDR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x018)   // Port A Input Disable Register
#endif
#if PORTS_AVAILABLE > 1
    #define GPIOB_ADD                    (volatile unsigned long*)(GPIO_BLOCK + 0x040)
    #define GPIOB_PDOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x040)   // Port B Data Output Register
    #define GPIOB_PSOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x044)   // Port B Set Output Register (write-only - always reads 0)
    #define GPIOB_PCOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x048)   // Port B Clear Output Register (write-only - always reads 0)
    #define GPIOB_PTOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x04c)   // Port B Toggle Output Register (write-only - always reads 0)
    #define GPIOB_PDIR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x050)   // Port B Data Input Register (read-only)
    #define GPIOB_PDDR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x054)   // Port B Data Direction Register
    #if defined KINETIS_KE
    #define GPIOB_PIDR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x058)   // Port B Input Disable Register
    #endif
#endif
#if PORTS_AVAILABLE > 2
    #define GPIOC_ADD                    (volatile unsigned long*)(GPIO_BLOCK + 0x080)
    #define GPIOC_PDOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x080)   // Port C Data Output Register
    #define GPIOC_PSOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x084)   // Port C Set Output Register (write-only - always reads 0)
    #define GPIOC_PCOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x088)   // Port C Clear Output Register (write-only - always reads 0)
    #define GPIOC_PTOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x08c)   // Port C Toggle Output Register (write-only - always reads 0)
    #define GPIOC_PDIR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x090)   // Port C Data Input Register (read-only)
    #define GPIOC_PDDR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x094)   // Port C Data Direction Register
#endif
#if PORTS_AVAILABLE > 3
    #define GPIOD_ADD                    (volatile unsigned long*)(GPIO_BLOCK + 0x0c0)
    #define GPIOD_PDOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x0c0)   // Port D Data Output Register
    #define GPIOD_PSOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x0c4)   // Port D Set Output Register (write-only - always reads 0)
    #define GPIOD_PCOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x0c8)   // Port D Clear Output Register (write-only - always reads 0)
    #define GPIOD_PTOR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x0cc)   // Port D Toggle Output Register (write-only - always reads 0)
    #define GPIOD_PDIR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x0d0)   // Port D Data Input Register (read-only)
    #define GPIOD_PDDR                   *(volatile unsigned long*)(GPIO_BLOCK + 0x0d4)   // Port D Data Direction Register
#endif
#if PORTS_AVAILABLE > 4
    #define GPIOE_ADD                    (volatile unsigned long*)(GPIO_BLOCK + 0x100)
    #define GPIOE_PDOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x100)  // Port E Data Output Register
    #define GPIOE_PSOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x104)  // Port E Set Output Register (write-only - always reads 0)
    #define GPIOE_PCOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x108)  // Port E Clear Output Register (write-only - always reads 0)
    #define GPIOE_PTOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x10c)  // Port E Toggle Output Register (write-only - always reads 0)
    #define GPIOE_PDIR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x110)  // Port E Data Input Register (read-only)
    #define GPIOE_PDDR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x114)  // Port E Data Direction Register
#endif
#if PORTS_AVAILABLE > 5
    #define GPIOF_ADD                    (volatile unsigned long*)(GPIO_BLOCK + 0x140)
    #define GPIOF_PDOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x140)  // Port F Data Output Register {11}
    #define GPIOF_PSOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x144)  // Port F Set Output Register (write-only - always reads 0)
    #define GPIOF_PCOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x148)  // Port F Clear Output Register (write-only - always reads 0)
    #define GPIOF_PTOR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x14c)  // Port F Toggle Output Register (write-only - always reads 0)
    #define GPIOF_PDIR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x150)  // Port F Data Input Register (read-only)
    #define GPIOF_PDDR                   *(volatile unsigned long *)(GPIO_BLOCK + 0x154)  // Port F Data Direction Register
#endif

typedef struct stGPIO_RGS
{
    volatile unsigned long  PDOR;
    volatile unsigned long  PSOR;
    volatile unsigned long  PCOR;
    volatile unsigned long  PTOR;
    volatile unsigned long  PDIR;
    volatile unsigned long  PDDR;
    #if defined KINETIS_KE
        volatile unsigned long  PIDR;
    #endif
} GPIO_REGS;

// Fast GPIOs
//
#if defined FGPIO_AVAILABLE
    #define FGPIOA_ADD                    (volatile unsigned long*)(FGPIO_BLOCK + 0x000)
    #define FGPIOA_PDOR                  *(volatile unsigned long*)(FGPIO_BLOCK + 0x000)  // Port A Data Output Register
    #define FGPIOA_PSOR                  *(volatile unsigned long*)(FGPIO_BLOCK + 0x004)  // Port A Set Output Register (write-only - always reads 0)
    #define FGPIOA_PCOR                  *(volatile unsigned long*)(FGPIO_BLOCK + 0x008)  // Port A Clear Output Register (write-only - always reads 0)
    #define FGPIOA_PTOR                  *(volatile unsigned long*)(FGPIO_BLOCK + 0x00c)  // Port A Toggle Output Register (write-only - always reads 0)
    #define FGPIOA_PDIR                  *(volatile unsigned long*)(FGPIO_BLOCK + 0x010)  // Port A Data Input Register (read-only)
    #define FGPIOA_PDDR                  *(volatile unsigned long*)(FGPIO_BLOCK + 0x014)  // Port A Data Direction Register

    #if PORTS_AVAILABLE > 1
        #define FGPIOB_ADD               (volatile unsigned long*)(FGPIO_BLOCK + 0x040)
        #define FGPIOB_PDOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x040)  // Port B Data Output Register
        #define FGPIOB_PSOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x044)  // Port B Set Output Register (write-only - always reads 0)
        #define FGPIOB_PCOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x048)  // Port B Clear Output Register (write-only - always reads 0)
        #define FGPIOB_PTOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x04c)  // Port B Toggle Output Register (write-only - always reads 0)
        #define FGPIOB_PDIR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x050)  // Port B Data Input Register (read-only)
        #define FGPIOB_PDDR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x054)  // Port B Data Direction Register
    #endif
    #if PORTS_AVAILABLE > 2
        #define FGPIOC_ADD               (volatile unsigned long*)(FGPIO_BLOCK + 0x080)
        #define FGPIOC_PDOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x080)  // Port C Data Output Register
        #define FGPIOC_PSOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x084)  // Port C Set Output Register (write-only - always reads 0)
        #define FGPIOC_PCOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x088)  // Port C Clear Output Register (write-only - always reads 0)
        #define FGPIOC_PTOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x08c)  // Port C Toggle Output Register (write-only - always reads 0)
        #define FGPIOC_PDIR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x090)  // Port C Data Input Register (read-only)
        #define FGPIOC_PDDR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x094)  // Port C Data Direction Register
    #endif
    #if PORTS_AVAILABLE > 3
        #define FGPIOD_ADD               (volatile unsigned long*)(FGPIO_BLOCK + 0x0c0)
        #define FGPIOD_PDOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x0c0)  // Port D Data Output Register
        #define FGPIOD_PSOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x0c4)  // Port D Set Output Register (write-only - always reads 0)
        #define FGPIOD_PCOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x0c8)  // Port D Clear Output Register (write-only - always reads 0)
        #define FGPIOD_PTOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x0cc)  // Port D Toggle Output Register (write-only - always reads 0)
        #define FGPIOD_PDIR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x0d0)  // Port D Data Input Register (read-only)
        #define FGPIOD_PDDR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x0d4)  // Port D Data Direction Register
    #endif
    #if PORTS_AVAILABLE > 4
        #define FGPIOE_ADD               (volatile unsigned long*)(FGPIO_BLOCK + 0x100)
        #define FGPIOE_PDOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x100)  // Port E Data Output Register
        #define FGPIOE_PSOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x104)  // Port E Set Output Register (write-only - always reads 0)
        #define FGPIOE_PCOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x108)  // Port E Clear Output Register (write-only - always reads 0)
        #define FGPIOE_PTOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x10c)  // Port E Toggle Output Register (write-only - always reads 0)
        #define FGPIOE_PDIR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x110)  // Port E Data Input Register (read-only)
        #define FGPIOE_PDDR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x114)  // Port E Data Direction Register
    #endif
    #if PORTS_AVAILABLE > 5
        #define FGPIOF_ADD               (volatile unsigned long*)(FGPIO_BLOCK + 0x140)
        #define FGPIOF_PDOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x140)  // Port F Data Output Register
        #define FGPIOF_PSOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x144)  // Port F Set Output Register (write-only - always reads 0)
        #define FGPIOF_PCOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x148)  // Port F Clear Output Register (write-only - always reads 0)
        #define FGPIOF_PTOR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x14c)  // Port F Toggle Output Register (write-only - always reads 0)
        #define FGPIOF_PDIR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x150)  // Port F Data Input Register (read-only)
        #define FGPIOF_PDDR              *(volatile unsigned long*)(FGPIO_BLOCK + 0x154)  // Port F Data Direction Register
    #endif

    typedef struct stFGPIO_RGS
    {
        volatile unsigned long  PDOR;
        volatile unsigned long  PSOR;
        volatile unsigned long  PCOR;
        volatile unsigned long  PTOR;
        volatile unsigned long  PDIR;
        volatile unsigned long  PDDR;
    } FGPIO_REGS;
#endif

#if defined KINETIS_KE
  #define PORT_WIDTH                     8                               // 8 bit ports according to KE convention

  #define KE_PORTA                       0
  #define KE_PORTB                       0
  #define KE_PORTC                       0
  #define KE_PORTD                       0

  #define KE_PORTE                       1
  #define KE_PORTF                       1
  #define KE_PORTG                       1
  #define KE_PORTH                       1

  #define KE_PORTI                       2

  #define KE_PORTA_BIT0                  0x00000001
  #define KE_PORTA_BIT1                  0x00000002
  #define KE_PORTA_BIT2                  0x00000004
  #define KE_PORTA_BIT3                  0x00000008
  #define KE_PORTA_BIT4                  0x00000010
  #define KE_PORTA_BIT5                  0x00000020
  #define KE_PORTA_BIT6                  0x00000040
  #define KE_PORTA_BIT7                  0x00000080

  #define KE_PORTB_BIT0                  0x00000100
  #define KE_PORTB_BIT1                  0x00000200
  #define KE_PORTB_BIT2                  0x00000400
  #define KE_PORTB_BIT3                  0x00000800
  #define KE_PORTB_BIT4                  0x00001000
  #define KE_PORTB_BIT5                  0x00002000
  #define KE_PORTB_BIT6                  0x00004000
  #define KE_PORTB_BIT7                  0x00008000

  #define KE_PORTC_BIT0                  0x00010000
  #define KE_PORTC_BIT1                  0x00020000
  #define KE_PORTC_BIT2                  0x00040000
  #define KE_PORTC_BIT3                  0x00080000
  #define KE_PORTC_BIT4                  0x00100000
  #define KE_PORTC_BIT5                  0x00200000
  #define KE_PORTC_BIT6                  0x00400000
  #define KE_PORTC_BIT7                  0x00800000

  #define KE_PORTD_BIT0                  0x01000000
  #define KE_PORTD_BIT1                  0x02000000
  #define KE_PORTD_BIT2                  0x04000000
  #define KE_PORTD_BIT3                  0x08000000
  #define KE_PORTD_BIT4                  0x10000000
  #define KE_PORTD_BIT5                  0x20000000
  #define KE_PORTD_BIT6                  0x40000000
  #define KE_PORTD_BIT7                  0x80000000

  #define KE_PORTE_BIT0                  0x00000001
  #define KE_PORTE_BIT1                  0x00000002
  #define KE_PORTE_BIT2                  0x00000004
  #define KE_PORTE_BIT3                  0x00000008
  #define KE_PORTE_BIT4                  0x00000010
  #define KE_PORTE_BIT5                  0x00000020
  #define KE_PORTE_BIT6                  0x00000040
  #define KE_PORTE_BIT7                  0x00000080

  #define KE_PORTF_BIT0                  0x00000100
  #define KE_PORTF_BIT1                  0x00000200
  #define KE_PORTF_BIT2                  0x00000400
  #define KE_PORTF_BIT3                  0x00000800
  #define KE_PORTF_BIT4                  0x00001000
  #define KE_PORTF_BIT5                  0x00002000
  #define KE_PORTF_BIT6                  0x00004000
  #define KE_PORTF_BIT7                  0x00008000

  #define KE_PORTG_BIT0                  0x00010000
  #define KE_PORTG_BIT1                  0x00020000
  #define KE_PORTG_BIT2                  0x00040000
  #define KE_PORTG_BIT3                  0x00080000
  #define KE_PORTG_BIT4                  0x00100000
  #define KE_PORTG_BIT5                  0x00200000
  #define KE_PORTG_BIT6                  0x00400000
  #define KE_PORTG_BIT7                  0x00800000

  #define KE_PORTH_BIT0                  0x01000000
  #define KE_PORTH_BIT1                  0x02000000
  #define KE_PORTH_BIT2                  0x04000000
  #define KE_PORTH_BIT3                  0x08000000
  #define KE_PORTH_BIT4                  0x10000000
  #define KE_PORTH_BIT5                  0x20000000
  #define KE_PORTH_BIT6                  0x40000000
  #define KE_PORTH_BIT7                  0x80000000

  #define KE_PORTI_BIT0                  0x00000001
  #define KE_PORTI_BIT1                  0x00000002
  #define KE_PORTI_BIT2                  0x00000004
  #define KE_PORTI_BIT3                  0x00000008
  #define KE_PORTI_BIT4                  0x00000010
  #define KE_PORTI_BIT5                  0x00000020
  #define KE_PORTI_BIT6                  0x00000040
  #define KE_PORTI_BIT7                  0x00000080
#else
  #define PORT_WIDTH                     32
#endif

#define PORTA_BIT0                       0x00000001
#define PORTA_BIT1                       0x00000002
#define PORTA_BIT2                       0x00000004
#define PORTA_BIT3                       0x00000008
#define PORTA_BIT4                       0x00000010
#define PORTA_BIT5                       0x00000020
#define PORTA_BIT6                       0x00000040
#define PORTA_BIT7                       0x00000080
#define PORTA_BIT8                       0x00000100
#define PORTA_BIT9                       0x00000200
#define PORTA_BIT10                      0x00000400
#define PORTA_BIT11                      0x00000800
#define PORTA_BIT12                      0x00001000
#define PORTA_BIT13                      0x00002000
#define PORTA_BIT14                      0x00004000
#define PORTA_BIT15                      0x00008000
#define PORTA_BIT16                      0x00010000
#define PORTA_BIT17                      0x00020000
#define PORTA_BIT18                      0x00040000
#define PORTA_BIT19                      0x00080000
#define PORTA_BIT20                      0x00100000
#define PORTA_BIT21                      0x00200000
#define PORTA_BIT22                      0x00400000
#define PORTA_BIT23                      0x00800000
#define PORTA_BIT24                      0x01000000
#define PORTA_BIT25                      0x02000000
#define PORTA_BIT26                      0x04000000
#define PORTA_BIT27                      0x08000000
#define PORTA_BIT28                      0x10000000
#define PORTA_BIT29                      0x20000000
#define PORTA_BIT30                      0x40000000
#define PORTA_BIT31                      0x80000000

#define PORTB_BIT0                       0x00000001
#define PORTB_BIT1                       0x00000002
#define PORTB_BIT2                       0x00000004
#define PORTB_BIT3                       0x00000008
#define PORTB_BIT4                       0x00000010
#define PORTB_BIT5                       0x00000020
#define PORTB_BIT6                       0x00000040
#define PORTB_BIT7                       0x00000080
#define PORTB_BIT8                       0x00000100
#define PORTB_BIT9                       0x00000200
#define PORTB_BIT10                      0x00000400
#define PORTB_BIT11                      0x00000800
#define PORTB_BIT12                      0x00001000
#define PORTB_BIT13                      0x00002000
#define PORTB_BIT14                      0x00004000
#define PORTB_BIT15                      0x00008000
#define PORTB_BIT16                      0x00010000
#define PORTB_BIT17                      0x00020000
#define PORTB_BIT18                      0x00040000
#define PORTB_BIT19                      0x00080000
#define PORTB_BIT20                      0x00100000
#define PORTB_BIT21                      0x00200000
#define PORTB_BIT22                      0x00400000
#define PORTB_BIT23                      0x00800000
#define PORTB_BIT24                      0x01000000
#define PORTB_BIT25                      0x02000000
#define PORTB_BIT26                      0x04000000
#define PORTB_BIT27                      0x08000000
#define PORTB_BIT28                      0x10000000
#define PORTB_BIT29                      0x20000000
#define PORTB_BIT30                      0x40000000
#define PORTB_BIT31                      0x80000000

#if defined KINETIS_KW2X
    #define RST_B                        PORTB_BIT19                     // MCU output is internally connected to modem reset line
    #define IRQ_B                        PORTB_BIT3                      // MCU input is internally connected to modem IRQ line
    #define GPIO3                        PORTC_BIT3
    #define GPIO4                        PORTC_BIT1
    #define GPIO5                        PORTC_BIT0
#endif

#define PORTC_BIT0                       0x00000001
#define PORTC_BIT1                       0x00000002
#define PORTC_BIT2                       0x00000004
#define PORTC_BIT3                       0x00000008
#define PORTC_BIT4                       0x00000010
#define PORTC_BIT5                       0x00000020
#define PORTC_BIT6                       0x00000040
#define PORTC_BIT7                       0x00000080
#define PORTC_BIT8                       0x00000100
#define PORTC_BIT9                       0x00000200
#define PORTC_BIT10                      0x00000400
#define PORTC_BIT11                      0x00000800
#define PORTC_BIT12                      0x00001000
#define PORTC_BIT13                      0x00002000
#define PORTC_BIT14                      0x00004000
#define PORTC_BIT15                      0x00008000
#define PORTC_BIT16                      0x00010000
#define PORTC_BIT17                      0x00020000
#define PORTC_BIT18                      0x00040000
#define PORTC_BIT19                      0x00080000
#define PORTC_BIT20                      0x00100000
#define PORTC_BIT21                      0x00200000
#define PORTC_BIT22                      0x00400000
#define PORTC_BIT23                      0x00800000
#define PORTC_BIT24                      0x01000000
#define PORTC_BIT25                      0x02000000
#define PORTC_BIT26                      0x04000000
#define PORTC_BIT27                      0x08000000
#define PORTC_BIT28                      0x10000000
#define PORTC_BIT29                      0x20000000
#define PORTC_BIT30                      0x40000000
#define PORTC_BIT31                      0x80000000

#define PORTD_BIT0                       0x00000001
#define PORTD_BIT1                       0x00000002
#define PORTD_BIT2                       0x00000004
#define PORTD_BIT3                       0x00000008
#define PORTD_BIT4                       0x00000010
#define PORTD_BIT5                       0x00000020
#define PORTD_BIT6                       0x00000040
#define PORTD_BIT7                       0x00000080
#define PORTD_BIT8                       0x00000100
#define PORTD_BIT9                       0x00000200
#define PORTD_BIT10                      0x00000400
#define PORTD_BIT11                      0x00000800
#define PORTD_BIT12                      0x00001000
#define PORTD_BIT13                      0x00002000
#define PORTD_BIT14                      0x00004000
#define PORTD_BIT15                      0x00008000
#define PORTD_BIT16                      0x00010000
#define PORTD_BIT17                      0x00020000
#define PORTD_BIT18                      0x00040000
#define PORTD_BIT19                      0x00080000
#define PORTD_BIT20                      0x00100000
#define PORTD_BIT21                      0x00200000
#define PORTD_BIT22                      0x00400000
#define PORTD_BIT23                      0x00800000
#define PORTD_BIT24                      0x01000000
#define PORTD_BIT25                      0x02000000
#define PORTD_BIT26                      0x04000000
#define PORTD_BIT27                      0x08000000
#define PORTD_BIT28                      0x10000000
#define PORTD_BIT29                      0x20000000
#define PORTD_BIT30                      0x40000000
#define PORTD_BIT31                      0x80000000

#define PORTE_BIT0                       0x00000001
#define PORTE_BIT1                       0x00000002
#define PORTE_BIT2                       0x00000004
#define PORTE_BIT3                       0x00000008
#define PORTE_BIT4                       0x00000010
#define PORTE_BIT5                       0x00000020
#define PORTE_BIT6                       0x00000040
#define PORTE_BIT7                       0x00000080
#define PORTE_BIT8                       0x00000100
#define PORTE_BIT9                       0x00000200
#define PORTE_BIT10                      0x00000400
#define PORTE_BIT11                      0x00000800
#define PORTE_BIT12                      0x00001000
#define PORTE_BIT13                      0x00002000
#define PORTE_BIT14                      0x00004000
#define PORTE_BIT15                      0x00008000
#define PORTE_BIT16                      0x00010000
#define PORTE_BIT17                      0x00020000
#define PORTE_BIT18                      0x00040000
#define PORTE_BIT19                      0x00080000
#define PORTE_BIT20                      0x00100000
#define PORTE_BIT21                      0x00200000
#define PORTE_BIT22                      0x00400000
#define PORTE_BIT23                      0x00800000
#define PORTE_BIT24                      0x01000000
#define PORTE_BIT25                      0x02000000
#define PORTE_BIT26                      0x04000000
#define PORTE_BIT27                      0x08000000
#define PORTE_BIT28                      0x10000000
#define PORTE_BIT29                      0x20000000
#define PORTE_BIT30                      0x40000000
#define PORTE_BIT31                      0x80000000
  
#define PORTF_BIT0                       0x00000001                      // {18}
#define PORTF_BIT1                       0x00000002
#define PORTF_BIT2                       0x00000004
#define PORTF_BIT3                       0x00000008
#define PORTF_BIT4                       0x00000010
#define PORTF_BIT5                       0x00000020
#define PORTF_BIT6                       0x00000040
#define PORTF_BIT7                       0x00000080
#define PORTF_BIT8                       0x00000100
#define PORTF_BIT9                       0x00000200
#define PORTF_BIT10                      0x00000400
#define PORTF_BIT11                      0x00000800
#define PORTF_BIT12                      0x00001000
#define PORTF_BIT13                      0x00002000
#define PORTF_BIT14                      0x00004000
#define PORTF_BIT15                      0x00008000
#define PORTF_BIT16                      0x00010000
#define PORTF_BIT17                      0x00020000
#define PORTF_BIT18                      0x00040000
#define PORTF_BIT19                      0x00080000
#define PORTF_BIT20                      0x00100000
#define PORTF_BIT21                      0x00200000
#define PORTF_BIT22                      0x00400000
#define PORTF_BIT23                      0x00800000
#define PORTF_BIT24                      0x01000000
#define PORTF_BIT25                      0x02000000
#define PORTF_BIT26                      0x04000000
#define PORTF_BIT27                      0x08000000
#define PORTF_BIT28                      0x10000000
#define PORTF_BIT29                      0x20000000
#define PORTF_BIT30                      0x40000000
#define PORTF_BIT31                      0x80000000

extern void fnConnectGPIO(int iPortRef, unsigned long ulPortBits, unsigned long ulCharacteristics);
extern void fnSimPers(void);

// Port macros
//

// Configure pins as output, including enabling clock to specified port eg. _CONFIG_PORT_OUTPUT(A, PORTA_BIT16, (PORT_SRE_FAST | PORT_DSE_LOW));
//
#if defined KINETIS_KE
    #define _CONFIG_PORT_OUTPUT(ref, pins, chars) GPIO##ref##_PIDR &= ~(pins); fnConnectGPIO(PORT##ref, pins, (PORT_MUX_GPIO | chars)); GPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_PORT_OUTPUT_FAST_LOW(ref, pins, chars)  _CONFIG_PORT_OUTPUT(ref, pins, chars)
    #define _CONFIG_PORT_OUTPUT_FAST_HIGH(ref, pins, chars) _CONFIG_PORT_OUTPUT(ref, pins, chars)
#else
    #define _CONFIG_PORT_OUTPUT(ref, pins, chars) SIM_SCGC5 |= SIM_SCGC5_PORT##ref; fnConnectGPIO(PORT##ref, pins, (PORT_MUX_GPIO | chars)); GPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE; _SIM_PER_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_PORT_OUTPUT_FAST_LOW(ref, pins, chars)  SIM_SCGC5 |= SIM_SCGC5_PORT##ref; PORT##ref##_GPCLR = (((pins) << 16) | (chars | PORT_MUX_GPIO)); GPIO##ref##_PDDR |= ((pins) & 0x0000ffff); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_PORT_OUTPUT_FAST_HIGH(ref, pins, chars) SIM_SCGC5 |= SIM_SCGC5_PORT##ref; PORT##ref##_GPCHR = (((pins) & 0xffff0000) | chars | PORT_MUX_GPIO); GPIO##ref##_PDDR |= ((pins) & 0xffff0000); _SIM_PORT_CHANGE; _SIM_PER_CHANGE // {65}
#endif

// Configure pins as Input, including enabling clock to specified port eg. _CONFIG_PORT_INPUT(A, PORTA_BIT4, PORT_PS_UP_ENABLE);
//
#if defined KINETIS_KE
    #define _CONFIG_PORT_INPUT(ref, pins, chars) GPIO##ref##_PIDR &= ~(pins); GPIO##ref##_PDDR &= ~(pins); fnConnectGPIO(PORT##ref, pins, (PORT_MUX_GPIO | chars)); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_PORT_INPUT_FAST_LOW(ref, pins, chars)  _CONFIG_PORT_INPUT(ref, pins, chars)
    #define _CONFIG_PORT_INPUT_FAST_HIGH(ref, pins, chars) _CONFIG_PORT_INPUT(ref, pins, chars)
#else
    #define _CONFIG_PORT_INPUT(ref, pins, chars)  SIM_SCGC5 |= SIM_SCGC5_PORT##ref; GPIO##ref##_PDDR &= ~(pins);fnConnectGPIO(PORT##ref, pins, (PORT_MUX_GPIO | chars)); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_PORT_INPUT_FAST_LOW(ref, pins, chars)  SIM_SCGC5 |= SIM_SCGC5_PORT##ref; GPIO##ref##_PDDR &= ~((pins) & 0x0000ffff); PORT##ref##_GPCLR = (((pins) << 16) | chars | PORT_MUX_GPIO);  _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_PORT_INPUT_FAST_HIGH(ref, pins, chars) SIM_SCGC5 |= SIM_SCGC5_PORT##ref; GPIO##ref##_PDDR &= ~((pins) & 0xffff0000); PORT##ref##_GPCHR = (((pins) & 0xffff0000) | chars | PORT_MUX_GPIO); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
#endif

// Configure a peripheral function eg. _CONFIG_PERIPHERAL(B, 2, (PB_2_FTM0_CH0 | PORT_SRE_FAST | PORT_DSE_HIGH));
//
#if defined KINETIS_KE
    #define _CONFIG_PERIPHERAL(port, pin, function) _SIM_PER_CHANGE      // dummy since the peripherals automatically configures their peripheral pins
#else
    #define _CONFIG_PERIPHERAL(port, pin, function) SIM_SCGC5 |= SIM_SCGC5_PORT##port; PORT##port##_PCR##pin = function; _SIM_PER_CHANGE
#endif

// Write to a port with a mask eg. eg. _WRITE_PORT_MASK(C, 0x1234,  0x0000ffff)
//
#if defined FGPIO_AVAILABLE
    #define _WRITE_PORT_MASK(ref, value, mask) FGPIO##ref##_PDOR = ((FGPIO##ref##_PDOR & ~(mask)) | (value)); _SIM_PORT_CHANGE
#else
    #define _WRITE_PORT_MASK(ref, value, mask) GPIO##ref##_PDOR = ((GPIO##ref##_PDOR & ~(mask)) | (value)); _SIM_PORT_CHANGE
#endif

// Write full port width eg. _WRITE_PORT_MASK(C, 0x12345678)
//
#if defined FGPIO_AVAILABLE
    #define _WRITE_PORT(ref, value)        FGPIO##ref##_PDOR = (value); _SIM_PORT_CHANGE
#else
    #define _WRITE_PORT(ref, value)        GPIO##ref##_PDOR = (value); _SIM_PORT_CHANGE
#endif

// Toggle a port with a mask eg. _TOGGLE_PORT(D, PORTD_BIT3)
//
#if defined FGPIO_AVAILABLE
    #define _TOGGLE_PORT(ref, mask)        FGPIO##ref##_PTOR = (mask); _SIM_PORT_CHANGE
#else
    #define _TOGGLE_PORT(ref, mask)        GPIO##ref##_PTOR = (mask); _SIM_PORT_CHANGE
#endif

// Read full port width eg. _READ_PORT(A)
//
#define _READ_PORT(ref)                    (GPIO##ref##_PDIR)

// Read from a port with a mask eg. _READ_PORT(D, (PORTD_BIT3 | PORTD_BIT0))
//
#define _READ_PORT_MASK(ref, mask)         (GPIO##ref##_PDIR & (mask))

// Configure outputs, including enabling clock to specified port, and then set a value to them - this device sets the value and then drives
// eg. _CONFIG_DRIVE_PORT_OUTPUT_VALUE(C, (PORTC_BIT13), (PORTC_BIT13), (PORT_SRE_SLOW | PORT_DSE_HIGH))
//
#if defined KINETIS_KE
    #define _CONFIG_DRIVE_PORT_OUTPUT_VALUE(ref, pins, value, chars) GPIO##ref##_PIDR &= ~(pins); GPIO##ref##_PDOR = ((GPIO##ref##_PDOR & ~(pins)) | (value)); fnConnectGPIO(PORT##ref, pins, (PORT_MUX_GPIO | chars)); GPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_LOW(ref, pins, value, chars) _CONFIG_DRIVE_PORT_OUTPUT_VALUE(ref, pins, value, chars)
    #define _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_HIGH(ref, pins, value, chars) _CONFIG_DRIVE_PORT_OUTPUT_VALUE(ref, pins, value, chars)
#else
    #define _CONFIG_DRIVE_PORT_OUTPUT_VALUE(ref, pins, value, chars) SIM_SCGC5 |= SIM_SCGC5_PORT##ref; fnConnectGPIO(PORT##ref, pins, (PORT_MUX_GPIO | chars)); GPIO##ref##_PDOR = ((GPIO##ref##_PDOR & ~(pins)) | (value)); GPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE; _SIM_PER_CHANGE
    #define _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_LOW(ref, pins, value, chars) SIM_SCGC5 |= SIM_SCGC5_PORT##ref; PORT##ref##_GPCLR = (((pins) << 16) | (chars | PORT_MUX_GPIO)); GPIO##ref##_PDOR = ((GPIO##ref##_PDOR & ~((pins) & 0x0000ffff)) | ((value) & 0x0000ffff)); GPIO##ref##_PDDR |= ((pins) & 0x0000ffff); _SIM_PORT_CHANGE; _SIM_PER_CHANGE // {12}
    #define _CONFIG_DRIVE_PORT_OUTPUT_VALUE_FAST_HIGH(ref, pins, value, chars) SIM_SCGC5 |= SIM_SCGC5_PORT##ref; PORT##ref##_GPCHR = (((pins) & 0xffff0000) | (chars | PORT_MUX_GPIO)); GPIO##ref##_PDOR = ((GPIO##ref##_PDOR & ~((pins) & 0xffff0000)) | ((value) & 0xffff0000)); GPIO##ref##_PDDR |= ((pins) & 0xffff0000); _SIM_PORT_CHANGE; _SIM_PER_CHANGE // {12}{39}
#endif

// Set from inputs to outputs and set a value to them - this is equivalent to _CONFIG_DRIVE_PORT_OUTPUT_VALUE on this device
//
#if defined FGPIO_AVAILABLE
    #define _DRIVE_PORT_OUTPUT_VALUE(ref, pins, value)  FGPIO##ref##_PDOR = ((FGPIO##ref##_PDOR & ~(pins)) | (value)); FGPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE
#else
    #define _DRIVE_PORT_OUTPUT_VALUE(ref, pins, value)  GPIO##ref##_PDOR = ((GPIO##ref##_PDOR & ~(pins)) | (value)); GPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE
#endif

// Set from outputs to inputs eg. _FLOAT_PORT(A, LCD_BUS_BITS)
//
#if defined FGPIO_AVAILABLE
    #define _FLOAT_PORT(ref, pins)         FGPIO##ref##_PDDR &= ~(pins); _SIM_PORT_CHANGE
#else
    #define _FLOAT_PORT(ref, pins)         GPIO##ref##_PDDR &= ~(pins); _SIM_PORT_CHANGE
#endif

// Set from inputs to outputs eg. _DRIVE_PORT_OUTPUT(A, LCD_BUS_BITS)
//
#if defined FGPIO_AVAILABLE
    #define _DRIVE_PORT_OUTPUT(ref, pins)  FGPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE
#else
    #define _DRIVE_PORT_OUTPUT(ref, pins)  GPIO##ref##_PDDR |= (pins); _SIM_PORT_CHANGE
#endif
// Set and clear individual bits of a port eg. _SETBITS(B, (PORTB_BIT5 | PORTB_BIT19)) / _CLEARBITS(B, (PORTB_BIT5 | PORTB_BIT19))
//
#if defined FGPIO_AVAILABLE
    #define _SETBITS(ref, pins)            FGPIO##ref##_PSOR = (pins); _SIM_PORT_CHANGE
    #define _CLEARBITS(ref, pins)          FGPIO##ref##_PCOR = (pins); _SIM_PORT_CHANGE
#else
    #define _SETBITS(ref, pins)            GPIO##ref##_PSOR = (pins); _SIM_PORT_CHANGE
    #define _CLEARBITS(ref, pins)          GPIO##ref##_PCOR = (pins); _SIM_PORT_CHANGE
#endif


// Miscellaneous Control Module                                          {29}
//
#define MCM_PLASC                        *(volatile unsigned short *)(MCM_BLOCK + 0x08)   // crossbar switch (AXBS) slave configuration (read-only)
#define MCM_PLAMC                        *(volatile unsigned short *)(MCM_BLOCK + 0x0a)   // crossbar switch (AXBS) master configuration (read-only)
#if defined KINETIS_K02
    #define MCM_PLACR                    *(unsigned long *)(MCM_BLOCK + 0x0c)   // crossbar switch control register
      #define MCM_PLACR_ARB_FIXED_PRIORITY 0x00000000
      #define MCM_PLACR_ARB_ROUND_ROBIN    0x00000200                    // round-robin arbitration for crossbar masters rather than fixed priority
    #define MCM_ISCR                     *(volatile unsigned long *)(MCM_BLOCK + 0x10)   // interrupt status and control register (read-only)
    #define MCM_CPO                      *(unsigned long *)(MCM_BLOCK + 0x40)   // compute operation control register
#else
    #define MCM_CR                       *(unsigned long *)(MCM_BLOCK + 0x0c)   // control register
      #define MCM_CR_DDR_SIZE_DISABLED   0x00000000
      #define MCM_CR_DDR_SIZE_128MB      0x00010000
      #define MCM_CR_DDR_SIZE_256MB      0x00020000
      #define MCM_CR_DDR_SIZE_512MB      0x00030000
    #define MCM_ISR                      *(volatile unsigned long *)(MCM_BLOCK + 0x10)   // Interrupt Status Register
    #define MCM_ETBCC                    *(unsigned long *)(MCM_BLOCK + 0x14)   // ETB Counter Control Register
    #define MCM_ETBRL                    *(unsigned long *)(MCM_BLOCK + 0x18)   // ETB Reload Register
    #define MCM_ETBCNT                   *(volatile unsigned long *)(MCM_BLOCK + 0x1c)   // ETB Counter Value Register
    #define MCM_PID                      *(unsigned long *)(MCM_BLOCK + 0x30)   // Process ID Register
#endif

// Memory-Mapped Cryptographic Accelerator Unit                          {45}
//
#if defined _WINDOWS
    #define _OFFSET_0 0x00
    #define _OFFSET_1 0x04
    #define _OFFSET_2 0x08
    #define _OFFSET_3 0x0c
    #define _OFFSET_4 0x10
    #define _OFFSET_5 0x14
    #define _OFFSET_6 0x18
    #define _OFFSET_7 0x1c
    #define _OFFSET_8 0x20
    #define _OFFSET_9 0x24
    #define _OFFSET_A 0x28
#else
    #define _OFFSET_0 0x00
    #define _OFFSET_1 0x01
    #define _OFFSET_2 0x02
    #define _OFFSET_3 0x03
    #define _OFFSET_4 0x04
    #define _OFFSET_5 0x05
    #define _OFFSET_6 0x06
    #define _OFFSET_7 0x07
    #define _OFFSET_8 0x08
    #define _OFFSET_9 0x09
    #define _OFFSET_A 0x0a
#endif
#define CAU_CASR                         *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_0)   // status register
  #define CAU_CASR_IC                    0x00000001                      // illegal command
  #define CAU_CASR_DPE                   0x00000002                      // DES parity error
  #define CAU_CASR_VER_MASK              0xf0000000                      // CAU version mask
    #if defined CAU_V1_AVAILABLE
      #define CAU_CASR_VER               0x10000000                      // CAU version 1
    #elif defined CAU_V2_AVAILABLE
      #define CAU_CASR_VER               0x20000000                      // CAU version 2 (adds SHA-256 algorithm)
    #endif
#define CAU_CAA                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_1)   // accumulator
#define CAU_CA0                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_2)   // general purpose register 0
#define CAU_CA1                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_3)   // general purpose register 1
#define CAU_CA2                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_4)   // general purpose register 2
#define CAU_CA3                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_5)   // general purpose register 3
#define CAU_CA4                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_6)   // general purpose register 4
#define CAU_CA5                          *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_7)   // general purpose register 5
#if defined CAU_V2_AVAILABLE
    #define CAU_CA6                      *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_8)   // general purpose register 6
    #define CAU_CA7                      *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_9)   // general purpose register 7
    #define CAU_CA8                      *(volatile unsigned short *)(MMCAU_BLOCK + _OFFSET_A)   // general purpose register 8
#endif

// Macro to clear flags by writing '1' to the bit
//
#if defined _WINDOWS                                                     // clear when simulating
    #define WRITE_ONE_TO_CLEAR(reg, flag)    reg &= ~(flag)
#else
    #define WRITE_ONE_TO_CLEAR(reg, flag)    reg = (flag)
#endif


// Software references used when setting up interrupts
//
#define PORT_INTERRUPT            0
#define TIMER_INTERRUPT           1
#define PIT_INTERRUPT             2
#define PWM_INTERRUPT             3
#define ADC_INTERRUPT             4                                      // {6}
#define DAC_INTERRUPT             5                                      // {23}
#define PDB_INTERRUPT             6                                      // {37}
#define LPTMR_INTERRUPT           7                                      // {51}
#define KEYBOARD_INTERRUPT        8
#define WAKEUP_INTERRUPT          9
#define I2S_SAI_INTERRUPT         10

#define TIMER_SINGLE_SHOT         0x0000
#define TIMER_PWM_MAT0            0x0001
#define TIMER_PWM_MAT1            0x0002
#define TIMER_PWM_MAT2            0x0004
#define TIMER_PERIODIC            0x0010
#define TIMER_MS_VALUE            0x0000
#define TIMER_US_VALUE            0x0020
#define TIMER_STOP_PWM_MAT0       0x0040
#define TIMER_STOP_PWM_MAT1       0x0080
#define TIMER_STOP_PWM_MAT2       0x0100
#define TIMER_DONT_DISTURB        0x0200
#define TIMER_EXT_CLK_0           0x0400                                 // {89}
#define TIMER_EXT_CLK_1           0x0800
#define TIMER_DMA_TRIGGER         0x4000
#define TIMER_STOP                0x8000


#if defined KINETIS_KL
    #if defined TPM_CLOCKED_FROM_OSCERCLK                                // {55}
        #define TIMER_CLOCK       (OSCERCLK)
    #elif defined TPM_CLOCKED_FROM_MCGIRCLK
        #define TIMER_CLOCK       (MCGIRCLK)
    #else
        #if defined KINETIS_HAS_IRC48M                                   // {82}
            #define TIMER_CLOCK   (48000000)
        #elif defined FLL_FACTOR
            #define TIMER_CLOCK   (MCGFLLCLK)
        #else
            #define TIMER_CLOCK   (MCGPLLCLK/2)
        #endif
    #endif
    #define PWM_CLOCK             TIMER_CLOCK
#elif defined KINETIS_KE
    #if (defined KINETIS_KE04 || defined KINETIS_KE06 || defined KINETIS_KEA8 || defined KINETIS_KEA64 || defined KINETIS_KEA128)
        #if defined TIMER_CLOCK_DIVIDE_2
		    #define TIMER_CLOCK   (ICSOUT_CLOCK/2)
        #else
		    #define TIMER_CLOCK   (ICSOUT_CLOCK)
        #endif
    #else
		#define TIMER_CLOCK       (BUS_CLOCK)
    #endif
    #define PWM_CLOCK             (TIMER_CLOCK)
#else
    #define TIMER_CLOCK           (BUS_CLOCK)
    #define PWM_CLOCK             (SYSTEM_CLOCK/2)
#endif

// FlexTimer delays
//
#define TIMER_MS_DELAY(msec)           ((TIMER_CLOCK/1000) * msec)
#define TIMER_US_DELAY(usec)           ((TIMER_CLOCK/1000000) * usec)
#define TIMER_FREQUENCY_VALUE(hertz)   (1000000/hertz)

typedef struct stPWM_INTERRUPT_SETUP
{
    void             (*int_handler)(void);                               // interrupt handler to be configured (0 to disable PWM time base interrupt)
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // interrupt priority the user wants to set
    unsigned char    pwm_reference;                                      // PWM channel to be used (0..7)
    unsigned short   pwm_value;                                          // PWM percentage value
    unsigned short   pwm_frequency;                                      // base frequency
    unsigned short   pwm_mode;                                           // PWM mode of operation
    #if !defined DEVICE_WITHOUT_DMA
        unsigned long    ulPWM_buffer_length;                            // length of the buffer used for DMA transfer to PWM
        void             (*dma_int_handler)(void);                       // DMA interrupt handler to be configured
        unsigned short  *ptrPWM_Buffer;                                  // source buffer for DMA transfer to PWM
        unsigned char    dma_int_priority;                               // DMA interrupt priority the user wants to set
        unsigned char    ucDmaChannel;                                   // DMA channel to be used
        unsigned char    ucDmaTriggerSource;                             // source used to trigger DMA transfer
    #endif
} PWM_INTERRUPT_SETUP;

#define _TIMER_0                0x00                                     // used together with pwm_reference to specify the FTM used
#define _TIMER_1                0x20
#define _TIMER_2                0x40
#define _TIMER_3                0x60
#define _TPM_TIMER_1            0x80
#define _TPM_TIMER_2            0xa0
#define _TIMER_MODULE_MASK      0xe0
#define _TIMER_MODULE_SHIFT     5

#define PWM_PRESCALER_128       0x0007
#define PWM_PRESCALER_64        0x0006
#define PWM_PRESCALER_32        0x0005
#define PWM_PRESCALER_16        0x0004
#define PWM_PRESCALER_8         0x0003
#define PWM_PRESCALER_4         0x0002
#define PWM_PRESCALER_2         0x0001
#define PWM_PRESCALER_1         0x0000
#define PWM_PRESCALER_0         0x0000
#define PWM_CENTER_ALIGNED      FTM_SC_CPWMS                             // 0x20
#define PWM_EXTERNAL_CLK        FTM_SC_CLKS_EXT                          // 0x18
#define PWM_FIXED_CLK           FTM_SC_CLKS_FIX                          // 0x10 presently not supported
#define PWM_SYS_CLK             FTM_SC_CLKS_SYS                          // 0x08
#define PWM_IRC48M_CLK          FTM_SC_CLKS_SYS                          // for use by device with IRC48M
#define PWM_POLARITY            0x0080
#define PWM_DMA_PERIOD_ENABLE   FTM_SC_DMA                               // 0x100 (only valid for KL)
#define PWM_FULL_BUFFER_DMA     0x0200
#define PWM_HALF_BUFFER_DMA     0x0400
#define PWM_FULL_BUFFER_DMA_AUTO_REPEAT 0x0800
#define PWM_NO_OUTPUT           0x1000                                   // {93} run PWM without connecting it to a physical output (for internal timing, for example triggering ADCs)
#define PWM_DMA_CHANNEL_ENABLE  0x2000                                   // {93} enable the channel to trigger DMA
#define PWM_DMA_CONTROL_PWM     0x0000
#define PWM_DMA_CONTROL_FREQUENCY 0x4000

#define PWM_MODE_SETTINGS_MASK  (PWM_PRESCALER_128 | FTM_SC_CPWMS | FTM_SC_CLKS_EXT | FTM_SC_CLKS_SYS | PWM_DMA_PERIOD_ENABLE)

#define PWM_FREQUENCY(frequency, prescaler)  (PWM_CLOCK/prescaler/frequency) // {83}
#if (((PWM_CLOCK/1000000) * 1000000) != PWM_CLOCK)                       // if the clock is not an exact MHz value
    #define PWM_TIMER_US_DELAY(usec, prescaler)  ((unsigned long)(((double)PWM_CLOCK/(double)1000000) * usec)/prescaler)
#else
    #define PWM_TIMER_US_DELAY(usec, prescaler)  (((PWM_CLOCK/1000000) * usec)/prescaler)
#endif
#define PWM_TIMER_MS_DELAY(msec, prescaler)  (((PWM_CLOCK/1000) * msec)/prescaler)

#define _PWM_PERCENT(percent_pwm, frequency_value)       (unsigned short)((frequency_value * percent_pwm)/100)
#define _PWM_TENTH_PERCENT(percent_pwm, frequency_value) (unsigned short)((frequency_value * percent_pwm)/1000)



// Define interrupt setup structures to suit this processor
//
typedef struct stINTERRUPT_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured - a return value of 1 causes the level sensitive source to re cleared on return
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    int_port_bits;                                      // the input bits to be configured to generate this interrupt
    unsigned short   int_port_sense;                                     // PULLUP_ON, PULLDOWN_ON, PULLUP_DOWN_OFF, IRQ_RISING_EDGE etc.
    unsigned char    int_port;                                           // the port (PORT_A..PORT_E)
} INTERRUPT_SETUP;


typedef struct stLPTMR_SETUP                                             // {51}
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned short   mode;                                               // periodic or single shot as well as trigger options
    unsigned short   count_delay;                                        // the delay value (16 bit)
    unsigned char    ucTimer;                                            // low power timer reference
} LPTMR_SETUP;

#define LPTMR_PERIODIC       0x0001
#define LPTMR_SINGLE_SHOT    0x0002
#define LPTMR_TRIGGER_ADC0_A 0x0004
#define LPTMR_TRIGGER_ADC0_B 0x0008
#define LPTMR_TRIGGER_ADC1_A 0x0010
#define LPTMR_TRIGGER_ADC1_B 0x0020
#define LPTMR_TRIGGER_ADC2_A 0x0040
#define LPTMR_TRIGGER_ADC2_B 0x0080
#define LPTMR_TRIGGER_ADC3_A 0x0100
#define LPTMR_TRIGGER_ADC3_B 0x0200
#define LPTMR_STOP           0x8000

#if defined LPTMR_CLOCK_LPO                                              // define the low power clock speed for calculations
    #define LPTMR_CLOCK (1000)
#elif defined LPTMR_CLOCK_INTERNAL_30_40kHz
    #define LPTMR_CLOCK (35000)
#elif defined LPTMR_CLOCK_INTERNAL_4MHz
    #define LPTMR_CLOCK (4000000)
#elif defined LPTMR_CLOCK_EXTERNAL_32kHz
    #define LPTMR_CLOCK (32768)
#else                                                                    // LPTMR_CLOCK_OSCERCLK
    #if defined LPTMR_PRESCALE
        #define LPTMR_CLOCK ((_EXTERNAL_CLOCK)/LPTMR_PRESCALE)
    #else
        #define LPTMR_CLOCK (_EXTERNAL_CLOCK)
    #endif
#endif

#if LPTMR_CLOCK < 0xffff
    #define LPTMR_US_DELAY(us_delay)  (((us_delay * LPTMR_CLOCK)/1000000) - 1) // macros for setting LPTMR interrupt times
    #define LPTMR_MS_DELAY(ms_delay)  (((ms_delay * LPTMR_CLOCK)/1000) - 1)
#else
    #define LPTMR_US_DELAY(us_delay)  (((us_delay * (LPTMR_CLOCK/1000))/1000) - 1) // macros for setting LPTMR interrupt times
    #define LPTMR_MS_DELAY(ms_delay)  ((ms_delay * (LPTMR_CLOCK/1000)) - 1) 
#endif
#define LPTMR_S_DELAY(s_delay)        (s_delay * LPTMR_CLOCK) - 1)


typedef struct stI2S_SAI_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    ulI2S_SAI_buffer_length;
    unsigned char    I2S_SAI_mode;
    unsigned char    ucDmaChannel;
    unsigned char    ucDmaTriggerSource;
    unsigned char    ucSynchBits;
    void            *ptrI2S_SAI_Buffer;
} I2S_SAI_SETUP;

#define I2S_SAI_CONFIG_TX                   0x01
#define I2S_SAI_CONFIG_RX                   0x02
#define I2S_SAI_FULL_BUFFER_DMA             0x04
#define I2S_SAI_HALF_BUFFER_DMA             0x08
#define I2S_SAI_BUFFER_DMA_START            0x10
#define I2S_SAI_FULL_BUFFER_DMA_AUTO_REPEAT 0x20
#define I2S_SAI_ENABLE_TX                   0x40
#define I2S_SAI_ENABLE_RX                   0x80


typedef struct stPIT_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    count_delay;                                        // the delay value
    #if !defined DEVICE_WITHOUT_DMA
    unsigned long    ulPortBits;                                         // optional port bits toggled by PIT DMA trigger
    #endif
    unsigned short   mode;                                               // periodic or single shot
    unsigned char    ucPIT;                                              // PIT reference
    #if !defined DEVICE_WITHOUT_DMA
    unsigned char    ucPortRef;                                          // optional port toggled by PIT DMA trigger
    #endif
} PIT_SETUP;

#define PIT_SINGLE_SHOT     0x0001                                        // configure for single interrupt
#define PIT_PERIODIC        0x0002                                        // configure for periodic interrupt
#define PIT_RETRIGGER       0x0004                                        // {5} force PIT load when periodic
#define PIT_TRIGGER_ADC0_A  0x0008
#define PIT_TRIGGER_ADC0_B  0x0010
#define PIT_TRIGGER_ADC1_A  0x0020
#define PIT_TRIGGER_ADC1_B  0x0040
#define PIT_TRIGGER_ADC2_A  0x0080
#define PIT_TRIGGER_ADC2_B  0x0100
#define PIT_TRIGGER_ADC3_A  0x0200
#define PIT_TRIGGER_ADC3_B  0x0400
#define PIT_OUTPUT_DMA_TRIG 0x4000
#define PIT_STOP            0x8000                                        // stop operation

#define PIT_US_DELAY(us_delay)  ((((us_delay) * (BUS_CLOCK/1000))/1000) - 1) // macros for setting PIT interrupt times
#define PIT_MS_DELAY(ms_delay)  (((ms_delay) * (BUS_CLOCK/1000)) - 1) 
#define PIT_S_DELAY(s_delay)    (((s_delay) * (BUS_CLOCK)) - 1)

#define PIT_FREERUN_FREQ(Hz)    ((BUS_CLOCK/(Hz)) - 1)

typedef struct stTIMER_INTERRUPT_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    timer_value;                                        // the delay value
    unsigned short   timer_mode;                                         // timer mode
    unsigned char    timer_reference;                                    // hardware timer to use (0, 1, 2, 3)
} TIMER_INTERRUPT_SETUP;

#define PORTA                0
#define PORTB                1
#define PORTC                2
#define PORTD                3
#define PORTE                4
#define PORTF                5                                           // {18}

#define PORT_MODULE          0xff                                        // used for module referencing rather than ports

#define PULLUP_DOWN_OFF      0x0001
#define PULLUP_ON            0x0002 
#define PULLDOWN_ON          0x0004
#define IRQ_RISING_EDGE      0x0008
#define IRQ_FALLING_EDGE     0x0010
#define IRQ_BOTH_EDGES       (IRQ_RISING_EDGE | IRQ_FALLING_EDGE)
#define IRQ_DISABLE_INT      0x0020
#define IRQ_LOW_LEVEL        0x0040
#define IRQ_HIGH_LEVEL       0x0080
#define ENABLE_PORT_MODE     0x0100                                      // pull-ups are not valid if the port is disabled so allow the pin's GPIO mode to be set if desired
#define PORT_DMA_MODE        0x0200                                      // {72} use port DMA mode rather than interrupt mode
#define PORT_KEEP_PERIPHERAL 0x0400                                      // {72} keep the configured peripheral function and don't change to an input

#define MODULE_LPTMR0        0x01
#define MODULE_COMP0         0x02
#define MODULE_TSI0          0x10
#define MODULE_RTC_ALARM     0x20
#define MODULE_RTC_SECONDS   0x80

#define WAKEUP_MODULES       (MODULE_LPTMR0 | MODULE_COMP0 | MODULE_TSI0 | MODULE_RTC_ALARM | MODULE_RTC_SECONDS)


typedef struct stRTC_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned short   usYear;
    unsigned char    ucMonthOfYear;
    unsigned char    ucDayOfMonth;
    unsigned char    ucDayOfWeek;
    unsigned char    ucHours;
    unsigned char    ucMinutes;
    unsigned char    ucSeconds;
    unsigned char    command;                                            // identifier for command to perform
    unsigned long    ulLocalUTC;                                         // {24} optional UTC field
} RTC_SETUP;


#define RTC_TIME_SETTING     0x01
#define RTC_TICK_SEC         0x02
#define RTC_TICK_MIN         0x03
#define RTC_TICK_HOUR        0x04
#define RTC_TICK_DAY         0x05
#define RTC_ALARM_TIME       0x06
#define RTC_STOPWATCH_GO     0x07
#define RTC_GET_TIME         0x08
#define RTC_CONVERT_TO_UTC   0x09                                        // {24}
#define RTC_CONVERT_FROM_UTC 0x0a                                        // {24}
#define RTC_GET_ALARM        0x0b
#define RTC_INCREMENT        0x10                                        // used by software RTC
#define RTC_SET_UTC          0x20                                        // {24} use UTC rather than time and date when setting
#define RTC_INITIALISATION   0x40
#define RTC_RETURNED_TIME    0x80
#define RTC_DISABLE          0x80


typedef struct stADC_INTERRUPT_RESULT                                    // {6}
{
    signed short     sADC_value;                                         // present ADC sample value
    unsigned char    ucADC_channel;                                      // ADC channel status
    unsigned char    ucADC_flags;                                        // flags
} ADC_INTERRUPT_RESULT;

#if defined KINETIS_KE
    #define ADC_CHANNELS          16                                     // single ended inputs 
#else
    #define ADC_CHANNELS          24                                     // single ended inputs               
    #define ADC_CHANNELS_DIF      4                                      // differential inputs
#endif

typedef struct stADC_RESULTS
{
    signed short     sADC_value[ADC_CHANNELS];                           // present ADC sample values
    unsigned char    ucADC_status[ADC_CHANNELS];                         // present ADC channel status
} ADC_RESULTS;

// Define interrupt setup structure to suit this processor
//
typedef struct stADC_SETUP
{
    void (*int_handler)(ADC_INTERRUPT_RESULT *);                         // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set
    unsigned char    int_adc_bit;                                        // the ADC input number (0..31)
    unsigned char    int_adc_int_type;                                   // interrupt type (ADC_END_OF_SCAN_INT, ADC_ZERO_CROSSING_INT, ADC_LOW_LIMIT_INT, ADC_HIGH_LIMIT_INT)
    unsigned long    int_adc_mode;                                       // parallel, sequencial, single-ended, differential, start/stop, etc.
    unsigned short   int_adc_offset;                                     // offset for input
    unsigned short   int_high_level_trigger;                             // trigger when higher than this level
    unsigned short   int_low_level_trigger;                              // trigger when lower than this level
    #if !defined KINETIS_KE
        unsigned char    int_adc_sample;                                 // sampling details
        unsigned char    pga_gain;                                       // {35} PGA gain setting
        unsigned char    int_adc_bit_b;                                  // {57} the ADC channel B input number (used only in hardware mode with double trigger)
    #endif
    unsigned char    int_adc_controller;                                 // the ADC controller to be used
    ADC_RESULTS     *int_adc_result;                                     // results structure to be filled
    #if !defined DEVICE_WITHOUT_DMA
        void (*dma_int_handler)(void);                                   // interrupt handler to be configured for buffer operation
        unsigned long    ulADC_buffer_length;                            // {36} buffer length
        signed short    *ptrADC_Buffer;                                  // {36} if DMA is specified this is a pointer to the buffer in which the samples will be saved to
        unsigned char    ucDmaChannel;                                   // {36} DMA channel to be used
        unsigned char    ucDmaTriggerSource;                             // {94} DMA trigger souce (0 defaults to the channel's ADC conversion completion)
        unsigned char    dma_int_priority;                               // priority the user wants to set for DMA completion interrupt
    #endif
} ADC_SETUP;

#define ADC_FULL_SCALE                  (0xffff)
#define ADC_VOLT                        (unsigned short)((ADC_FULL_SCALE * 1000) / ADC_REFERENCE_VOLTAGE)

#define ADC_ENABLE_INTS                 0x00
#define ADC_END_OF_SCAN_INT             0x01
#define ADC_ZERO_CROSSING_INT_POSITIVE  0x02
#define ADC_ZERO_CROSSING_INT_NEGATIVE  0x04
#define ADC_LOW_LIMIT_INT               0x08
#define ADC_SINGLE_SHOT_CROSSING_INT    0x10
#define ADC_HIGH_LIMIT_INT              0x20
#define ADC_SINGLE_SHOT_TRIGGER_INT     0x40
#define ADC_DISABLE_INTS                0x80


#define ADC_SAMPLE_LONG_PLUS_20         0x00                             // ADC_CFG2_ADLSTS_20
#define ADC_SAMPLE_LONG_PLUS_12         0x01                             // ADC_CFG2_ADLSTS_12
#define ADC_SAMPLE_LONG_PLUS_6          0x02                             // ADC_CFG2_ADLSTS_6
#define ADC_SAMPLE_LONG_PLUS_2          0x03                             // ADC_CFG2_ADLSTS_2
#define ADC_SAMPLE_HIGH_SPEED_CONFIG    0x04                             // ADC_CFG2_ADHSC
#define ADC_SAMPLE_AVERAGING_OFF        0x00
#define ADC_SAMPLE_AVERAGING_4          0x40                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_4) << 4)
#define ADC_SAMPLE_AVERAGING_8          0x50                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_8) << 4)
#define ADC_SAMPLE_AVERAGING_16         0x60                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_16) << 4)
#define ADC_SAMPLE_AVERAGING_32         0x70                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_32) << 4)


#define ADC_CLOCK_BUS                   0x00000000                       // ADC_CFG1_ADICLK_BUS
#define ADC_CLOCK_BUS_DIV_2             0x00000001                       // ADC_CFG1_ADICLK_BUS2
#define ADC_CLOCK_ALTERNATE_SOURCE      0x00000002                       // ADC_CFG1_ADICLK_ALT
#define ADC_CLOCK_ASYNCHRONOUS          0x00000003                       // ADC_CFG1_ADICLK_ASY
#define ADC_8_BIT_MODE                  0x00000000                       // ADC_CFG1_MODE_8
#if defined KINETIS_KE
    #define ADC_10_BIT_MODE             0x00000004                       // ADC_CFG1_MODE_10
    #define ADC_12_BIT_MODE             0x00000008                       // ADC_CFG1_MODE_12
#else
    #define ADC_12_BIT_MODE             0x00000004                       // ADC_CFG1_MODE_12
    #define ADC_10_BIT_MODE             0x00000008                       // ADC_CFG1_MODE_10
    #define ADC_16_BIT_MODE             0x0000000c                       // ADC_CFG1_MODE_16
#endif
#define ADC_SAMPLE_ACTIVATE_LONG        0x00000010                       // ADC_CFG1_ADLSMP_LONG
#define ADC_CLOCK_DIVIDE_1              0x00000000                       // ADC_CFG1_ADIV_1
#define ADC_CLOCK_DIVIDE_2              0x00000020                       // ADC_CFG1_ADIV_2
#define ADC_CLOCK_DIVIDE_4              0x00000040                       // ADC_CFG1_ADIV_4
#define ADC_CLOCK_DIVIDE_8              0x00000060                       // ADC_CFG1_ADIV_8
#define ADC_LOW_POWER_CONFIG            0x00000080                       // ADC_CFG1_ADLPC
#define ADC_REFERENCE_VREF              0x00000000
#define ADC_REFERENCE_VALT              0x00000100                       // (ADC_SC2_REFSEL_ALT << 8)
#define ADC_SW_TRIGGERED                0x00000000
#define ADC_HW_TRIGGERED                0x00004000                       // (ADC_SC2_ADTRG_HW << 8)
#define ADC_FULL_BUFFER_DMA_AUTO_REPEAT 0x00010000
#define ADC_CALIBRATE                   0x00100000
#define ADC_READ_ONLY                   0x00200000
#define ADC_CONFIGURE_CHANNEL           0x00400000
#define ADC_CONFIGURE_ADC               0x00800000
#define ADC_GET_RESULT                  0x01000000
#define ADC_DISABLE_ADC                 0x02000000
#define ADC_SINGLE_ENDED_INPUT          0x00000000
#define ADC_DIFFERENTIAL_INPUT          0x04000000
#define ADC_SINGLE_SHOT_MODE            0x00000000
#define ADC_LOOP_MODE                   0x08000000
#define ADC_SELECT_INPUTS_A             0x00000000                       // {33}
#define ADC_SELECT_INPUTS_B             0x10000000                       // {33}
#define ADC_FULL_BUFFER_DMA             0x20000000                       // {36}
#define ADC_HALF_BUFFER_DMA             0x40000000                       // {36}
#define ADC_DIFFERENTIAL_B              0x80000000                       // {57}

#define PGA_GAIN_OFF                    0                                // {35}
#define PGA_GAIN_1                      ((ADC_PGA_PGAG_1  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_2                      ((ADC_PGA_PGAG_2  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_4                      ((ADC_PGA_PGAG_4  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_8                      ((ADC_PGA_PGAG_8  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_16                     ((ADC_PGA_PGAG_16 | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_32                     ((ADC_PGA_PGAG_32 | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_64                     ((ADC_PGA_PGAG_64 | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_64                     ((ADC_PGA_PGAG_64 | ADC_PGA_PGAEN) >> 16)
#define PGA_RUNS_IN_LP_MODE             (ADC_PGA_PGALPb >> 16)
 

#define ADC_RESULT_NOT_READY            0x00
#define ADC_RESULT_VALID                0x01
#define ADC_INT_ZERO_CROSSING           0x02
#define ADC_INT_HIGH_LEVEL              0x04
#define ADC_INT_LOW_LEVEL               0x08

#define ADC_SAMPLING_SPEED(sample_rate) (((BUS_CLOCK/2)/sample_rate/2) - 1)

typedef struct stDAC_SETUP                                               // {23}
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set
    unsigned long    dac_mode;                                           // the mode of operation
    unsigned short  *ptrDAC_Buffer;                                      // {38} if DMA is specified this is a pointer to the buffer which supplies DAC output values
    unsigned long    ulDAC_buffer_length;                                // {38} buffer length
    unsigned short   usOutputValue;                                      // value to be output on the DAC output
    unsigned char    int_dac_controller;                                 // the controller to be used
    unsigned char    ucDmaChannel;                                       // {38} DMA channel to be used
    unsigned char    ucDmaTriggerSource;                                 // {74} DMA trigger source to be used
} DAC_SETUP;

// dac_mode
//
#define DAC_CONFIGURE                   0x00000001
#define DAC_REF_VREF                    0x00000000
#define DAC_REF_VDDA                    0x00000002                       // K parts
#define DAC_REF_VREF2                   0x00000002                       // KL parts
#define DAC_NON_BUFFERED_MODE           0x00000000                       // write to data[0] trigger conversion
#define DAC_BUFFERED_MODE               0x00000004
#define DAC_OUTPUT_VALUE                0x00000008
#define DAC_ENABLE                      0x00000040
#define DAC_DISABLE                     0x00000080
#define DAC_HALF_BUFFER_DMA             0x00000100                       // {38}
#define DAC_FULL_BUFFER_DMA             0x00000200                       // {38}
#define DAC_FULL_BUFFER_DMA_AUTO_REPEAT 0x00000400                       // automatically repeat transfers (not one-shot buffer - used by KL parts)
#define DAC_DMA_LINKING                 0x00000800                       // use two linked DMA channels to ensure no sample loss at high speeds (used by KL parts)
#define DAC_HW_TRIGGER_MODE             0x00001000
#define DAC_BUFFER_DMA_START            0x00002000


// Define interrupt setup structure to suit this processor
//
typedef struct stPDB_SETUP                                               // {37}
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set
    unsigned short   pdb_mode;                                           // PDB mode of operation
    unsigned short   period;                                             // set in value for Hertz using PDB_FREQUENCY()
    unsigned short   int_match;                                          // interrupt matched at this value
    unsigned short   ch0_delay_0;                                        // ADC0 channel A trigger position
    unsigned short   ch0_delay_1;                                        // ADC0 channel B trigger position
    unsigned short   ch1_delay_0;                                        // ADC1 channel A trigger position
    unsigned short   ch1_delay_1;                                        // ADC1 channel B trigger position
    unsigned short   ch2_delay_0;                                        // ADC2 channel A trigger position
    unsigned short   ch2_delay_1;                                        // ADC2 channel B trigger position
    unsigned short   ch3_delay_0;                                        // ADC3 channel A trigger position
    unsigned short   ch3_delay_1;                                        // ADC2 channel B trigger position
    unsigned short   dac0_delay_0;                                       // DAC0 trigger position
    unsigned short   dac1_delay_0;                                       // DAC1 trigger position
    unsigned char    prescaler;                                          // PDB_MUL and PDB_PRESECALER settings
    unsigned char    pdb_trigger;
} PDB_SETUP;

// pdb_mode
//
#define PDB_MONO_TIMER_INTERRUPT        0x0000
#define PDB_TRIGGER_ADC0_A              0x0001
#define PDB_TRIGGER_ADC0_B              0x0002
#define PDB_TRIGGER_ADC1_A              0x0004
#define PDB_TRIGGER_ADC1_B              0x0008
#define PDB_TRIGGER_ADC2_A              0x0010
#define PDB_TRIGGER_ADC2_B              0x0020
#define PDB_TRIGGER_ADC3_A              0x0040
#define PDB_TRIGGER_ADC3_B              0x0080
#define PDB_TRIGGER_DAC0                0x0100
#define PDB_TRIGGER_DAC1                0x0200
#define PDB_PERIODIC_DMA                0x4000
#define PDB_PERIODIC_INTERRUPT          0x8000

#define PDB_PRESCALER_1                 (unsigned char)(PDB_SC_PRESCALER_1   >> 12)
#define PDB_PRESCALER_2                 (unsigned char)(PDB_SC_PRESCALER_2   >> 12)
#define PDB_PRESCALER_4                 (unsigned char)(PDB_SC_PRESCALER_4   >> 12)
#define PDB_PRESCALER_8                 (unsigned char)(PDB_SC_PRESCALER_8   >> 12)
#define PDB_PRESCALER_16                (unsigned char)(PDB_SC_PRESCALER_16  >> 12)
#define PDB_PRESCALER_32                (unsigned char)(PDB_SC_PRESCALER_32  >> 12)
#define PDB_PRESCALER_64                (unsigned char)(PDB_SC_PRESCALER_64  >> 12)
#define PDB_PRESCALER_128               (unsigned char)(PDB_SC_PRESCALER_128 >> 12)

#define PDB_MUL_1                       (PDB_SC_MULT_1  << 4)
#define PDB_MUL_10                      (PDB_SC_MULT_10 << 4)
#define PDB_MUL_20                      (PDB_SC_MULT_20 << 4)
#define PDB_MUL_40                      (PDB_SC_MULT_40 << 4)

#define PDB_TRIGGER_SW                  (unsigned char)(PDB_SC_TRGSEL_SW >> 8)
#define PDB_TRIGGER_EXTERN              (unsigned char)(PDB_SC_TRGSEL_0  >> 8)
#define PDB_TRIGGER_PIT0                (unsigned char)(PDB_SC_TRGSEL_4  >> 8)
#define PDB_TRIGGER_PIT1                (unsigned char)(PDB_SC_TRGSEL_5  >> 8)
#define PDB_TRIGGER_PIT2                (unsigned char)(PDB_SC_TRGSEL_6  >> 8)
#define PDB_TRIGGER_PIT3                (unsigned char)(PDB_SC_TRGSEL_7  >> 8)
#define PDB_TRIGGER_CMP0                (unsigned char)(PDB_SC_TRGSEL_1  >> 8)
#define PDB_TRIGGER_CMP1                (unsigned char)(PDB_SC_TRGSEL_2  >> 8)
#define PDB_TRIGGER_CMP2                (unsigned char)(PDB_SC_TRGSEL_3  >> 8)
#define PDB_TRIGGER_FTM0                (unsigned char)(PDB_SC_TRGSEL_8  >> 8)
#define PDB_TRIGGER_FTM1                (unsigned char)(PDB_SC_TRGSEL_9  >> 8)
#define PDB_TRIGGER_FTM2                (unsigned char)(PDB_SC_TRGSEL_10 >> 8)
#define PDB_TRIGGER_RTC_ALARM           (unsigned char)(PDB_SC_TRGSEL_12 >> 8)
#define PDB_TRIGGER_RTC_SECONDS         (unsigned char)(PDB_SC_TRGSEL_13 >> 8)
#define PDB_TRIGGER_RTC_LPTMR           (unsigned char)(PDB_SC_TRGSEL_14 >> 8)

#define PDB_FREQUENCY(prescaler, mul, hz) ((BUS_CLOCK/((prescaler) * (mul))/(hz)) - 1) // period match value


/************************************************************************************************/

extern void fnEnterInterrupt(int iInterruptID, unsigned char ucPriority, void (*InterruptFunc)(void)); // {34}
extern void fnClearPending(int iInterruptID);                            // {90}
extern int  fnIsPending(int iInterruptID);                               // {90}

// Cortex M4 private registers
//
// NVIC
//
#define INT_CONT_TYPE               *(const unsigned long *)(CORTEX_M4_BLOCK + 0x04)   // NVIC Interrupt Controller Type Register (read only)
#if defined KINETIS_KL || defined KINETIS_KE
    #define __NVIC_PRIORITY_SHIFT   6                                    // 4 levels of priority so shifted by (8 - 2 (number of implemented bits))
#else
    #define __NVIC_PRIORITY_SHIFT   4                                    // 16 levels of priority so shifted by (8 - 4 (number of implemented bits))
#endif

// SYSTICK
//
#define SYSTICK_CSR                 *(volatile unsigned long *)(CORTEX_M4_BLOCK + 0x10) // SYSTICK Control and Status Register
  #define SYSTICK_ENABLE            0x00000001                           // enable SYSTICK counter
  #define SYSTICK_TICKINT           0x00000002                           // interrupt on counter reload (reaching zero)
  #define SYSTICK_CORE_CLOCK        0x00000004                           // choose core clock as opposed to external reference clock
  #define SYSTICK_COUNTFLAG         0x00010000                           // '1' if the timer counted to 0 since the last time this register was read
#define SYSTICK_RELOAD              *(unsigned long *)(CORTEX_M4_BLOCK + 0x14) // SYSTICK Reload value (24 bits are valid)
#define SYSTICK_CURRENT             *(volatile unsigned long *)(CORTEX_M4_BLOCK + 0x18) // SYSTICK Current value - write any value to it to clear to 0
  #define SYSTICK_COUNT_MASK        0x00ffffff                           // valid count width in registers
#define SYSTICK_CALIB               *(const unsigned long *)(CORTEX_M4_BLOCK + 0x1c) // SYSTICK Calibration value (not available in Stellaris devices) (read-only)

// NVIC
//
#define IRQ0_31_SER_ADD             ( unsigned long*)(CORTEX_M4_BLOCK + 0x100)
#define IRQ0_31_SER                 *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x100)// NVIC IRQ0..31    Set Enable Register
#define IRQ32_63_SER                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x104)// NVIC IRQ32..64   Set Enable Register
#define IRQ64_95_SER                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x108)// NVIC IRQ64..95   Set Enable Register
#define IRQ96_127_SER               *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x10c)// NVIC IRQ96..127  Set Enable Register
#define IRQ128_159_SER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x110)// NVIC IRQ128..159 Set Enable Register
#define IRQ160_191_SER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x114)// NVIC IRQ160..191 Set Enable Register
#define IRQ192_223_SER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x118)// NVIC IRQ192..223 Set Enable Register
#define IRQ224_239_SER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x11c)// NVIC IRQ224..239 Set Enable Register

#define IRQ0_31_CER                 *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x180)// NVIC IRQ0..31    Clear Enable Register
#define IRQ32_63_CER                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x184)// NVIC IRQ32..64   Clear Enable Register
#define IRQ64_95_CER                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x188)// NVIC IRQ64..95   Clear Enable Register
#define IRQ96_127_CER               *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x18c)// NVIC IRQ96..127  Clear Enable Register
#define IRQ128_159_CER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x190)// NVIC IRQ128..159 Clear Enable Register
#define IRQ160_191_CER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x194)// NVIC IRQ160..191 Clear Enable Register
#define IRQ192_223_CER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x198)// NVIC IRQ192..223 Clear Enable Register
#define IRQ224_239_CER              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x19c)// NVIC IRQ224..239 Clear Enable Register

#define IRQ0_31_SPR                 *( unsigned long*)(CORTEX_M4_BLOCK + 0x200)        // NVIC IRQ0..31    Set Pending Register
#define IRQ32_63_SPR                *( unsigned long*)(CORTEX_M4_BLOCK + 0x204)        // NVIC IRQ32..64   Set Pending Register
#define IRQ64_95_SPR                *( unsigned long*)(CORTEX_M4_BLOCK + 0x208)        // NVIC IRQ64..95   Set Pending Register
#define IRQ96_127_SPR               *( unsigned long*)(CORTEX_M4_BLOCK + 0x20c)        // NVIC IRQ96..127  Set Pending Register
#define IRQ128_159_SPR              *( unsigned long*)(CORTEX_M4_BLOCK + 0x210)        // NVIC IRQ128..159 Set Pending Register
#define IRQ160_191_SPR              *( unsigned long*)(CORTEX_M4_BLOCK + 0x214)        // NVIC IRQ160..191 Set Pending Register
#define IRQ192_223_SPR              *( unsigned long*)(CORTEX_M4_BLOCK + 0x218)        // NVIC IRQ192..223 Set Pending Register
#define IRQ224_239_SPR              *( unsigned long*)(CORTEX_M4_BLOCK + 0x21c)        // NVIC IRQ224..239 Set Pending Register

#define IRQ0_31_CPR_ADD             ( unsigned long*)(CORTEX_M4_BLOCK + 0x280)
#define IRQ0_31_CPR                 *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x280)// NVIC IRQ0..31    Clear Pending Register
#define IRQ32_63_CPR                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x284)// NVIC IRQ32..64   Clear Pending Register
#define IRQ64_95_CPR                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x288)// NVIC IRQ64..95   Clear Pending Register
#define IRQ96_127_CPR               *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x28c)// NVIC IRQ96..127  Clear Pending Register
#define IRQ128_159_CPR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x290)// NVIC IRQ128..159 Clear Pending Register
#define IRQ160_191_CPR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x294)// NVIC IRQ160..191 Clear Pending Register
#define IRQ192_223_CPR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x298)// NVIC IRQ192..223 Clear Pending Register
#define IRQ224_239_CPR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x29c)// NVIC IRQ224..239 Clear Pending Register

#define IRQ0_31_ABR                 *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x300)// NVIC IRQ0..31    Active Bit Register (read only)
#define IRQ32_63_ABR                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x304)// NVIC IRQ32..64   Active Bit Register (read only)
#define IRQ64_95_ABR                *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x308)// NVIC IRQ64..95   Active Bit Register (read only)
#define IRQ96_127_ABR               *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x30c)// NVIC IRQ96..127  Active Bit Register (read only)
#define IRQ128_159_ABR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x310)// NVIC IRQ128..159 Active Bit Register (read only)
#define IRQ160_191_ABR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x314)// NVIC IRQ160..191 Active Bit Register (read only)
#define IRQ192_223_ABR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x318)// NVIC IRQ192..223 Active Bit Register (read only)
#define IRQ224_239_ABR              *(volatile unsigned long*)(CORTEX_M4_BLOCK + 0x31c)// NVIC IRQ224..239 Active Bit Register (read only)

#define IRQ0_3_PRIORITY_REGISTER_ADD ( unsigned char *)(CORTEX_M4_BLOCK + 0x400)
#define IRQ0_3_PRIORITY_REGISTER    *( unsigned long *)(CORTEX_M4_BLOCK + 0x400)       // NVIC IRQ0..3     Priority Register
#define IRQ4_7_PRIORITY_REGISTER    *( unsigned long *)(CORTEX_M4_BLOCK + 0x404)       // NVIC IRQ4..7     Priority Register
#define IRQ8_11_PRIORITY_REGISTER   *( unsigned long *)(CORTEX_M4_BLOCK + 0x408)       // NVIC IRQ8..11    Priority Register
#define IRQ12_15_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x40c)       // NVIC IRQ12..15   Priority Register
#define IRQ16_19_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x410)       // NVIC IRQ16..19   Priority Register
#define IRQ20_23_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x414)       // NVIC IRQ20..23   Priority Register
#define IRQ24_27_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x418)       // NVIC IRQ24..27   Priority Register
#define IRQ28_31_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x41c)       // NVIC IRQ28..31   Priority Register
#define IRQ32_35_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x420)       // NVIC IRQ32..35   Priority Register
#define IRQ36_39_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x424)       // NVIC IRQ36..39   Priority Register
#define IRQ40_43_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x428)       // NVIC IRQ40..43   Priority Register
#define IRQ44_47_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x42c)       // NVIC IRQ44..47   Priority Register
#define IRQ48_51_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x430)       // NVIC IRQ48..51   Priority Register
#define IRQ52_55_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x434)       // NVIC IRQ52..55   Priority Register
#define IRQ56_59_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x438)       // NVIC IRQ56..59   Priority Register
#define IRQ60_63_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x43c)       // NVIC IRQ60..63   Priority Register
#define IRQ64_67_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x440)       // NVIC IRQ64..67   Priority Register
#define IRQ68_71_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x444)       // NVIC IRQ68..71   Priority Register
#define IRQ72_75_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x448)       // NVIC IRQ72..75   Priority Register
#define IRQ76_79_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x44c)       // NVIC IRQ76..79   Priority Register
#define IRQ80_83_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x450)       // NVIC IRQ80..83   Priority Register
#define IRQ84_87_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x454)       // NVIC IRQ84..87   Priority Register
#define IRQ88_91_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x458)       // NVIC IRQ88..91   Priority Register
#define IRQ92_95_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x45c)       // NVIC IRQ92..95   Priority Register
#define IRQ96_99_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x460)       // NVIC IRQ96..99   Priority Register
#define IRQ100_103_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x464)     // NVIC IRQ100..103   Priority Register
#define IRQ104_107_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x468)     // NVIC IRQ104..107   Priority Register
#define IRQ108_111_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x46c)     // NVIC IRQ108..111   Priority Register
#define IRQ112_115_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x470)     // NVIC IRQ112..115   Priority Register
#define IRQ116_119_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x474)     // NVIC IRQ116..119   Priority Register
#define IRQ120_123_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x478)     // NVIC IRQ120..123   Priority Register
#define IRQ124_127_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x47c)     // NVIC IRQ124..127   Priority Register
#define IRQ128_131_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x480)     // NVIC IRQ128..131   Priority Register
#define IRQ132_135_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x484)     // NVIC IRQ132..135   Priority Register
#define IRQ136_139_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x488)     // NVIC IRQ136..139   Priority Register
#define IRQ140_143_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x48c)     // NVIC IRQ140..143   Priority Register
#define IRQ144_147_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x490)     // NVIC IRQ144..147   Priority Register
#define IRQ148_151_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x494)     // NVIC IRQ148..151   Priority Register
#define IRQ152_155_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x498)     // NVIC IRQ152..155   Priority Register
#define IRQ156_159_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x49c)     // NVIC IRQ156..159   Priority Register
#define IRQ160_163_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4a0)     // NVIC IRQ160..163   Priority Register
#define IRQ164_167_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4a4)     // NVIC IRQ164..167   Priority Register
#define IRQ168_171_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4a8)     // NVIC IRQ168..171   Priority Register
#define IRQ172_175_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4ac)     // NVIC IRQ172..175   Priority Register
#define IRQ176_179_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4b0)     // NVIC IRQ176..179   Priority Register
#define IRQ180_183_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4b4)     // NVIC IRQ180..183   Priority Register
#define IRQ184_187_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4b8)     // NVIC IRQ184..187   Priority Register
#define IRQ188_191_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4bc)     // NVIC IRQ188..191   Priority Register
#define IRQ192_195_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4c0)     // NVIC IRQ192..195   Priority Register
#define IRQ196_199_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4c4)     // NVIC IRQ196..199   Priority Register
#define IRQ200_203_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4c8)     // NVIC IRQ200..203   Priority Register
#define IRQ204_207_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4cc)     // NVIC IRQ204..207   Priority Register
#define IRQ208_211_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4d0)     // NVIC IRQ208..211   Priority Register
#define IRQ212_215_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4d4)     // NVIC IRQ212..215   Priority Register
#define IRQ216_219_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4d8)     // NVIC IRQ216..219   Priority Register
#define IRQ220_223_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4dc)     // NVIC IRQ220..223   Priority Register
#define IRQ224_227_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4e0)     // NVIC IRQ224..227   Priority Register
#define IRQ228_231_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4e4)     // NVIC IRQ228..231   Priority Register
#define IRQ232_235_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4e8)     // NVIC IRQ232..235   Priority Register
#define IRQ236_239_PRIORITY_REGISTER  *( unsigned long *)(CORTEX_M4_BLOCK + 0x4ec)     // NVIC IRQ236..239   Priority Register

#define CPUID_BASE_REGISTER           *(unsigned long *)(CORTEX_M4_BLOCK + 0xd00)      // (read only)
#define INT_CONT_STATE_REG            *(volatile unsigned long *)(CORTEX_M4_BLOCK + 0xd04) // Interrupt Control State Register
  #define NMIPENDSET                  0x80000000                                       // set pending NMI bit
  #define PENDSVSET                   0x10000000                                       // set pending pendSV bit
  #define PENDSVCLR                   0x08000000                                       // clear pending pendSV bit
  #define PENDSTSET                   0x04000000                                       // set pending sysTick bit
  #define PENDSTCLR                   0x02000000                                       // clear pending sysTick bit
  #define ISRPREEMPT                  0x00800000                                       //
  #define ISRPENDING                  0x00400000                                       // Interrupt Pending Flag
  #define VECT_PENDING_MASK           0x003ff000                                       // Pending ISR number field
  #define RETTOBASE                   0x00000800                                       //
  #define VECT_ACTIVE_MASK            0x00000010                                       // Active ISR number field
#define VECTOR_TABLE_OFFSET_REG       *(unsigned long *)(CORTEX_M4_BLOCK + 0xd08) // Interrupt Control State Register
  #define TBLBASE_IN_RAM              0x20000000 // vector table base is in RAM
  #define TBLBASE_IN_CODE             0x00000000
  #define TBLOFF_MASK                 0x1fffff80  // table offset from bottom of Code / RAM
#define APPLICATION_INT_RESET_CTR_REG *(unsigned long *)(CORTEX_M4_BLOCK + 0xd0c)      // Application Interrupt and Reset Control Register
  #define VECTKEY                     0x05fa0000
  #define ENDIANESS_BIG               0x00008000
  #define ENDIANESS_LITTLE            0x00000000
  #define PRIGROUP_7_1                0x00000100
  #define PRIGROUP_6_2                0x00000200
  #define PRIGROUP_5_3                0x00000300
  #define PRIGROUP_4_4                0x00000400
  #define PRIGROUP_3_5                0x00000500
  #define PRIGROUP_2_6                0x00000600
  #define PRIGROUP_1_7                0x00000700
  #define PRIGROUP_0_8                0x00000800
  #define SYSRESETREQ                 0x00000004
  #define VECTCLRACTIVE               0x00000002
  #define VECTRESET                   0x00000001
#define SYSTEM_CONTROL_REGISTER       *(volatile unsigned long *)(CORTEX_M4_BLOCK + 0xd10) // System Control Register
  #define SLEEPONEXIT                 0x00000002
  #define SLEEPDEEP                   0x00000004
  #define SEVONPEND                   0x00000010
#define CONFIGURATION_CONTROL_REGISTER *(unsigned long *)(CORTEX_M4_BLOCK + 0xd14)     // Configuration Control Register

#define SYSTEM_HANDLER_4_7_PRIORITY_REGISTER *(unsigned long *)(CORTEX_M4_BLOCK + 0xd18) // System Handler Priority Register 4..7
#define SYSTEM_HANDLER_8_11_PRIORITY_REGISTER *(unsigned long *)(CORTEX_M4_BLOCK + 0xd1c) // System Handler Priority Register 8..11
#define SYSTEM_HANDLER_12_15_PRIORITY_REGISTER *(unsigned long *)(CORTEX_M4_BLOCK + 0xd20) // System Handler Priority Register 12..15

#define CPACR *(unsigned long *)(CORTEX_M4_BLOCK + 0xd88)                // {13} Co-processor Access Control Register

#if defined KINETIS_K_FPU
    #define __FPU_PRESENT  1
#endif
